{"version":3,"sources":["../src/index.ts","../src/global/constants.ts","../src/types/api/index.ts","../src/types/api/jsonrpc/index.ts","../src/types/api/rpcspec_0_6/index.ts","../src/types/api/rpcspec_0_6/errors.ts","../src/types/api/rpcspec_0_6/components.ts","../src/types/api/rpcspec_0_6/nonspec.ts","../src/utils/encode.ts","../src/channel/rpc_0_6.ts","../src/utils/json.ts","../src/utils/errors/rpc.ts","../src/utils/errors/index.ts","../src/types/index.ts","../src/types/lib/contract/index.ts","../src/types/lib/index.ts","../src/types/calldata.ts","../src/types/outsideExecution.ts","../src/types/typedData.ts","../src/utils/batch/index.ts","../src/utils/assert.ts","../src/utils/num.ts","../src/utils/typed.ts","../src/utils/hash/selector.ts","../src/utils/shortString.ts","../src/utils/calldata/byteArray.ts","../src/utils/calldata/cairo.ts","../src/utils/cairoDataTypes/felt.ts","../src/utils/cairoDataTypes/uint256.ts","../src/utils/cairoDataTypes/uint512.ts","../src/utils/calldata/enum/CairoCustomEnum.ts","../src/utils/calldata/enum/CairoOption.ts","../src/utils/calldata/enum/CairoResult.ts","../src/utils/calldata/formatter.ts","../src/utils/calldata/parser/parser-0-1.1.0.ts","../src/utils/calldata/parser/parser-2.0.0.ts","../src/utils/calldata/parser/index.ts","../src/utils/calldata/tuple.ts","../src/utils/cairoDataTypes/fixedArray.ts","../src/utils/calldata/propertyOrder.ts","../src/utils/calldata/requestParser.ts","../src/utils/calldata/responseParser.ts","../src/utils/calldata/validate.ts","../src/utils/calldata/index.ts","../src/utils/hash/index.ts","../src/utils/hash/transactionHash/v2.ts","../src/utils/ec.ts","../src/utils/hash/transactionHash/v3.ts","../src/utils/hash/transactionHash/index.ts","../src/utils/hash/classHash.ts","../src/utils/stark.ts","../src/utils/contract.ts","../src/utils/eth.ts","../src/utils/fetchPonyfill.ts","../src/utils/provider.ts","../src/global/config.ts","../src/global/logger.type.ts","../src/global/logger.ts","../src/utils/transaction.ts","../src/channel/rpc_0_7.ts","../src/utils/responseParser/rpc.ts","../src/utils/transactionReceipt.ts","../src/utils/typedData.ts","../src/utils/merkle.ts","../src/provider/rpc.ts","../src/provider/extensions/default.ts","../src/utils/starknetId.ts","../src/provider/extensions/starknetId.ts","../src/provider/interface.ts","../src/provider/index.ts","../src/signer/interface.ts","../src/signer/default.ts","../src/signer/ethSigner.ts","../src/utils/uint256.ts","../src/signer/ledgerSigner111.ts","../src/utils/address.ts","../src/signer/ledgerSigner221.ts","../src/utils/events/index.ts","../src/utils/outsideExecution.ts","../src/utils/src5.ts","../src/account/default.ts","../src/account/interface.ts","../src/wallet/connect.ts","../src/wallet/account.ts","../src/contract/default.ts","../src/contract/interface.ts","../src/contract/contractFactory.ts","../src/utils/responseParser/interface.ts","../src/utils/units.ts"],"sourcesContent":["/**\n * Main\n */\nexport * from './wallet';\nexport * from './account';\nexport * from './contract';\nexport * from './provider';\nexport * from './signer';\nexport * from './channel';\n\n// TODO: decide on final export style\nexport * from './types';\nexport * as types from './types';\n\n/**\n * Utils\n */\nexport * as constants from './global/constants';\nexport * as encode from './utils/encode';\nexport * as hash from './utils/hash';\nexport * as v3hash from './utils/hash/transactionHash/v3';\nexport * as v2hash from './utils/hash/transactionHash/v2';\nexport * as json from './utils/json';\nexport * as num from './utils/num';\nexport * as transaction from './utils/transaction';\nexport * as stark from './utils/stark';\nexport * as eth from './utils/eth';\nexport * as merkle from './utils/merkle';\nexport * as uint256 from './utils/uint256';\nexport * as shortString from './utils/shortString';\nexport * as typedData from './utils/typedData';\nexport * as ec from './utils/ec';\nexport * as starknetId from './utils/starknetId';\nexport * as provider from './utils/provider';\nexport * as selector from './utils/hash/selector';\nexport * as events from './utils/events';\nexport * as outsideExecution from './utils/outsideExecution';\nexport * as src5 from './utils/src5';\nexport * from './utils/batch';\nexport * from './utils/responseParser';\nexport * from './utils/cairoDataTypes/uint256';\nexport * from './utils/cairoDataTypes/uint512';\nexport * from './utils/cairoDataTypes/fixedArray';\nexport * from './utils/address';\nexport * from './utils/calldata';\nexport * from './utils/calldata/enum';\nexport * from './utils/contract';\nexport * from './utils/transactionReceipt';\nexport * from './utils/units';\nexport * as wallet from './wallet/connect';\nexport * from './global/config';\nexport * from './global/logger';\nexport * from './global/logger.type';\n\n/**\n * Deprecated\n */\n/* eslint-disable import/first */\nimport * as num from './utils/num';\n\n/** @deprecated prefer the 'num' naming */\nexport const number = num;\n","import { ETransactionVersion } from '../types/api';\nimport { type LogLevel } from './logger.type';\n\nexport { IS_BROWSER } from '../utils/encode';\n\n/**\n * Cairo Felt support storing max 31 character\n */\nexport const TEXT_TO_FELT_MAX_LEN = 31;\n\n/**\n * Alternatively use directly from api specification\n * types.RPC.ETransactionVersion\n * For BN do BigInt(TRANSACTION_VERSION.*)\n */\nexport { ETransactionVersion as TRANSACTION_VERSION };\n\nexport const ZERO = 0n;\nexport const MASK_250 = 2n ** 250n - 1n; // 2 ** 250 - 1\nexport const MASK_31 = 2n ** 31n - 1n; // 2 ** 31 - 1\nexport const API_VERSION = ZERO;\nexport const PRIME = 2n ** 251n + 17n * 2n ** 192n + 1n;\n\n// based on: https://github.com/starkware-libs/cairo-lang/blob/v0.12.3/src/starkware/starknet/common/storage.cairo#L3\nexport const MAX_STORAGE_ITEM_SIZE = 256n;\nexport const ADDR_BOUND = 2n ** 251n - MAX_STORAGE_ITEM_SIZE;\n\nconst range = (min: bigint, max: bigint) => ({ min, max }) as const;\n\nexport const RANGE_FELT = range(ZERO, PRIME - 1n);\nexport const RANGE_I128 = range(-(2n ** 127n), 2n ** 127n - 1n);\nexport const RANGE_U128 = range(ZERO, 2n ** 128n - 1n);\n\nexport enum BaseUrl {\n  SN_MAIN = 'https://alpha-mainnet.starknet.io',\n  SN_SEPOLIA = 'https://alpha-sepolia.starknet.io',\n}\n\nexport enum NetworkName {\n  SN_MAIN = 'SN_MAIN',\n  SN_SEPOLIA = 'SN_SEPOLIA',\n}\n\nexport enum StarknetChainId {\n  SN_MAIN = '0x534e5f4d41494e', // encodeShortString('SN_MAIN'),\n  SN_SEPOLIA = '0x534e5f5345504f4c4941', // encodeShortString('SN_SEPOLIA')\n}\n\nexport enum TransactionHashPrefix {\n  DECLARE = '0x6465636c617265', // encodeShortString('declare'),\n  DEPLOY = '0x6465706c6f79', // encodeShortString('deploy'),\n  DEPLOY_ACCOUNT = '0x6465706c6f795f6163636f756e74', // encodeShortString('deploy_account'),\n  INVOKE = '0x696e766f6b65', // encodeShortString('invoke'),\n  L1_HANDLER = '0x6c315f68616e646c6572', // encodeShortString('l1_handler'),\n}\n\nexport const enum FeeMarginPercentage {\n  L1_BOUND_MAX_AMOUNT = 50,\n  L1_BOUND_MAX_PRICE_PER_UNIT = 50,\n  MAX_FEE = 50,\n}\n\nexport const UDC = {\n  ADDRESS: '0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf',\n  ENTRYPOINT: 'deployContract',\n} as const;\n\nexport const RPC_DEFAULT_VERSION = 'v0_7';\n\nexport const RPC_NODES = {\n  SN_MAIN: [\n    `https://starknet-mainnet.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n    `https://free-rpc.nethermind.io/mainnet-juno/${RPC_DEFAULT_VERSION}`,\n  ],\n  SN_SEPOLIA: [\n    `https://starknet-sepolia.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n    `https://free-rpc.nethermind.io/sepolia-juno/${RPC_DEFAULT_VERSION}`,\n  ],\n} as const;\n\nexport const OutsideExecutionCallerAny = '0x414e595f43414c4c4552'; // encodeShortString('ANY_CALLER')\nexport const SNIP9_V1_INTERFACE_ID =\n  '0x68cfd18b92d1907b8ba3cc324900277f5a3622099431ea85dd8089255e4181';\nexport const SNIP9_V2_INTERFACE_ID =\n  '0x1d1144bb2138366ff28d8e9ab57456b1d332ac42196230c3a602003c89872';\n\n// Ledger signer\n// 0x80\nexport const HARDENING_BYTE = 128;\n// 0x80000000\nexport const HARDENING_4BYTES = 2147483648n;\n\n// Default initial global config\nexport const DEFAULT_GLOBAL_CONFIG: {\n  legacyMode: boolean;\n  logLevel: LogLevel;\n  accountTxVersion: typeof ETransactionVersion.V2 | typeof ETransactionVersion.V3;\n} = {\n  legacyMode: false,\n  logLevel: 'INFO',\n  accountTxVersion: ETransactionVersion.V2,\n};\n\n// Default system messages\nexport const SYSTEM_MESSAGES = {\n  legacyTxWarningMessage:\n    'You are using a deprecated transaction version (V0,V1,V2)!\\nUpdate to the latest V3 transactions!',\n};\n","export * as JRPC from './jsonrpc';\n\nexport * as RPCSPEC06 from './rpcspec_0_6';\nexport * as RPCSPEC07 from 'starknet-types-07';\nexport * from 'starknet-types-07';\n","export type RequestBody = {\n  id: number | string;\n  jsonrpc: '2.0';\n  method: string;\n  params?: {};\n};\n\nexport type ResponseBody = {\n  id: number | string;\n  jsonrpc: '2.0';\n} & (SuccessResponseBody | ErrorResponseBody);\n\nexport type SuccessResponseBody = {\n  result: unknown;\n};\n\nexport type ErrorResponseBody = {\n  error: Error;\n};\n\nexport type Error = {\n  code: number;\n  message: string;\n  data?: unknown;\n};\n","/**\n * version 0.6.0\n */\n\nexport * from './methods';\nexport * from './contract';\nexport * as Errors from './errors';\nexport * as SPEC from './components';\nexport * from './nonspec';\n","export interface FAILED_TO_RECEIVE_TXN {\n  code: 1;\n  message: 'Failed to write transaction';\n}\n\nexport interface NO_TRACE_AVAILABLE {\n  code: 10;\n  message: 'No trace available for transaction';\n  data: {\n    status: 'RECEIVED' | 'REJECTED';\n  };\n}\n\nexport interface CONTRACT_NOT_FOUND {\n  code: 20;\n  message: 'Contract not found';\n}\n\nexport interface INVALID_MESSAGE_SELECTOR {\n  code: 21;\n  message: 'Invalid message selector';\n}\n\nexport interface INVALID_CALL_DATA {\n  code: 22;\n  message: 'Invalid call data';\n}\n\nexport interface BLOCK_NOT_FOUND {\n  code: 24;\n  message: 'Block not found';\n}\n\nexport interface INVALID_BLOCK_HASH {\n  code: 26;\n  message: 'Invalid block hash';\n}\n\nexport interface INVALID_TXN_INDEX {\n  code: 27;\n  message: 'Invalid transaction index in a block';\n}\n\nexport interface CLASS_HASH_NOT_FOUND {\n  code: 28;\n  message: 'Class hash not found';\n}\n\nexport interface TXN_HASH_NOT_FOUND {\n  code: 29;\n  message: 'Transaction hash not found';\n}\n\nexport interface PAGE_SIZE_TOO_BIG {\n  code: 31;\n  message: 'Requested page size is too big';\n}\n\nexport interface NO_BLOCKS {\n  code: 32;\n  message: 'There are no blocks';\n}\n\nexport interface INVALID_CONTINUATION_TOKEN {\n  code: 33;\n  message: 'The supplied continuation token is invalid or unknown';\n}\n\nexport interface TOO_MANY_KEYS_IN_FILTER {\n  code: 34;\n  message: 'Too many keys provided in a filter';\n}\n\nexport interface CONTRACT_ERROR {\n  code: 40;\n  message: 'Contract error';\n  data: {\n    revert_error: string;\n  };\n}\n\nexport interface TRANSACTION_EXECUTION_ERROR {\n  code: 41;\n  message: 'Transaction execution error';\n  data: {\n    transaction_index: number;\n    execution_error: string;\n  };\n}\n\nexport interface CLASS_ALREADY_DECLARED {\n  code: 51;\n  message: 'Class already declared';\n}\n\nexport interface INVALID_TRANSACTION_NONCE {\n  code: 52;\n  message: 'Invalid transaction nonce';\n}\n\nexport interface INSUFFICIENT_MAX_FEE {\n  code: 53;\n  message: 'Max fee is smaller than the minimal transaction cost (validation plus fee transfer)';\n}\n\nexport interface INSUFFICIENT_ACCOUNT_BALANCE {\n  code: 54;\n  message: \"Account balance is smaller than the transaction's max_fee\";\n}\n\nexport interface VALIDATION_FAILURE {\n  code: 55;\n  message: 'Account validation failed';\n  data: string;\n}\n\nexport interface COMPILATION_FAILED {\n  code: 56;\n  message: 'Compilation failed';\n}\n\nexport interface CONTRACT_CLASS_SIZE_IS_TOO_LARGE {\n  code: 57;\n  message: 'Contract class size it too large';\n}\n\nexport interface NON_ACCOUNT {\n  code: 58;\n  message: 'Sender address in not an account contract';\n}\n\nexport interface DUPLICATE_TX {\n  code: 59;\n  message: 'A transaction with the same hash already exists in the mempool';\n}\n\nexport interface COMPILED_CLASS_HASH_MISMATCH {\n  code: 60;\n  message: 'the compiled class hash did not match the one supplied in the transaction';\n}\n\nexport interface UNSUPPORTED_TX_VERSION {\n  code: 61;\n  message: 'the transaction version is not supported';\n}\n\nexport interface UNSUPPORTED_CONTRACT_CLASS_VERSION {\n  code: 62;\n  message: 'the contract class version is not supported';\n}\n\nexport interface UNEXPECTED_ERROR {\n  code: 63;\n  message: 'An unexpected error occurred';\n  data: string;\n}\n","/**\n * PRIMITIVES\n */\n\n/**\n * A field element. represented by at most 63 hex digits\n * @pattern ^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,62})$\n */\nexport type FELT = string;\n/**\n * an ethereum address represented as 40 hex digits\n * @pattern ^0x[a-fA-F0-9]{40}$\n */\nexport type ETH_ADDRESS = string;\n/**\n * A storage key. Represented as up to 62 hex digits, 3 bits, and 5 leading zeroes.\n * @pattern ^0x0[0-7]{1}[a-fA-F0-9]{0,62}$\n */\nexport type STORAGE_KEY = string;\nexport type ADDRESS = FELT;\nexport type NUM_AS_HEX = string;\n/**\n * 64 bit integers, represented by hex string of length at most 16\n * \"pattern\": \"^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,15})$\"\n */\nexport type u64 = string;\n/**\n * 64 bit integers, represented by hex string of length at most 32\n * \"pattern\": \"^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,31})$\"\n */\nexport type u128 = string;\nexport type SIGNATURE = Array<FELT>;\nexport type BLOCK_NUMBER = number;\nexport type BLOCK_HASH = FELT;\nexport type TXN_HASH = FELT;\nexport type CHAIN_ID = NUM_AS_HEX;\nexport type STRUCT_ABI_TYPE = 'struct';\nexport type EVENT_ABI_TYPE = 'event';\nexport type FUNCTION_ABI_TYPE = 'function' | 'l1_handler' | 'constructor';\n// Represents the type of an entry point.\nexport type ENTRY_POINT_TYPE = 'EXTERNAL' | 'L1_HANDLER' | 'CONSTRUCTOR';\n// Represents the type of a function call.\nexport type CALL_TYPE = 'DELEGATE' | 'LIBRARY_CALL' | 'CALL';\n// Represents the status of the transaction\nexport type TXN_STATUS = 'RECEIVED' | 'REJECTED' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1';\n// Flags that indicate how to simulate a given transaction. By default, the sequencer behavior is replicated locally (enough funds are expected to be in the account, and the fee will be deducted from the balance before the simulation of the next transaction). To skip the fee charge, use the SKIP_FEE_CHARGE flag.\nexport type SIMULATION_FLAG = 'SKIP_VALIDATE' | 'SKIP_FEE_CHARGE';\n// Data availability mode\nexport type DA_MODE = 'L1' | 'L2';\nexport type TXN_TYPE = 'DECLARE' | 'DEPLOY' | 'DEPLOY_ACCOUNT' | 'INVOKE' | 'L1_HANDLER';\nexport type TXN_FINALITY_STATUS = 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1';\nexport type TXN_EXECUTION_STATUS = 'SUCCEEDED' | 'REVERTED';\nexport type BLOCK_STATUS = 'PENDING' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1' | 'REJECTED';\nexport type BLOCK_TAG = 'latest' | 'pending';\n\n/**\n * READ API\n */\n\nexport type EVENTS_CHUNK = {\n  // Returns matching events\n  events: EMITTED_EVENT[];\n  // Use this token in a subsequent query to obtain the next page. Should not appear if there are no more pages.\n  continuation_token?: string;\n};\n\nexport type RESULT_PAGE_REQUEST = {\n  // The token returned from the previous query. If no token is provided the first page is returned.\n  continuation_token?: string;\n  // Chunk size\n  chunk_size: number;\n};\n\nexport type EMITTED_EVENT = EVENT & {\n  block_hash: BLOCK_HASH;\n  block_number: BLOCK_NUMBER;\n  transaction_hash: TXN_HASH;\n};\n\nexport type EVENT = {\n  from_address: ADDRESS;\n} & EVENT_CONTENT;\n\nexport type EVENT_CONTENT = {\n  keys: FELT[];\n  data: FELT[];\n};\n\nexport type EVENT_FILTER = {\n  from_block?: BLOCK_ID;\n  to_block?: BLOCK_ID;\n  address?: ADDRESS;\n  keys?: FELT[][];\n};\n\nexport type BLOCK_ID =\n  | {\n      block_hash?: BLOCK_HASH;\n      block_number?: BLOCK_NUMBER;\n    }\n  | BLOCK_TAG;\n\nexport type SYNC_STATUS = {\n  starting_block_hash: BLOCK_HASH;\n  starting_block_num: BLOCK_NUMBER;\n  current_block_hash: BLOCK_HASH;\n  current_block_num: BLOCK_NUMBER;\n  highest_block_hash: BLOCK_HASH;\n  highest_block_num: BLOCK_NUMBER;\n};\n\nexport type NEW_CLASSES = {\n  class_hash: FELT;\n  compiled_class_hash: FELT;\n};\n\nexport type REPLACED_CLASS = {\n  class_hash: FELT;\n  contract_address: FELT;\n};\n\nexport type NONCE_UPDATE = {\n  contract_address: ADDRESS;\n  nonce: FELT;\n};\n\nexport type STATE_DIFF = {\n  storage_diffs: CONTRACT_STORAGE_DIFF_ITEM[];\n  deprecated_declared_classes: FELT[];\n  declared_classes: NEW_CLASSES[];\n  deployed_contracts: DEPLOYED_CONTRACT_ITEM[];\n  replaced_classes: REPLACED_CLASS[];\n  nonces: NONCE_UPDATE[];\n};\n\nexport type PENDING_STATE_UPDATE = {\n  old_root: FELT;\n  state_diff: STATE_DIFF;\n  block_hash: never; // diverge: this makes it distinct\n};\n\nexport type STATE_UPDATE = {\n  block_hash: BLOCK_HASH;\n  old_root: FELT;\n  new_root: FELT;\n  state_diff: STATE_DIFF;\n};\n\nexport type BLOCK_BODY_WITH_TX_HASHES = {\n  transactions: TXN_HASH[];\n};\n\nexport type BLOCK_BODY_WITH_TXS = {\n  transactions: (TXN & {\n    transaction_hash: TXN_HASH;\n  })[];\n};\n\nexport type BLOCK_HEADER = {\n  block_hash: BLOCK_HASH;\n  parent_hash: BLOCK_HASH;\n  block_number: BLOCK_NUMBER;\n  new_root: FELT;\n  timestamp: number;\n  sequencer_address: FELT;\n  l1_gas_price: RESOURCE_PRICE;\n  starknet_version: string;\n};\n\nexport type PENDING_BLOCK_HEADER = {\n  parent_hash: BLOCK_HASH;\n  timestamp: number;\n  sequencer_address: FELT;\n  l1_gas_price: RESOURCE_PRICE;\n  starknet_version: string;\n};\n\nexport type BLOCK_WITH_TX_HASHES = { status: BLOCK_STATUS } & BLOCK_HEADER &\n  BLOCK_BODY_WITH_TX_HASHES;\n\nexport type BLOCK_WITH_TXS = { status: BLOCK_STATUS } & BLOCK_HEADER & BLOCK_BODY_WITH_TXS;\n\nexport type PENDING_BLOCK_WITH_TX_HASHES = BLOCK_BODY_WITH_TX_HASHES & PENDING_BLOCK_HEADER;\n\nexport type PENDING_BLOCK_WITH_TXS = BLOCK_BODY_WITH_TXS & PENDING_BLOCK_HEADER;\n\nexport type DEPLOYED_CONTRACT_ITEM = {\n  address: FELT;\n  class_hash: FELT;\n};\n\nexport type CONTRACT_STORAGE_DIFF_ITEM = {\n  // The contract address for which the storage changed (in FELT format)\n  address: string;\n  // The changes in the storage of the contract\n  storage_entries: StorageDiffItem[];\n};\n\nexport type StorageDiffItem = {\n  // The key of the changed value (in FELT format)\n  key: string;\n  // The new value applied to the given address (in FELT format)\n  value: string;\n};\n\nexport type TXN = INVOKE_TXN | L1_HANDLER_TXN | DECLARE_TXN | DEPLOY_TXN | DEPLOY_ACCOUNT_TXN;\n\nexport type DECLARE_TXN = DECLARE_TXN_V0 | DECLARE_TXN_V1 | DECLARE_TXN_V2 | DECLARE_TXN_V3;\n\nexport type DECLARE_TXN_V0 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  max_fee: FELT;\n  version: '0x0' | '0x100000000000000000000000000000000';\n  signature: SIGNATURE;\n  class_hash: FELT;\n};\n\nexport type DECLARE_TXN_V1 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  max_fee: FELT;\n  version: '0x1' | '0x100000000000000000000000000000001';\n  signature: SIGNATURE;\n  nonce: FELT;\n  class_hash: FELT;\n};\n\nexport type DECLARE_TXN_V2 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  compiled_class_hash: FELT;\n  max_fee: FELT;\n  version: '0x2' | '0x100000000000000000000000000000002';\n  signature: SIGNATURE;\n  nonce: FELT;\n  class_hash: FELT;\n};\n\nexport type DECLARE_TXN_V3 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  compiled_class_hash: FELT;\n  version: '0x3' | '0x100000000000000000000000000000003';\n  signature: SIGNATURE;\n  nonce: FELT;\n  class_hash: FELT;\n  // new...\n  resource_bounds: RESOURCE_BOUNDS_MAPPING;\n  tip: u64;\n  paymaster_data: FELT[];\n  account_deployment_data: FELT[];\n  nonce_data_availability_mode: DA_MODE;\n  fee_data_availability_mode: DA_MODE;\n};\n\nexport type BROADCASTED_TXN =\n  | BROADCASTED_INVOKE_TXN\n  | BROADCASTED_DECLARE_TXN\n  | BROADCASTED_DEPLOY_ACCOUNT_TXN;\n\nexport type BROADCASTED_INVOKE_TXN = INVOKE_TXN;\n\nexport type BROADCASTED_DEPLOY_ACCOUNT_TXN = DEPLOY_ACCOUNT_TXN;\n\nexport type BROADCASTED_DECLARE_TXN =\n  | BROADCASTED_DECLARE_TXN_V1\n  | BROADCASTED_DECLARE_TXN_V2\n  | BROADCASTED_DECLARE_TXN_V3;\n\nexport type BROADCASTED_DECLARE_TXN_V1 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  max_fee: FELT;\n  // todo: check if working, prev i fixed it with NUM_AS_HEX\n  version: '0x1' | '0x100000000000000000000000000000001';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_class: DEPRECATED_CONTRACT_CLASS;\n};\n\nexport type BROADCASTED_DECLARE_TXN_V2 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  compiled_class_hash: FELT;\n  max_fee: FELT;\n  version: '0x2' | '0x100000000000000000000000000000002';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_class: CONTRACT_CLASS;\n};\n\nexport type BROADCASTED_DECLARE_TXN_V3 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  compiled_class_hash: FELT;\n  version: '0x3' | '0x100000000000000000000000000000003';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_class: CONTRACT_CLASS;\n  // new...\n  resource_bounds: RESOURCE_BOUNDS_MAPPING;\n  tip: u64;\n  paymaster_data: FELT[];\n  account_deployment_data: FELT[];\n  nonce_data_availability_mode: DA_MODE;\n  fee_data_availability_mode: DA_MODE;\n};\n\nexport type DEPLOY_ACCOUNT_TXN = DEPLOY_ACCOUNT_TXN_V1 | DEPLOY_ACCOUNT_TXN_V3;\n\nexport type DEPLOY_ACCOUNT_TXN_V1 = {\n  type: 'DEPLOY_ACCOUNT';\n  max_fee: FELT;\n  version: '0x1' | '0x100000000000000000000000000000001';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_address_salt: FELT;\n  constructor_calldata: FELT[];\n  class_hash: FELT;\n};\n\nexport type DEPLOY_ACCOUNT_TXN_V3 = {\n  type: 'DEPLOY_ACCOUNT';\n  version: '0x3' | '0x100000000000000000000000000000003';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_address_salt: FELT;\n  constructor_calldata: FELT[];\n  class_hash: FELT;\n  resource_bounds: RESOURCE_BOUNDS_MAPPING;\n  tip: u64;\n  paymaster_data: FELT[];\n  nonce_data_availability_mode: DA_MODE;\n  fee_data_availability_mode: DA_MODE;\n};\n\nexport type DEPLOY_TXN = {\n  type: 'DEPLOY';\n  version: FELT;\n  contract_address_salt: FELT;\n  constructor_calldata: FELT[];\n  class_hash: FELT;\n};\n\nexport type INVOKE_TXN = INVOKE_TXN_V0 | INVOKE_TXN_V1 | INVOKE_TXN_V3;\n\nexport type INVOKE_TXN_V0 = {\n  type: 'INVOKE';\n  max_fee: FELT;\n  version: '0x0' | '0x100000000000000000000000000000000';\n  signature: SIGNATURE;\n  contract_address: ADDRESS;\n  entry_point_selector: FELT;\n  calldata: FELT[];\n};\n\nexport type INVOKE_TXN_V1 = {\n  type: 'INVOKE';\n  sender_address: ADDRESS;\n  calldata: FELT[];\n  max_fee: FELT;\n  version: '0x1' | '0x100000000000000000000000000000001';\n  signature: SIGNATURE;\n  nonce: FELT;\n};\n\nexport type INVOKE_TXN_V3 = {\n  type: 'INVOKE';\n  sender_address: ADDRESS;\n  calldata: FELT[];\n  version: '0x3' | '0x100000000000000000000000000000003';\n  signature: SIGNATURE;\n  nonce: FELT;\n  resource_bounds: RESOURCE_BOUNDS_MAPPING;\n  tip: u64;\n  paymaster_data: FELT[];\n  account_deployment_data: FELT[];\n  nonce_data_availability_mode: DA_MODE;\n  fee_data_availability_mode: DA_MODE;\n};\n\nexport type L1_HANDLER_TXN = {\n  version: FELT;\n  type: 'L1_HANDLER';\n  nonce: NUM_AS_HEX;\n} & FUNCTION_CALL;\n\nexport type COMMON_RECEIPT_PROPERTIES = {\n  transaction_hash: TXN_HASH;\n  actual_fee: FEE_PAYMENT;\n  execution_status: TXN_EXECUTION_STATUS;\n  finality_status: TXN_FINALITY_STATUS;\n  block_hash: BLOCK_HASH;\n  block_number: BLOCK_NUMBER;\n  messages_sent: MSG_TO_L1[];\n  revert_reason?: string;\n  events: EVENT[];\n  execution_resources: EXECUTION_RESOURCES;\n};\n\nexport type PENDING_COMMON_RECEIPT_PROPERTIES = {\n  transaction_hash: TXN_HASH;\n  actual_fee: FEE_PAYMENT;\n  messages_sent: MSG_TO_L1[];\n  events: EVENT[];\n  revert_reason?: string;\n  finality_status: 'ACCEPTED_ON_L2';\n  execution_status: TXN_EXECUTION_STATUS;\n  execution_resources: EXECUTION_RESOURCES;\n};\n\nexport type INVOKE_TXN_RECEIPT = {\n  type: 'INVOKE';\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type PENDING_INVOKE_TXN_RECEIPT = {\n  type: 'INVOKE';\n} & PENDING_COMMON_RECEIPT_PROPERTIES;\n\nexport type DECLARE_TXN_RECEIPT = {\n  type: 'DECLARE';\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type PENDING_DECLARE_TXN_RECEIPT = {\n  type: 'DECLARE';\n} & PENDING_COMMON_RECEIPT_PROPERTIES;\n\nexport type DEPLOY_ACCOUNT_TXN_RECEIPT = {\n  type: 'DEPLOY_ACCOUNT';\n  contract_address: FELT;\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type PENDING_DEPLOY_ACCOUNT_TXN_RECEIPT = {\n  type: 'DEPLOY_ACCOUNT';\n  contract_address: FELT;\n} & PENDING_COMMON_RECEIPT_PROPERTIES;\n\nexport type DEPLOY_TXN_RECEIPT = {\n  type: 'DEPLOY';\n  contract_address: FELT;\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type L1_HANDLER_TXN_RECEIPT = {\n  type: 'L1_HANDLER';\n  message_hash: NUM_AS_HEX;\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type PENDING_L1_HANDLER_TXN_RECEIPT = {\n  type: 'L1_HANDLER';\n  message_hash: NUM_AS_HEX;\n} & PENDING_COMMON_RECEIPT_PROPERTIES;\n\nexport type TXN_RECEIPT =\n  | INVOKE_TXN_RECEIPT\n  | L1_HANDLER_TXN_RECEIPT\n  | DECLARE_TXN_RECEIPT\n  | DEPLOY_TXN_RECEIPT\n  | DEPLOY_ACCOUNT_TXN_RECEIPT;\n\nexport type PENDING_TXN_RECEIPT =\n  | PENDING_INVOKE_TXN_RECEIPT\n  | PENDING_L1_HANDLER_TXN_RECEIPT\n  | PENDING_DECLARE_TXN_RECEIPT\n  | PENDING_DEPLOY_ACCOUNT_TXN_RECEIPT;\n\nexport type MSG_TO_L1 = {\n  from_address: FELT;\n  to_address: FELT;\n  payload: FELT[];\n};\n\nexport type MSG_FROM_L1 = {\n  from_address: ETH_ADDRESS;\n  to_address: ADDRESS;\n  entry_point_selector: FELT;\n  payload: FELT[];\n};\n\nexport type FUNCTION_CALL = {\n  contract_address: ADDRESS;\n  entry_point_selector: FELT;\n  calldata: FELT[];\n};\n\nexport type CONTRACT_CLASS = {\n  sierra_program: FELT[];\n  contract_class_version: string;\n  entry_points_by_type: {\n    CONSTRUCTOR: SIERRA_ENTRY_POINT[];\n    EXTERNAL: SIERRA_ENTRY_POINT[];\n    L1_HANDLER: SIERRA_ENTRY_POINT[];\n  };\n  abi: string;\n};\n\nexport type DEPRECATED_CONTRACT_CLASS = {\n  program: string;\n  entry_points_by_type: {\n    CONSTRUCTOR: DEPRECATED_CAIRO_ENTRY_POINT[];\n    EXTERNAL: DEPRECATED_CAIRO_ENTRY_POINT[];\n    L1_HANDLER: DEPRECATED_CAIRO_ENTRY_POINT[];\n  };\n  abi: CONTRACT_ABI;\n};\n\nexport type DEPRECATED_CAIRO_ENTRY_POINT = {\n  offset: NUM_AS_HEX | number;\n  selector: FELT;\n};\n\nexport type SIERRA_ENTRY_POINT = {\n  selector: FELT;\n  function_idx: number;\n};\n\nexport type CONTRACT_ABI = readonly CONTRACT_ABI_ENTRY[];\n\nexport type CONTRACT_ABI_ENTRY = {\n  selector: FELT;\n  input: string;\n  output: string;\n};\n\nexport type STRUCT_ABI_ENTRY = {\n  type: STRUCT_ABI_TYPE;\n  name: string;\n  size: number;\n  members: STRUCT_MEMBER[];\n};\n\nexport type STRUCT_MEMBER = TYPED_PARAMETER & {\n  offset: number;\n};\n\nexport type EVENT_ABI_ENTRY = {\n  type: EVENT_ABI_TYPE;\n  name: string;\n  keys: TYPED_PARAMETER[];\n  data: TYPED_PARAMETER[];\n};\n\nexport type FUNCTION_STATE_MUTABILITY = 'view';\n\nexport type FUNCTION_ABI_ENTRY = {\n  type: FUNCTION_ABI_TYPE;\n  name: string;\n  inputs: TYPED_PARAMETER[];\n  outputs: TYPED_PARAMETER[];\n  stateMutability: FUNCTION_STATE_MUTABILITY;\n};\n\nexport type TYPED_PARAMETER = {\n  name: string;\n  type: string;\n};\n\nexport type SIMULATION_FLAG_FOR_ESTIMATE_FEE = 'SKIP_VALIDATE';\nexport type PRICE_UNIT = 'WEI' | 'FRI';\n\nexport type FEE_ESTIMATE = {\n  gas_consumed: FELT;\n  gas_price: FELT;\n  overall_fee: FELT;\n  unit: PRICE_UNIT;\n};\n\nexport type FEE_PAYMENT = {\n  amount: FELT;\n  unit: PRICE_UNIT;\n};\n\nexport type RESOURCE_BOUNDS_MAPPING = {\n  l1_gas: RESOURCE_BOUNDS;\n  l2_gas: RESOURCE_BOUNDS;\n};\n\nexport type RESOURCE_BOUNDS = {\n  max_amount: u64;\n  max_price_per_unit: u128;\n};\n\nexport type RESOURCE_PRICE = {\n  price_in_fri: FELT;\n  price_in_wei: FELT;\n};\n\nexport type EXECUTION_RESOURCES = {\n  steps: number;\n  memory_holes?: number;\n  range_check_builtin_applications?: number;\n  pedersen_builtin_applications?: number;\n  poseidon_builtin_applications?: number;\n  ec_op_builtin_applications?: number;\n  ecdsa_builtin_applications?: number;\n  bitwise_builtin_applications?: number;\n  keccak_builtin_applications?: number;\n  segment_arena_builtin?: number;\n};\n\n/**\n * TRACE API\n */\n\n// Represents a transaction trace including the execution details.\nexport type TRANSACTION_TRACE = {\n  invoke_tx_trace?: INVOKE_TXN_TRACE;\n  declare_tx_trace?: DECLARE_TXN_TRACE;\n  deploy_account_tx_trace?: DEPLOY_ACCOUNT_TXN_TRACE;\n  l1_handler_tx_trace?: L1_HANDLER_TXN_TRACE;\n};\n\n// Represents a transaction trace for an invoke transaction.\nexport type INVOKE_TXN_TRACE = {\n  type: 'INVOKE';\n  execute_invocation: FUNCTION_INVOCATION | { revert_reason: string };\n  validate_invocation?: FUNCTION_INVOCATION;\n  fee_transfer_invocation?: FUNCTION_INVOCATION;\n  state_diff?: STATE_DIFF;\n};\n\n// Represents a transaction trace for a declare transaction.\nexport type DECLARE_TXN_TRACE = {\n  type: 'DECLARE';\n  validate_invocation?: FUNCTION_INVOCATION;\n  fee_transfer_invocation?: FUNCTION_INVOCATION;\n  state_diff?: STATE_DIFF;\n};\n\n// Represents a transaction trace for a deploy account transaction.\nexport type DEPLOY_ACCOUNT_TXN_TRACE = {\n  type: 'DEPLOY_ACCOUNT';\n  constructor_invocation: FUNCTION_INVOCATION;\n  validate_invocation?: FUNCTION_INVOCATION;\n  fee_transfer_invocation?: FUNCTION_INVOCATION;\n  state_diff?: STATE_DIFF;\n};\n\n// Represents a transaction trace for an L1 handler transaction.\nexport type L1_HANDLER_TXN_TRACE = {\n  type: 'L1_HANDLER';\n  function_invocation: FUNCTION_INVOCATION;\n  state_diff?: STATE_DIFF;\n};\n\n// Represents a nested function call.\nexport type NESTED_CALL = FUNCTION_INVOCATION;\n\n// Represents a function invocation along with its execution details.\nexport type FUNCTION_INVOCATION = FUNCTION_CALL & {\n  caller_address: string;\n  class_hash: string;\n  entry_point_type: ENTRY_POINT_TYPE;\n  call_type: CALL_TYPE;\n  result: string[];\n  calls: NESTED_CALL[];\n  events: ORDERED_EVENT[];\n  messages: ORDERED_MESSAGE[];\n  execution_resources: EXECUTION_RESOURCES;\n};\n\n// Represents an ordered event alongside its order within the transaction.\nexport type ORDERED_EVENT = {\n  order: number;\n  event: EVENT;\n};\n\n// Represents an ordered message alongside its order within the transaction.\nexport type ORDERED_MESSAGE = {\n  order: number;\n  message: MSG_TO_L1;\n};\n","/**\n * Types that are not in spec but required for UX\n */\nimport {\n  ADDRESS,\n  BLOCK_HASH,\n  BLOCK_NUMBER,\n  BLOCK_WITH_TXS,\n  BLOCK_WITH_TX_HASHES,\n  BROADCASTED_TXN,\n  CHAIN_ID,\n  CONTRACT_CLASS,\n  CONTRACT_STORAGE_DIFF_ITEM,\n  DEPRECATED_CONTRACT_CLASS,\n  EMITTED_EVENT,\n  EVENT,\n  EVENTS_CHUNK,\n  EVENT_FILTER,\n  FEE_ESTIMATE,\n  FEE_PAYMENT,\n  FELT,\n  MSG_FROM_L1,\n  NONCE_UPDATE,\n  PENDING_BLOCK_WITH_TXS,\n  PENDING_BLOCK_WITH_TX_HASHES,\n  PENDING_STATE_UPDATE,\n  PENDING_TXN_RECEIPT,\n  PRICE_UNIT,\n  REPLACED_CLASS,\n  RESOURCE_BOUNDS_MAPPING,\n  RESULT_PAGE_REQUEST,\n  SIMULATION_FLAG,\n  STATE_UPDATE,\n  SYNC_STATUS,\n  TRANSACTION_TRACE,\n  TXN,\n  TXN_EXECUTION_STATUS,\n  TXN_HASH,\n  TXN_RECEIPT,\n  TXN_STATUS,\n} from './components';\nimport { ValuesType } from '../../helpers/valuesType';\n\n// METHOD RESPONSES\n// response starknet_getClass\nexport type ContractClass = CONTRACT_CLASS | DEPRECATED_CONTRACT_CLASS;\n// response starknet_simulateTransactions\nexport type SimulateTransaction = {\n  transaction_trace: TRANSACTION_TRACE;\n  fee_estimation: FEE_ESTIMATE;\n};\nexport type SimulateTransactionResponse = SimulateTransaction[];\n// response starknet_estimateFee\nexport type FeeEstimate = FEE_ESTIMATE;\n// response starknet_getTransactionByHash, starknet_getTransactionByBlockIdAndIndex\nexport type TransactionWithHash = TXN & { transaction_hash: TXN_HASH };\n// response starknet_blockHashAndNumber\nexport type BlockHashAndNumber = { block_hash: BLOCK_HASH; block_number: BLOCK_NUMBER };\n// response starknet_getBlockWithTxs\nexport type BlockWithTxs = BLOCK_WITH_TXS | PENDING_BLOCK_WITH_TXS;\n// response starknet_getBlockWithTxHashes\nexport type BlockWithTxHashes = BLOCK_WITH_TX_HASHES | PENDING_BLOCK_WITH_TX_HASHES;\n// response starknet_getStateUpdate\nexport type StateUpdate = STATE_UPDATE | PENDING_STATE_UPDATE;\n// response starknet_traceBlockTransactions\nexport type BlockTransactionsTraces = { transaction_hash: FELT; trace_root: TRANSACTION_TRACE }[];\n// response starknet_syncing\nexport type Syncing = false | SYNC_STATUS;\n// response starknet_getEvents\nexport type Events = EVENTS_CHUNK;\nexport type EmittedEvent = EMITTED_EVENT;\nexport type Event = EVENT;\n// response starknet_addInvokeTransaction\nexport type InvokedTransaction = { transaction_hash: TXN_HASH };\n// response starknet_addDeclareTransaction\nexport type DeclaredTransaction = { transaction_hash: TXN_HASH; class_hash: FELT };\n// response starknet_addDeployAccountTransaction\nexport type DeployedAccountTransaction = { transaction_hash: TXN_HASH; contract_address: FELT };\n\n// Nice Components names\nexport type ContractAddress = ADDRESS;\nexport type Felt = FELT;\nexport type Nonce = FELT;\nexport type TransactionHash = TXN_HASH;\nexport type TransactionTrace = TRANSACTION_TRACE;\nexport type BlockHash = BLOCK_HASH;\nexport type TransactionReceipt = TXN_RECEIPT | PENDING_TXN_RECEIPT;\nexport type Receipt = TXN_RECEIPT;\nexport type PendingReceipt = PENDING_TXN_RECEIPT;\nexport type EventFilter = EVENT_FILTER & RESULT_PAGE_REQUEST;\nexport type SimulationFlags = Array<SIMULATION_FLAG>;\nexport type L1Message = MSG_FROM_L1;\nexport type BaseTransaction = BROADCASTED_TXN;\nexport type ChainId = CHAIN_ID;\nexport type Transaction = TXN;\nexport type TransactionStatus = {\n  finality_status: TXN_STATUS;\n  execution_status?: TXN_EXECUTION_STATUS;\n};\nexport type ResourceBounds = RESOURCE_BOUNDS_MAPPING;\nexport type FeePayment = FEE_PAYMENT;\nexport type PriceUnit = PRICE_UNIT;\n\n// Diff Than Seq\nexport type StorageDiffs = Array<CONTRACT_STORAGE_DIFF_ITEM>;\nexport type DeprecatedDeclaredClasses = Array<FELT>;\nexport type NonceUpdates = NONCE_UPDATE[];\nexport type ReplacedClasses = REPLACED_CLASS[];\n\n// Enums Derived From Spec Types (require manual check for changes)\nexport const ETransactionType = {\n  DECLARE: 'DECLARE',\n  DEPLOY: 'DEPLOY',\n  DEPLOY_ACCOUNT: 'DEPLOY_ACCOUNT',\n  INVOKE: 'INVOKE',\n  L1_HANDLER: 'L1_HANDLER',\n} as const;\n\nexport type ETransactionType = ValuesType<typeof ETransactionType>;\n\nexport const ESimulationFlag = {\n  SKIP_VALIDATE: 'SKIP_VALIDATE',\n  SKIP_FEE_CHARGE: 'SKIP_FEE_CHARGE',\n} as const;\n\nexport type ESimulationFlag = ValuesType<typeof ESimulationFlag>;\n\nexport const ETransactionStatus = {\n  RECEIVED: 'RECEIVED',\n  REJECTED: 'REJECTED',\n  ACCEPTED_ON_L2: 'ACCEPTED_ON_L2',\n  ACCEPTED_ON_L1: 'ACCEPTED_ON_L1',\n} as const;\n\nexport type ETransactionStatus = ValuesType<typeof ETransactionStatus>;\n\nexport const ETransactionFinalityStatus = {\n  ACCEPTED_ON_L2: 'ACCEPTED_ON_L2',\n  ACCEPTED_ON_L1: 'ACCEPTED_ON_L1',\n} as const;\n\nexport type ETransactionFinalityStatus = ValuesType<typeof ETransactionFinalityStatus>;\n\nexport const ETransactionExecutionStatus = {\n  SUCCEEDED: 'SUCCEEDED',\n  REVERTED: 'REVERTED',\n} as const;\n\nexport type ETransactionExecutionStatus = ValuesType<typeof ETransactionExecutionStatus>;\n\nexport const EBlockTag = {\n  PENDING: 'pending',\n  LATEST: 'latest',\n} as const;\n\nexport type EBlockTag = ValuesType<typeof EBlockTag>;\n\n// 'L1' | 'L2'\nexport const EDataAvailabilityMode = {\n  L1: 'L1',\n  L2: 'L2',\n} as const;\n\nexport type EDataAvailabilityMode = ValuesType<typeof EDataAvailabilityMode>;\n\n// 0 | 1\nexport const EDAMode = {\n  L1: 0,\n  L2: 1,\n} as const;\n\nexport type EDAMode = ValuesType<typeof EDAMode>;\n\n/**\n * V_ Transaction versions HexString\n * F_ Fee Transaction Versions HexString (2 ** 128 + TRANSACTION_VERSION)\n */\nexport const ETransactionVersion = {\n  V0: '0x0',\n  V1: '0x1',\n  V2: '0x2',\n  V3: '0x3',\n  F0: '0x100000000000000000000000000000000',\n  F1: '0x100000000000000000000000000000001',\n  F2: '0x100000000000000000000000000000002',\n  F3: '0x100000000000000000000000000000003',\n} as const;\n\nexport type ETransactionVersion = ValuesType<typeof ETransactionVersion>;\n\n/**\n * Old Transaction Versions\n */\nexport const ETransactionVersion2 = {\n  V0: '0x0',\n  V1: '0x1',\n  V2: '0x2',\n  F0: '0x100000000000000000000000000000000',\n  F1: '0x100000000000000000000000000000001',\n  F2: '0x100000000000000000000000000000002',\n} as const;\n\nexport type ETransactionVersion2 = ValuesType<typeof ETransactionVersion2>;\n\n/**\n * V3 Transaction Versions\n */\nexport const ETransactionVersion3 = {\n  V3: '0x3',\n  F3: '0x100000000000000000000000000000003',\n} as const;\n\nexport type ETransactionVersion3 = ValuesType<typeof ETransactionVersion3>;\n","import { base64 } from '@scure/base';\n\nexport const IS_BROWSER = typeof window !== 'undefined';\n\nconst STRING_ZERO = '0';\n\n/**\n * Some functions recreated from https://github.com/pedrouid/enc-utils/blob/master/src/index.ts\n * enc-utils is not a dependency to avoid using `Buffer` which only works in node and not browsers\n */\n\n/**\n * Convert array buffer to string\n *\n * *[internal usage]*\n *\n * @param {ArrayBuffer} array The ArrayBuffer to convert to string.\n * @returns {string} The converted string.\n *\n * @example\n * ```typescript\n * const buffer = new ArrayBuffer(5);\n * const view = new Uint8Array(buffer);\n * [72, 101, 108, 108, 111].forEach((x, idx) => view[idx] = x);\n * const result = encode.arrayBufferToString(buffer);\n * // result = \"Hello\"\n * ```\n */\nexport function arrayBufferToString(array: ArrayBuffer): string {\n  return new Uint8Array(array).reduce((data, byte) => data + String.fromCharCode(byte), '');\n}\n\n/**\n * Convert utf8-string to Uint8Array\n *\n * *[internal usage]*\n *\n * @param {string} str The UTF-8 string to convert.\n * @returns {Uint8Array} The encoded Uint8Array.\n *\n * @example\n * ```typescript\n * const myString = 'Hi';\n * const result = encode.utf8ToArray(myString);\n * // result = Uint8Array(2) [ 72, 105 ]\n * ```\n */\nexport function utf8ToArray(str: string): Uint8Array {\n  return new TextEncoder().encode(str);\n}\n\n/**\n * Convert utf8-string to Uint8Array\n *\n * @deprecated equivalent to 'utf8ToArray', alias will be removed\n */\nexport function stringToArrayBuffer(str: string): Uint8Array {\n  return utf8ToArray(str);\n}\n\n/**\n * Convert string to array buffer (browser and node compatible)\n *\n * @param {string} a The Base64 encoded string to convert.\n * @returns {Uint8Array} The decoded Uint8Array.\n *\n * @example\n * ```typescript\n * const base64String = 'SGVsbG8='; // 'Hello' in Base64\n * const result = encode.atobUniversal(base64String);\n * // result = Uint8Array(5) [ 72, 101, 108, 108, 111 ]\n * ```\n */\nexport function atobUniversal(a: string): Uint8Array {\n  return base64.decode(a);\n}\n\n/**\n * Convert array buffer to string (browser and node compatible)\n *\n * @param {ArrayBuffer} b The Array buffer.\n * @returns {string} The Base64 encoded string.\n *\n * @example\n * ```typescript\n * const buffer = new Uint8Array([72, 101, 108, 108, 111]); // Array with ASCII values for 'Hello'\n * const result = encode.btoaUniversal(buffer);\n * // result = \"SGVsbG8=\"\n * ```\n */\nexport function btoaUniversal(b: ArrayBuffer): string {\n  return base64.encode(new Uint8Array(b));\n}\n\n/**\n * Convert array buffer to hex-string\n *\n * @param {Uint8Array} buffer The encoded Uint8Array.\n * @returns {string} The hex-string\n *\n * @example\n * ```typescript\n * const buffer = new Uint8Array([72, 101, 108, 108, 111]); // Array with ASCII values for 'Hello'\n * const result = encode.buf2hex(buffer);\n * // result = \"48656c6c6f\"\n * ```\n */\nexport function buf2hex(buffer: Uint8Array): string {\n  return buffer.reduce((r, x) => r + x.toString(16).padStart(2, '0'), '');\n}\n\n/**\n * Remove hex prefix '0x' from hex-string\n * @param hex hex-string\n * @returns {string} The hex-string\n *\n * @example\n * ```typescript\n * const hexStringWithPrefix = '0x48656c6c6f';\n * const result = encode.removeHexPrefix(hexStringWithPrefix);\n * // result: \"48656c6c6f\"\n * ```\n */\nexport function removeHexPrefix(hex: string): string {\n  return hex.replace(/^0x/i, '');\n}\n\n/**\n * Add hex prefix '0x' to base16-string\n * @param hex base16-string\n * @returns {string} The hex-string\n *\n * @example\n * ```typescript\n * const plainHexString = '48656c6c6f';\n * const result = encode.addHexPrefix(plainHexString);\n * // result: \"0x48656c6c6f\"\n * ```\n */\nexport function addHexPrefix(hex: string): string {\n  return `0x${removeHexPrefix(hex)}`;\n}\n\n/**\n * Prepend or append to string\n *\n * *[internal usage]*\n *\n * Pads a string to a certain length with a specific string.\n * The padding can be applied either to the left or the right of the input string.\n *\n * @param {string} str The string to pad.\n * @param {number} length The target length for the padded string.\n * @param {boolean} left Set to true to add padding to the left, false to add it to the right.\n * @param {string} [padding='0'] The string to use for padding. Defaults to '0'.\n * @returns {string} The padded string.\n *\n * @example\n * ```typescript\n * const myString = 'hello';\n * const result = padString(myString, 10, true);\n * // result = '00000hello'\n * ```\n */\nfunction padString(\n  str: string,\n  length: number,\n  left: boolean,\n  padding: string = STRING_ZERO\n): string {\n  const diff = length - str.length;\n  let result = str;\n  if (diff > 0) {\n    const pad = padding.repeat(diff);\n    result = left ? pad + str : str + pad;\n  }\n  return result;\n}\n\n/**\n * Prepend string (default with '0')\n *\n * Pads a string to a certain length with a specific string.\n * The padding can be applied only to the left of the input string.\n *\n * @param {string} str The string to pad.\n * @param {number} length The target length for the padded string.\n * @param {string} [padding='0'] The string to use for padding. Defaults to '0'.\n * @returns {string} The padded string.\n * @example\n * ```typescript\n * const myString = '1A3F';\n * const result = encode.padLeft(myString, 10);\n * // result: '0000001A3F'\n * ```\n */\nexport function padLeft(str: string, length: number, padding: string = STRING_ZERO): string {\n  return padString(str, length, true, padding);\n}\n\n/**\n * Calculate byte length of string\n *\n * *[no internal usage]*\n *\n * Calculates the byte length of a string based on a specified byte size.\n * The function rounds up the byte count to the nearest multiple of the specified byte size.\n *\n * @param {string} str The string whose byte length is to be calculated.\n * @param {number} [byteSize='8'] The size of the byte block to round up to. Defaults to 8.\n * @returns {number} The calculated byte length, rounded to the nearest multiple of byteSize.\n *\n * @example\n * ```typescript\n * const myString = 'Hello';\n * const result = encode.calcByteLength(myString, 4);\n * // result = 8 (rounded up to the nearest multiple of 4)\n *\n * ```\n */\nexport function calcByteLength(str: string, byteSize: number = 8): number {\n  const { length } = str;\n  const remainder = length % byteSize;\n  return remainder ? ((length - remainder) / byteSize) * byteSize + byteSize : length;\n}\n\n/**\n * Prepend '0' to string bytes\n *\n * *[no internal usage]*\n *\n *\n * * Prepends padding to the left of a string to ensure it matches a specific byte length.\n * The function uses a specified padding character and rounds up the string length to the nearest multiple of `byteSize`.\n *\n * @param {string} str The string to be padded.\n * @param {number} [byteSize='8'] The byte block size to which the string length should be rounded up. Defaults to 8.\n * @param {string} [padding='0'] The character to use for padding. Defaults to '0'.\n * @returns {string} The padded string.\n *\n * @example\n * ```typescript\n * const myString = '123';\n * const result = encode.sanitizeBytes(myString);\n * // result: '00000123' (padded to 8 characters)\n * ```\n */\nexport function sanitizeBytes(\n  str: string,\n  byteSize: number = 8,\n  padding: string = STRING_ZERO\n): string {\n  return padLeft(str, calcByteLength(str, byteSize), padding);\n}\n\n/**\n * Sanitizes a hex-string by removing any existing '0x' prefix, padding the string with '0' to ensure it has even length,\n * and then re-adding the '0x' prefix.\n *\n * *[no internal usage]*\n * @param {string} hex hex-string\n * @returns {string} format: hex-string\n *\n * @example\n * ```typescript\n * const unevenHex = '0x23abc';\n * const result = encode.sanitizeHex(unevenHex);\n * // result = '0x023abc' (padded to ensure even length)\n * ```\n */\nexport function sanitizeHex(hex: string): string {\n  const hexWithoutPrefix = removeHexPrefix(hex);\n  const sanitizedHex = sanitizeBytes(hexWithoutPrefix, 2);\n  return sanitizedHex ? addHexPrefix(sanitizedHex) : sanitizedHex;\n}\n\n/**\n * String transformation util\n *\n * Pascal case to screaming snake case\n *\n * @param {string} text The PascalCase string to convert.\n * @returns {string} The converted snake_case string in uppercase.\n *\n * @example\n * ```typescript\n * const pascalString = 'PascalCaseExample';\n * const result = encode.pascalToSnake(pascalString);\n * // result: 'PASCAL_CASE_EXAMPLE'\n * ```\n */\nexport const pascalToSnake = (text: string): string =>\n  /[a-z]/.test(text)\n    ? text\n        .split(/(?=[A-Z])/)\n        .join('_')\n        .toUpperCase()\n    : text;\n\n/**\n * Combine multiple Uint8Arrays into one.\n * Useful for wallet path creation.\n * @param {Uint8Array[]} uint8arrays An array of Uint8Array.\n * @returns {Uint8Array} all the Uint8Arrays joined.\n * @example\n * ```typescript\n * const path0buff = new Uint8Array([128, 0, 10, 85]);\n * const path1buff = new Uint8Array([71, 65, 233, 201]);\n * const result = encode.concatenateArrayBuffer([path0buff, path1buff]);\n * // result = Uint8Array(8) [128, 0, 10, 85, 71, 65, 233, 201]\n * ```\n */\nexport function concatenateArrayBuffer(uint8arrays: Uint8Array[]): Uint8Array {\n  const totalLength = uint8arrays.reduce((total, uint8array) => total + uint8array.byteLength, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  uint8arrays.forEach((uint8array) => {\n    result.set(uint8array, offset);\n    offset += uint8array.byteLength;\n  });\n  return result;\n}\n","import { NetworkName, StarknetChainId, SYSTEM_MESSAGES } from '../global/constants';\nimport { LibraryError, RpcError } from '../utils/errors';\nimport {\n  AccountInvocationItem,\n  AccountInvocations,\n  BigNumberish,\n  BlockIdentifier,\n  BlockTag,\n  Call,\n  DeclareContractTransaction,\n  DeployAccountContractTransaction,\n  Invocation,\n  InvocationsDetailsWithNonce,\n  RPC_ERROR,\n  RpcProviderOptions,\n  TransactionType,\n  getEstimateFeeBulkOptions,\n  getSimulateTransactionOptions,\n  waitForTransactionOptions,\n} from '../types';\nimport { JRPC, RPCSPEC06 as RPC } from '../types/api';\nimport { BatchClient } from '../utils/batch';\nimport { CallData } from '../utils/calldata';\nimport { isSierra } from '../utils/contract';\nimport { validateAndParseEthAddress } from '../utils/eth';\nimport fetch from '../utils/fetchPonyfill';\nimport { getSelector, getSelectorFromName } from '../utils/hash';\nimport { stringify } from '../utils/json';\nimport { getHexStringArray, toHex, toStorageKey } from '../utils/num';\nimport { Block, getDefaultNodeUrl, isV3Tx, isVersion, wait } from '../utils/provider';\nimport { decompressProgram, signatureToHexArray } from '../utils/stark';\nimport { getVersionsByType } from '../utils/transaction';\nimport { logger } from '../global/logger';\n\nconst defaultOptions = {\n  headers: { 'Content-Type': 'application/json' },\n  blockIdentifier: BlockTag.PENDING,\n  retries: 200,\n};\n\nexport class RpcChannel {\n  public nodeUrl: string;\n\n  public headers: object;\n\n  public requestId: number;\n\n  readonly blockIdentifier: BlockIdentifier;\n\n  readonly retries: number;\n\n  readonly waitMode: boolean; // behave like web2 rpc and return when tx is processed\n\n  private chainId?: StarknetChainId;\n\n  private specVersion?: string;\n\n  private transactionRetryIntervalFallback?: number;\n\n  private batchClient?: BatchClient;\n\n  private baseFetch: NonNullable<RpcProviderOptions['baseFetch']>;\n\n  constructor(optionsOrProvider?: RpcProviderOptions) {\n    const {\n      baseFetch,\n      batch,\n      blockIdentifier,\n      chainId,\n      headers,\n      nodeUrl,\n      retries,\n      specVersion,\n      transactionRetryIntervalFallback,\n      waitMode,\n    } = optionsOrProvider || {};\n    if (Object.values(NetworkName).includes(nodeUrl as NetworkName)) {\n      this.nodeUrl = getDefaultNodeUrl(nodeUrl as NetworkName, optionsOrProvider?.default);\n    } else if (nodeUrl) {\n      this.nodeUrl = nodeUrl;\n    } else {\n      this.nodeUrl = getDefaultNodeUrl(undefined, optionsOrProvider?.default);\n    }\n    this.baseFetch = baseFetch ?? fetch;\n    this.blockIdentifier = blockIdentifier ?? defaultOptions.blockIdentifier;\n    this.chainId = chainId;\n    this.headers = { ...defaultOptions.headers, ...headers };\n    this.retries = retries ?? defaultOptions.retries;\n    this.specVersion = specVersion;\n    this.transactionRetryIntervalFallback = transactionRetryIntervalFallback;\n    this.waitMode = waitMode ?? false;\n\n    this.requestId = 0;\n\n    if (typeof batch === 'number') {\n      this.batchClient = new BatchClient({\n        nodeUrl: this.nodeUrl,\n        headers: this.headers,\n        interval: batch,\n        baseFetch: this.baseFetch,\n      });\n    }\n  }\n\n  private get transactionRetryIntervalDefault() {\n    return this.transactionRetryIntervalFallback ?? 5000;\n  }\n\n  public setChainId(chainId: StarknetChainId) {\n    this.chainId = chainId;\n  }\n\n  public fetch(method: string, params?: object, id: string | number = 0) {\n    const rpcRequestBody: JRPC.RequestBody = {\n      id,\n      jsonrpc: '2.0',\n      method,\n      ...(params && { params }),\n    };\n    return this.baseFetch(this.nodeUrl, {\n      method: 'POST',\n      body: stringify(rpcRequestBody),\n      headers: this.headers as Record<string, string>,\n    });\n  }\n\n  protected errorHandler(method: string, params: any, rpcError?: JRPC.Error, otherError?: any) {\n    if (rpcError) {\n      throw new RpcError(rpcError as RPC_ERROR, method, params);\n    }\n    if (otherError instanceof LibraryError) {\n      throw otherError;\n    }\n    if (otherError) {\n      throw Error(otherError.message);\n    }\n  }\n\n  protected async fetchEndpoint<T extends keyof RPC.Methods>(\n    method: T,\n    params?: RPC.Methods[T]['params']\n  ): Promise<RPC.Methods[T]['result']> {\n    try {\n      if (this.batchClient) {\n        const { error, result } = await this.batchClient.fetch(\n          method,\n          params,\n          (this.requestId += 1)\n        );\n        this.errorHandler(method, params, error);\n        return result as RPC.Methods[T]['result'];\n      }\n\n      const rawResult = await this.fetch(method, params, (this.requestId += 1));\n      const { error, result } = await rawResult.json();\n      this.errorHandler(method, params, error);\n      return result as RPC.Methods[T]['result'];\n    } catch (error: any) {\n      this.errorHandler(method, params, error?.response?.data, error);\n      throw error;\n    }\n  }\n\n  public async getChainId() {\n    this.chainId ??= (await this.fetchEndpoint('starknet_chainId')) as StarknetChainId;\n    return this.chainId;\n  }\n\n  public async getSpecVersion() {\n    this.specVersion ??= (await this.fetchEndpoint('starknet_specVersion')) as StarknetChainId;\n    return this.specVersion;\n  }\n\n  public getNonceForAddress(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getNonce', {\n      contract_address,\n      block_id,\n    });\n  }\n\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  public getBlockLatestAccepted() {\n    return this.fetchEndpoint('starknet_blockHashAndNumber');\n  }\n\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  public getBlockNumber() {\n    return this.fetchEndpoint('starknet_blockNumber');\n  }\n\n  public getBlockWithTxHashes(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithTxHashes', { block_id });\n  }\n\n  public getBlockWithTxs(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithTxs', { block_id });\n  }\n\n  public getBlockStateUpdate(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getStateUpdate', { block_id });\n  }\n\n  public getBlockTransactionsTraces(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_traceBlockTransactions', { block_id });\n  }\n\n  public getBlockTransactionCount(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockTransactionCount', { block_id });\n  }\n\n  public getTransactionByHash(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_getTransactionByHash', {\n      transaction_hash,\n    });\n  }\n\n  public getTransactionByBlockIdAndIndex(blockIdentifier: BlockIdentifier, index: number) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getTransactionByBlockIdAndIndex', { block_id, index });\n  }\n\n  public getTransactionReceipt(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_getTransactionReceipt', { transaction_hash });\n  }\n\n  public getTransactionTrace(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_traceTransaction', { transaction_hash });\n  }\n\n  /**\n   * Get the status of a transaction\n   */\n  public getTransactionStatus(transactionHash: BigNumberish) {\n    const transaction_hash = toHex(transactionHash);\n    return this.fetchEndpoint('starknet_getTransactionStatus', { transaction_hash });\n  }\n\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  public simulateTransaction(\n    invocations: AccountInvocations,\n    simulateTransactionOptions: getSimulateTransactionOptions = {}\n  ) {\n    const {\n      blockIdentifier = this.blockIdentifier,\n      skipValidate = true,\n      skipFeeCharge = true,\n    } = simulateTransactionOptions;\n    const block_id = new Block(blockIdentifier).identifier;\n    const simulationFlags: RPC.ESimulationFlag[] = [];\n    if (skipValidate) simulationFlags.push(RPC.ESimulationFlag.SKIP_VALIDATE);\n    if (skipFeeCharge) simulationFlags.push(RPC.ESimulationFlag.SKIP_FEE_CHARGE);\n\n    return this.fetchEndpoint('starknet_simulateTransactions', {\n      block_id,\n      transactions: invocations.map((it) => this.buildTransaction(it)),\n      simulation_flags: simulationFlags,\n    });\n  }\n\n  public async waitForTransaction(txHash: BigNumberish, options?: waitForTransactionOptions) {\n    const transactionHash = toHex(txHash);\n    let { retries } = this;\n    let onchain = false;\n    let isErrorState = false;\n    const retryInterval = options?.retryInterval ?? this.transactionRetryIntervalDefault;\n    const errorStates: any = options?.errorStates ?? [\n      RPC.ETransactionStatus.REJECTED,\n      // TODO: commented out to preserve the long-standing behavior of \"reverted\" not being treated as an error by default\n      // should decide which behavior to keep in the future\n      // RPC.ETransactionExecutionStatus.REVERTED,\n    ];\n    const successStates: any = options?.successStates ?? [\n      RPC.ETransactionExecutionStatus.SUCCEEDED,\n      RPC.ETransactionStatus.ACCEPTED_ON_L2,\n      RPC.ETransactionStatus.ACCEPTED_ON_L1,\n    ];\n\n    let txStatus: RPC.TransactionStatus;\n    while (!onchain) {\n      // eslint-disable-next-line no-await-in-loop\n      await wait(retryInterval);\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        txStatus = await this.getTransactionStatus(transactionHash);\n\n        const executionStatus = txStatus.execution_status;\n        const finalityStatus = txStatus.finality_status;\n\n        if (!finalityStatus) {\n          // Transaction is potentially NOT_RECEIVED or RPC not Synced yet\n          // so we will retry '{ retries }' times\n          const error = new Error('waiting for transaction status');\n          throw error;\n        }\n\n        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n          const message = `${executionStatus}: ${finalityStatus}`;\n          const error = new Error(message) as Error & { response: RPC.TransactionStatus };\n          error.response = txStatus;\n          isErrorState = true;\n          throw error;\n        } else if (\n          successStates.includes(executionStatus) ||\n          successStates.includes(finalityStatus)\n        ) {\n          onchain = true;\n        }\n      } catch (error) {\n        if (error instanceof Error && isErrorState) {\n          throw error;\n        }\n\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n\n      retries -= 1;\n    }\n\n    /**\n     * For some nodes even though the transaction has executionStatus SUCCEEDED finalityStatus ACCEPTED_ON_L2, getTransactionReceipt returns \"Transaction hash not found\"\n     * Retry until rpc is actually ready to work with txHash\n     */\n    let txReceipt = null;\n    while (txReceipt === null) {\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        txReceipt = await this.getTransactionReceipt(transactionHash);\n      } catch (error) {\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n      // eslint-disable-next-line no-await-in-loop\n      await wait(retryInterval);\n    }\n    return txReceipt as RPC.SPEC.TXN_RECEIPT;\n  }\n\n  public getStorageAt(\n    contractAddress: BigNumberish,\n    key: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const parsedKey = toStorageKey(key);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getStorageAt', {\n      contract_address,\n      key: parsedKey,\n      block_id,\n    });\n  }\n\n  public getClassHashAt(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClassHashAt', {\n      block_id,\n      contract_address,\n    });\n  }\n\n  public getClass(\n    classHash: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const class_hash = toHex(classHash);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClass', {\n      class_hash,\n      block_id,\n    });\n  }\n\n  public getClassAt(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClassAt', {\n      block_id,\n      contract_address,\n    });\n  }\n\n  public async getEstimateFee(\n    invocations: AccountInvocations,\n    { blockIdentifier = this.blockIdentifier, skipValidate = true }: getEstimateFeeBulkOptions\n  ) {\n    const block_id = new Block(blockIdentifier).identifier;\n    let flags = {};\n    if (!isVersion('0.5', await this.getSpecVersion())) {\n      flags = {\n        simulation_flags: skipValidate ? [RPC.ESimulationFlag.SKIP_VALIDATE] : [],\n      };\n    } // else v(0.5) no flags\n\n    return this.fetchEndpoint('starknet_estimateFee', {\n      request: invocations.map((it) => this.buildTransaction(it, 'fee')),\n      block_id,\n      ...flags,\n    });\n  }\n\n  public async invoke(functionInvocation: Invocation, details: InvocationsDetailsWithNonce) {\n    let promise;\n    if (!isV3Tx(details)) {\n      // V1\n      promise = this.fetchEndpoint('starknet_addInvokeTransaction', {\n        invoke_transaction: {\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          type: RPC.ETransactionType.INVOKE,\n          max_fee: toHex(details.maxFee || 0),\n          version: RPC.ETransactionVersion.V1,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n        },\n      });\n\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: RPC.ETransactionVersion.V1,\n        type: RPC.ETransactionType.INVOKE,\n      });\n    } else {\n      // V3\n      promise = this.fetchEndpoint('starknet_addInvokeTransaction', {\n        invoke_transaction: {\n          type: RPC.ETransactionType.INVOKE,\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          version: RPC.ETransactionVersion.V3,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode,\n        },\n      });\n    }\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public async declare(\n    { contract, signature, senderAddress, compiledClassHash }: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    let promise;\n    if (!isSierra(contract) && !isV3Tx(details)) {\n      // V1 Cairo 0\n      promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n        declare_transaction: {\n          type: RPC.ETransactionType.DECLARE,\n          contract_class: {\n            program: contract.program,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi,\n          },\n          version: RPC.ETransactionVersion.V1,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce),\n        },\n      });\n\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: RPC.ETransactionVersion.V1,\n        type: RPC.ETransactionType.DECLARE,\n      });\n    } else if (isSierra(contract) && !isV3Tx(details)) {\n      // V2 Cairo1\n      promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n        declare_transaction: {\n          type: RPC.ETransactionType.DECLARE,\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi,\n          },\n          compiled_class_hash: compiledClassHash || '',\n          version: RPC.ETransactionVersion.V2,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce),\n        },\n      });\n\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: RPC.ETransactionVersion.V2,\n        type: RPC.ETransactionType.DECLARE,\n      });\n    } else if (isSierra(contract) && isV3Tx(details)) {\n      // V3 Cairo1\n      promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n        declare_transaction: {\n          type: RPC.ETransactionType.DECLARE,\n          sender_address: senderAddress,\n          compiled_class_hash: compiledClassHash || '',\n          version: RPC.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi,\n          },\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode,\n        },\n      });\n    } else {\n      throw Error('declare unspotted parameters');\n    }\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public async deployAccount(\n    { classHash, constructorCalldata, addressSalt, signature }: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    let promise;\n    if (!isV3Tx(details)) {\n      // v1\n      promise = this.fetchEndpoint('starknet_addDeployAccountTransaction', {\n        deploy_account_transaction: {\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          contract_address_salt: toHex(addressSalt || 0),\n          type: RPC.ETransactionType.DEPLOY_ACCOUNT,\n          max_fee: toHex(details.maxFee || 0),\n          version: RPC.ETransactionVersion.V1,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n        },\n      });\n\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: RPC.ETransactionVersion.V1,\n        type: RPC.ETransactionType.DEPLOY_ACCOUNT,\n      });\n    } else {\n      // v3\n      promise = this.fetchEndpoint('starknet_addDeployAccountTransaction', {\n        deploy_account_transaction: {\n          type: RPC.ETransactionType.DEPLOY_ACCOUNT,\n          version: RPC.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_address_salt: toHex(addressSalt || 0),\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode,\n        },\n      });\n    }\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public callContract(call: Call, blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_call', {\n      request: {\n        contract_address: call.contractAddress,\n        entry_point_selector: getSelectorFromName(call.entrypoint),\n        calldata: CallData.toHex(call.calldata),\n      },\n      block_id,\n    });\n  }\n\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  public estimateMessageFee(\n    message: RPC.L1Message,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const { from_address, to_address, entry_point_selector, payload } = message;\n    const formattedMessage = {\n      from_address: validateAndParseEthAddress(from_address),\n      to_address: toHex(to_address),\n      entry_point_selector: getSelector(entry_point_selector),\n      payload: getHexStringArray(payload),\n    };\n\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_estimateMessageFee', {\n      message: formattedMessage,\n      block_id,\n    });\n  }\n\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  public getSyncingStats() {\n    return this.fetchEndpoint('starknet_syncing');\n  }\n\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  public getEvents(eventFilter: RPC.EventFilter) {\n    return this.fetchEndpoint('starknet_getEvents', { filter: eventFilter });\n  }\n\n  public buildTransaction(\n    invocation: AccountInvocationItem,\n    versionType?: 'fee' | 'transaction'\n  ): RPC.BaseTransaction {\n    const defaultVersions = getVersionsByType(versionType);\n    let details;\n\n    if (!isV3Tx(invocation)) {\n      // V0,V1,V2\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        max_fee: toHex(invocation.maxFee || 0),\n      };\n\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: invocation.version,\n        type: invocation.type,\n      });\n    } else {\n      // V3\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        resource_bounds: invocation.resourceBounds,\n        tip: toHex(invocation.tip),\n        paymaster_data: invocation.paymasterData.map((it) => toHex(it)),\n        nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n        fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n        account_deployment_data: invocation.accountDeploymentData.map((it) => toHex(it)),\n      };\n    }\n\n    if (invocation.type === TransactionType.INVOKE) {\n      return {\n        // v0 v1 v3\n        type: RPC.ETransactionType.INVOKE,\n        sender_address: invocation.contractAddress,\n        calldata: CallData.toHex(invocation.calldata),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details,\n      } as RPC.SPEC.BROADCASTED_INVOKE_TXN;\n    }\n    if (invocation.type === TransactionType.DECLARE) {\n      if (!isSierra(invocation.contract)) {\n        // Cairo 0 - v1\n        return {\n          type: invocation.type,\n          contract_class: invocation.contract,\n          sender_address: invocation.senderAddress,\n          version: toHex(invocation.version || defaultVersions.v1),\n          ...details,\n        } as RPC.SPEC.BROADCASTED_DECLARE_TXN_V1;\n      }\n      return {\n        // Cairo 1 - v2 v3\n        type: invocation.type,\n        contract_class: {\n          ...invocation.contract,\n          sierra_program: decompressProgram(invocation.contract.sierra_program),\n        },\n        compiled_class_hash: invocation.compiledClassHash || '',\n        sender_address: invocation.senderAddress,\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details,\n      } as RPC.SPEC.BROADCASTED_DECLARE_TXN;\n    }\n    if (invocation.type === TransactionType.DEPLOY_ACCOUNT) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { account_deployment_data, ...restDetails } = details;\n      // v1 v3\n      return {\n        type: invocation.type,\n        constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n        class_hash: toHex(invocation.classHash),\n        contract_address_salt: toHex(invocation.addressSalt || 0),\n        version: toHex(invocation.version || defaultVersions.v3) as RPC.SPEC.INVOKE_TXN['version'],\n        ...restDetails,\n      } as RPC.SPEC.BROADCASTED_DEPLOY_ACCOUNT_TXN;\n    }\n    throw Error('RPC buildTransaction received unknown TransactionType');\n  }\n}\n","import * as json from 'lossless-json';\n\n/**\n * Helper to convert string to number or bigint based on size\n */\nconst parseIntAsNumberOrBigInt = (str: string) => {\n  if (!json.isInteger(str)) return parseFloat(str);\n  const num = parseInt(str, 10);\n  return Number.isSafeInteger(num) ? num : BigInt(str);\n};\n\n/**\n * Convert JSON string to JSON object\n *\n * NOTE: the String() wrapping is used so the behavior conforms to JSON.parse()\n * which can accept simple data types but is not represented in the default typing\n *\n * @param str JSON string\n * @return {object} Parsed json object\n * @example\n * ```typescript\n * const str = '[123, 12.3, 11223344556677889900]';\n * const result = parse(str);\n * // result = [123, 12.3, 11223344556677890048n]\n * ```\n */\nexport const parse = (str: string): any =>\n  json.parse(String(str), undefined, parseIntAsNumberOrBigInt);\n\n/**\n * Convert JSON string to JSON object with all numbers as bigint\n * @param str JSON string\n * @return {object} Parsed json object\n * @example\n * ```typescript\n * const str = '[123, 12.3, 1234567890]';\n * const result = parseAlwaysAsBig(str);\n * // result = [123n, 12.3, 1234567890n]\n * ```\n */\nexport const parseAlwaysAsBig = (str: string): any =>\n  json.parse(String(str), undefined, json.parseNumberAndBigInt);\n\n/**\n * Convert JSON object to JSON string\n *\n * NOTE: the not-null assertion is used so the return type conforms to JSON.stringify()\n * which can also return undefined but is not represented in the default typing\n *\n * @param value JSON object\n * @param [replacer] Function that alters the behavior of the stringification process\n * @param [space] Used to insert white space into the output JSON string\n * @param [numberStringifiers] Function used to stringify numbers (returning undefined will delete the property from the object)\n * @return {string} JSON string\n * @example\n * ```typescript\n * const value = [123, 12.3, 1234567890];\n * const result = stringify(value);\n * // result = '[123,12.3,1234567890]'\n * ```\n */\nexport const stringify = (\n  value: unknown,\n  replacer?: any,\n  space?: string | number | undefined,\n  numberStringifiers?: json.NumberStringifier[] | undefined\n): string => json.stringify(value, replacer, space, numberStringifiers)!;\n\n/** @deprecated equivalent to 'stringify', alias will be removed */\nexport const stringifyAlwaysAsBig = stringify;\n","import { RPC_ERROR_SET } from '../../types';\n\n// NOTE: generated with scripts/generateRpcErrorMap.js\nconst errorCodes: { [K in keyof RPC_ERROR_SET]: RPC_ERROR_SET[K]['code'] } = {\n  FAILED_TO_RECEIVE_TXN: 1,\n  NO_TRACE_AVAILABLE: 10,\n  CONTRACT_NOT_FOUND: 20,\n  BLOCK_NOT_FOUND: 24,\n  INVALID_TXN_INDEX: 27,\n  CLASS_HASH_NOT_FOUND: 28,\n  TXN_HASH_NOT_FOUND: 29,\n  PAGE_SIZE_TOO_BIG: 31,\n  NO_BLOCKS: 32,\n  INVALID_CONTINUATION_TOKEN: 33,\n  TOO_MANY_KEYS_IN_FILTER: 34,\n  CONTRACT_ERROR: 40,\n  TRANSACTION_EXECUTION_ERROR: 41,\n  CLASS_ALREADY_DECLARED: 51,\n  INVALID_TRANSACTION_NONCE: 52,\n  INSUFFICIENT_MAX_FEE: 53,\n  INSUFFICIENT_ACCOUNT_BALANCE: 54,\n  VALIDATION_FAILURE: 55,\n  COMPILATION_FAILED: 56,\n  CONTRACT_CLASS_SIZE_IS_TOO_LARGE: 57,\n  NON_ACCOUNT: 58,\n  DUPLICATE_TX: 59,\n  COMPILED_CLASS_HASH_MISMATCH: 60,\n  UNSUPPORTED_TX_VERSION: 61,\n  UNSUPPORTED_CONTRACT_CLASS_VERSION: 62,\n  UNEXPECTED_ERROR: 63,\n};\nexport default errorCodes;\n","/* eslint-disable max-classes-per-file */\nimport { RPC, RPC_ERROR, RPC_ERROR_SET } from '../../types';\nimport { stringify } from '../json';\nimport rpcErrors from './rpc';\n\n// eslint-disable-next-line max-classes-per-file\nexport function fixStack(target: Error, fn: Function = target.constructor) {\n  const { captureStackTrace } = Error as any;\n  // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n  captureStackTrace && captureStackTrace(target, fn);\n}\n\nexport function fixProto(target: Error, prototype: {}) {\n  const { setPrototypeOf } = Object as any;\n  // eslint-disable-next-line @typescript-eslint/no-unused-expressions, no-proto, no-param-reassign\n  setPrototypeOf ? setPrototypeOf(target, prototype) : ((target as any).__proto__ = prototype);\n}\n\n/* eslint-disable max-classes-per-file */\nexport class CustomError extends Error {\n  name!: string;\n\n  constructor(message?: string) {\n    super(message);\n    // set error name as constructor name, make it not enumerable to keep native Error behavior\n    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target#new.target_in_constructors\n    // see https://github.com/adriengibrat/ts-custom-error/issues/30\n    Object.defineProperty(this, 'name', {\n      value: new.target.name,\n      enumerable: false,\n      configurable: true,\n    });\n    // fix the extended error prototype chain\n    // because typescript __extends implementation can't\n    // see https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    fixProto(this, new.target.prototype);\n    // try to remove constructor from stack trace\n    fixStack(this);\n  }\n}\n\nexport class LibraryError extends CustomError {}\n\nexport class RpcError<BaseErrorT extends RPC_ERROR = RPC_ERROR> extends LibraryError {\n  public readonly request: {\n    method: string;\n    params: any;\n  };\n\n  constructor(\n    public readonly baseError: BaseErrorT,\n    method: string,\n    params: any\n  ) {\n    // legacy message format\n    super(`RPC: ${method} with params ${stringify(params, null, 2)}\\n\n      ${baseError.code}: ${baseError.message}: ${stringify((baseError as RPC.JRPC.Error).data)}`);\n\n    this.request = { method, params };\n  }\n\n  public get code() {\n    return this.baseError.code;\n  }\n\n  /**\n   * Verifies the underlying RPC error, also serves as a type guard for the _baseError_ property\n   * @example\n   * ```typescript\n   * SomeError.isType('UNEXPECTED_ERROR');\n   * ```\n   */\n  public isType<N extends keyof RPC_ERROR_SET, C extends RPC_ERROR_SET[N]['code']>(\n    typeName: N\n  ): this is RpcError<RPC_ERROR_SET[N] & { code: C }> {\n    return rpcErrors[typeName] === this.code;\n  }\n}\n","export * from './lib';\nexport * from './provider';\n\nexport * from './account';\nexport * from './cairoEnum';\nexport * from './calldata';\nexport * from './contract';\nexport * from './errors';\nexport * from './outsideExecution';\nexport * from './signer';\nexport * from './transactionReceipt';\nexport * from './typedData';\n\nexport * as RPC from './api';\n","import { ValuesType } from '../../helpers/valuesType';\nimport { LegacyCompiledContract, LegacyContractClass } from './legacy';\nimport { CompiledSierra, SierraContractClass } from './sierra';\n\n// Final types\n/**\n * format produced after compressing compiled contract\n *\n * CompressedCompiledContract\n */\nexport type ContractClass = LegacyContractClass | SierraContractClass;\n\n/**\n * format produced after compile .cairo to .json\n */\nexport type CompiledContract = LegacyCompiledContract | CompiledSierra;\n\n/**\n * Compressed or decompressed Cairo0 or Cairo1 Contract\n */\nexport type CairoContract = ContractClass | CompiledContract;\n\n// Basic elements\nexport const EntryPointType = {\n  EXTERNAL: 'EXTERNAL',\n  L1_HANDLER: 'L1_HANDLER',\n  CONSTRUCTOR: 'CONSTRUCTOR',\n} as const;\n\nexport type EntryPointType = ValuesType<typeof EntryPointType>;\n\nexport * from './abi';\nexport * from './legacy';\nexport * from './sierra';\n","import { StarknetChainId } from '../../global/constants';\nimport { weierstrass } from '../../utils/ec';\nimport { EDataAvailabilityMode, ResourceBounds } from '../api';\nimport { CairoEnum } from '../cairoEnum';\nimport { CompiledContract, CompiledSierraCasm, ContractClass } from './contract';\nimport { ValuesType } from '../helpers/valuesType';\n\nexport type WeierstrassSignatureType = weierstrass.SignatureType;\nexport type ArraySignatureType = string[];\nexport type Signature = ArraySignatureType | WeierstrassSignatureType;\n\nexport type BigNumberish = string | number | bigint;\n\nexport type ByteArray = {\n  data: BigNumberish[];\n  pending_word: BigNumberish;\n  pending_word_len: BigNumberish;\n};\n\n/**\n * Compiled calldata ready to be sent\n *\n * decimal-string array\n */\nexport type Calldata = string[] & { readonly __compiled__?: true };\n\n/**\n * Represents an integer in the range [0, 2^256)\n */\nexport interface Uint256 {\n  // The low 128 bits of the value\n  low: BigNumberish;\n  // The high 128 bits of the value\n  high: BigNumberish;\n}\n\n/**\n * Represents an integer in the range [0, 2^256)\n */\nexport interface Uint512 {\n  // The lowest 128 bits of the value\n  limb0: BigNumberish;\n  limb1: BigNumberish;\n  limb2: BigNumberish;\n  // The higher 128 bits of the value\n  limb3: BigNumberish;\n}\n\n/**\n * BigNumberish array\n *\n * use CallData.compile() to convert to Calldata\n */\nexport type RawCalldata = BigNumberish[];\n\n/**\n * Hexadecimal-string array\n */\nexport type HexCalldata = string[];\n\nexport type AllowArray<T> = T | T[];\n\nexport type OptionalPayload<T> = { payload: T } | T;\n\nexport type RawArgs = RawArgsObject | RawArgsArray;\n\nexport type RawArgsObject = {\n  [inputName: string]: MultiType | MultiType[] | RawArgs;\n};\n\nexport type RawArgsArray = Array<MultiType | MultiType[] | RawArgs>;\n\nexport type MultiType = BigNumberish | Uint256 | object | boolean | CairoEnum;\n\nexport type UniversalDeployerContractPayload = {\n  classHash: BigNumberish;\n  salt?: string;\n  unique?: boolean;\n  constructorCalldata?: RawArgs;\n};\n\nexport type DeployAccountContractPayload = {\n  classHash: string;\n  constructorCalldata?: RawArgs;\n  addressSalt?: BigNumberish;\n  contractAddress?: string;\n};\n\nexport type DeployAccountContractTransaction = Omit<\n  DeployAccountContractPayload,\n  'contractAddress'\n> & {\n  signature?: Signature;\n};\n\nexport type DeclareContractPayload = {\n  contract: CompiledContract | string;\n  classHash?: string;\n  casm?: CompiledSierraCasm;\n  compiledClassHash?: string;\n};\n\n/**\n * DeclareContractPayload with classHash or contract defined\n */\nexport type ContractClassIdentifier = DeclareContractPayload | { classHash: string };\n\nexport type CompleteDeclareContractPayload = {\n  contract: CompiledContract | string;\n  classHash: string;\n  casm?: CompiledSierraCasm;\n  compiledClassHash?: string;\n};\n\nexport type DeclareAndDeployContractPayload = Omit<UniversalDeployerContractPayload, 'classHash'> &\n  DeclareContractPayload;\n\nexport type DeclareContractTransaction = {\n  contract: ContractClass;\n  senderAddress: string;\n  signature?: Signature;\n  compiledClassHash?: string;\n};\n\nexport type CallDetails = {\n  contractAddress: string;\n  calldata?: RawArgs | Calldata;\n  entrypoint?: string;\n};\n\nexport type Invocation = CallDetails & { signature?: Signature };\n\nexport type Call = CallDetails & { entrypoint: string };\n\nexport type CairoVersion = '0' | '1' | undefined;\nexport type CompilerVersion = '0' | '1' | '2' | undefined;\n\nexport type InvocationsDetails = {\n  nonce?: BigNumberish;\n  maxFee?: BigNumberish;\n  version?: BigNumberish;\n} & Partial<V3TransactionDetails>;\n\nexport type V3TransactionDetails = {\n  nonce: BigNumberish;\n  version: BigNumberish;\n  resourceBounds: ResourceBounds;\n  tip: BigNumberish;\n  paymasterData: BigNumberish[];\n  accountDeploymentData: BigNumberish[];\n  nonceDataAvailabilityMode: EDataAvailabilityMode;\n  feeDataAvailabilityMode: EDataAvailabilityMode;\n};\n\n/**\n * Contain all additional details params\n */\nexport type Details = {\n  nonce: BigNumberish;\n  maxFee: BigNumberish;\n  version: BigNumberish;\n  chainId: StarknetChainId;\n};\n\nexport type InvocationsDetailsWithNonce =\n  | (InvocationsDetails & { nonce: BigNumberish })\n  | V3TransactionDetails;\n\nexport const TransactionType = {\n  DECLARE: 'DECLARE',\n  DEPLOY: 'DEPLOY',\n  DEPLOY_ACCOUNT: 'DEPLOY_ACCOUNT',\n  INVOKE: 'INVOKE_FUNCTION',\n} as const;\n\nexport type TransactionType = ValuesType<typeof TransactionType>;\n\n/**\n * new statuses are defined by props: finality_status and execution_status\n * to be #deprecated\n */\nexport const TransactionStatus = {\n  NOT_RECEIVED: 'NOT_RECEIVED',\n  RECEIVED: 'RECEIVED',\n  ACCEPTED_ON_L2: 'ACCEPTED_ON_L2',\n  ACCEPTED_ON_L1: 'ACCEPTED_ON_L1',\n  REJECTED: 'REJECTED',\n  REVERTED: 'REVERTED',\n} as const;\n\nexport type TransactionStatus = ValuesType<typeof TransactionStatus>;\n\nexport const TransactionFinalityStatus = {\n  NOT_RECEIVED: 'NOT_RECEIVED',\n  RECEIVED: 'RECEIVED',\n  ACCEPTED_ON_L2: 'ACCEPTED_ON_L2',\n  ACCEPTED_ON_L1: 'ACCEPTED_ON_L1',\n} as const;\n\nexport type TransactionFinalityStatus = ValuesType<typeof TransactionFinalityStatus>;\n\nexport const TransactionExecutionStatus = {\n  REJECTED: 'REJECTED',\n  REVERTED: 'REVERTED',\n  SUCCEEDED: 'SUCCEEDED',\n} as const;\n\nexport type TransactionExecutionStatus = ValuesType<typeof TransactionExecutionStatus>;\n\nexport const BlockStatus = {\n  PENDING: 'PENDING',\n  ACCEPTED_ON_L1: 'ACCEPTED_ON_L1',\n  ACCEPTED_ON_L2: 'ACCEPTED_ON_L2',\n  REJECTED: 'REJECTED',\n} as const;\n\nexport type BlockStatus = ValuesType<typeof BlockStatus>;\n\nexport const BlockTag = {\n  PENDING: 'pending',\n  LATEST: 'latest',\n} as const;\n\nexport type BlockTag = ValuesType<typeof BlockTag>;\n\nexport type BlockNumber = BlockTag | null | number;\n\n/**\n * hex string and BigInt are detected as block hashes\n *\n * decimal string and number are detected as block numbers\n *\n * text string are detected as block tag\n *\n * null return 'pending' block tag\n */\nexport type BlockIdentifier = BlockNumber | BigNumberish;\n\n/**\n * items used by AccountInvocations\n */\nexport type AccountInvocationItem = (\n  | ({ type: typeof TransactionType.DECLARE } & DeclareContractTransaction)\n  | ({ type: typeof TransactionType.DEPLOY_ACCOUNT } & DeployAccountContractTransaction)\n  | ({ type: typeof TransactionType.INVOKE } & Invocation)\n) &\n  InvocationsDetailsWithNonce;\n\n/**\n * Complete invocations array with account details (internal type from account -> provider)\n */\nexport type AccountInvocations = AccountInvocationItem[];\n\n/**\n * Invocations array user provide to bulk method (simulate)\n */\nexport type Invocations = Array<\n  | ({ type: typeof TransactionType.DECLARE } & OptionalPayload<DeclareContractPayload>)\n  | ({ type: typeof TransactionType.DEPLOY } & OptionalPayload<\n      AllowArray<UniversalDeployerContractPayload>\n    >)\n  | ({\n      type: typeof TransactionType.DEPLOY_ACCOUNT;\n    } & OptionalPayload<DeployAccountContractPayload>)\n  | ({ type: typeof TransactionType.INVOKE } & OptionalPayload<AllowArray<Call>>)\n>;\n\nexport type Tupled = { element: any; type: string };\n\nexport type Args = {\n  [inputName: string]: BigNumberish | BigNumberish[] | ParsedStruct | ParsedStruct[];\n};\nexport type ParsedStruct = {\n  [key: string]: BigNumberish | BigNumberish[] | ParsedStruct | Uint256;\n};\n\nexport type waitForTransactionOptions = {\n  retryInterval?: number;\n  successStates?: Array<TransactionFinalityStatus | TransactionExecutionStatus>;\n  errorStates?: Array<TransactionFinalityStatus | TransactionExecutionStatus>;\n};\n\nexport type getSimulateTransactionOptions = {\n  blockIdentifier?: BlockIdentifier;\n  skipValidate?: boolean;\n  skipExecute?: boolean;\n  skipFeeCharge?: boolean;\n};\n\nexport type getContractVersionOptions = {\n  blockIdentifier?: BlockIdentifier;\n  compiler?: boolean;\n};\n\nexport type getEstimateFeeBulkOptions = {\n  blockIdentifier?: BlockIdentifier;\n  skipValidate?: boolean;\n};\n\nexport interface CallStruct {\n  to: string;\n  selector: string;\n  calldata: string[];\n}\n\n/**\n * Represent Contract version\n */\nexport type ContractVersion = {\n  /** version of the cairo language */\n  cairo: CairoVersion;\n  /** version of the cairo compiler used to compile the contract */\n  compiler: CompilerVersion;\n};\n\nexport * from './contract';\n","import { ValuesType } from './helpers/valuesType';\n\nexport const ValidateType = {\n  DEPLOY: 'DEPLOY',\n  CALL: 'CALL',\n  INVOKE: 'INVOKE',\n} as const;\n\nexport type ValidateType = ValuesType<typeof ValidateType>;\n\nexport const Uint = {\n  u8: 'core::integer::u8',\n  u16: 'core::integer::u16',\n  u32: 'core::integer::u32',\n  u64: 'core::integer::u64',\n  u128: 'core::integer::u128',\n  u256: 'core::integer::u256', // This one is struct\n  u512: 'core::integer::u512', // This one is struct\n} as const;\n\nexport type Uint = ValuesType<typeof Uint>;\n\nexport const Literal = {\n  ClassHash: 'core::starknet::class_hash::ClassHash',\n  ContractAddress: 'core::starknet::contract_address::ContractAddress',\n  Secp256k1Point: 'core::starknet::secp256k1::Secp256k1Point',\n  U96: 'core::internal::bounded_int::BoundedInt::<0, 79228162514264337593543950335>',\n} as const;\n\nexport type Literal = ValuesType<typeof Literal>;\n\nexport const ETH_ADDRESS = 'core::starknet::eth_address::EthAddress';\nexport const NON_ZERO_PREFIX = 'core::zeroable::NonZero::';\n","import { BigNumberish, RawArgs, type Signature } from './lib';\n\nexport interface OutsideExecutionOptions {\n  /** authorized executer of the transaction(s):  Hex address or \"ANY_CALLER\" or shortString.encodeShortString(constants.OutsideExecutionCallerAny) */\n  caller: string;\n  /** Unix timestamp of the beginning of the timeframe */\n  execute_after: BigNumberish;\n  /** Unix timestamp of the end of the timeframe */\n  execute_before: BigNumberish;\n}\n\nexport interface OutsideCall {\n  to: string;\n  selector: BigNumberish;\n  calldata: RawArgs;\n}\n\nexport interface OutsideExecution {\n  caller: string;\n  nonce: BigNumberish;\n  execute_after: BigNumberish;\n  execute_before: BigNumberish;\n  calls: OutsideCall[];\n}\n\nexport interface OutsideTransaction {\n  outsideExecution: OutsideExecution;\n  signature: Signature;\n  signerAddress: BigNumberish;\n  version: OutsideExecutionVersion;\n}\n\nexport const OutsideExecutionTypesV1 = {\n  StarkNetDomain: [\n    { name: 'name', type: 'felt' },\n    { name: 'version', type: 'felt' },\n    { name: 'chainId', type: 'felt' },\n  ],\n  OutsideExecution: [\n    { name: 'caller', type: 'felt' },\n    { name: 'nonce', type: 'felt' },\n    { name: 'execute_after', type: 'felt' },\n    { name: 'execute_before', type: 'felt' },\n    { name: 'calls_len', type: 'felt' },\n    { name: 'calls', type: 'OutsideCall*' },\n  ],\n  OutsideCall: [\n    { name: 'to', type: 'felt' },\n    { name: 'selector', type: 'felt' },\n    { name: 'calldata_len', type: 'felt' },\n    { name: 'calldata', type: 'felt*' },\n  ],\n};\n\nexport const OutsideExecutionTypesV2 = {\n  StarknetDomain: [\n    // SNIP-12 revision 1 is used, so should be \"StarknetDomain\", not \"StarkNetDomain\"\n    { name: 'name', type: 'shortstring' },\n    { name: 'version', type: 'shortstring' }, // set to 2 in v2\n    { name: 'chainId', type: 'shortstring' },\n    { name: 'revision', type: 'shortstring' },\n  ],\n  OutsideExecution: [\n    { name: 'Caller', type: 'ContractAddress' },\n    { name: 'Nonce', type: 'felt' },\n    { name: 'Execute After', type: 'u128' },\n    { name: 'Execute Before', type: 'u128' },\n    { name: 'Calls', type: 'Call*' },\n  ],\n  Call: [\n    { name: 'To', type: 'ContractAddress' },\n    { name: 'Selector', type: 'selector' },\n    { name: 'Calldata', type: 'felt*' },\n  ],\n};\n\nexport enum OutsideExecutionVersion {\n  UNSUPPORTED = '0',\n  V1 = '1',\n  V2 = '2',\n}\n","// Reexport types from package\nexport {\n  TypedDataRevision,\n  type StarknetEnumType,\n  type StarknetMerkleType,\n  type StarknetType,\n  type StarknetDomain,\n  type TypedData,\n} from 'starknet-types-07';\n","import { stringify } from '../json';\nimport { RPC, RpcProviderOptions } from '../../types';\nimport { JRPC } from '../../types/api';\n\nexport type BatchClientOptions = {\n  nodeUrl: string;\n  headers: object;\n  interval: number;\n  baseFetch: NonNullable<RpcProviderOptions['baseFetch']>;\n};\n\nexport class BatchClient {\n  public nodeUrl: string;\n\n  public headers: object;\n\n  public interval: number;\n\n  public requestId: number = 0;\n\n  private pendingRequests: Record<string | number, JRPC.RequestBody> = {};\n\n  private batchPromises: Record<string | number, Promise<JRPC.ResponseBody[]>> = {};\n\n  private delayTimer?: NodeJS.Timeout;\n\n  private delayPromise?: Promise<void>;\n\n  private delayPromiseResolve?: () => void;\n\n  private baseFetch: BatchClientOptions['baseFetch'];\n\n  constructor(options: BatchClientOptions) {\n    this.nodeUrl = options.nodeUrl;\n    this.headers = options.headers;\n    this.interval = options.interval;\n    this.baseFetch = options.baseFetch;\n  }\n\n  private async wait(): Promise<void> {\n    // If the promise is not set, create a new one and store the resolve function\n    if (!this.delayPromise || !this.delayPromiseResolve) {\n      this.delayPromise = new Promise((resolve) => {\n        this.delayPromiseResolve = resolve;\n      });\n    }\n\n    if (this.delayTimer) {\n      clearTimeout(this.delayTimer);\n      this.delayTimer = undefined;\n    }\n\n    this.delayTimer = setTimeout(() => {\n      if (this.delayPromiseResolve) {\n        this.delayPromiseResolve();\n\n        // Reset the promise and resolve function so that a new promise is created next time\n        this.delayPromise = undefined;\n        this.delayPromiseResolve = undefined;\n      }\n    }, this.interval);\n\n    return this.delayPromise;\n  }\n\n  private addPendingRequest<T extends keyof RPC.Methods>(\n    method: T,\n    params?: RPC.Methods[T]['params'],\n    id?: string | number\n  ) {\n    const request: JRPC.RequestBody = {\n      id: id ?? `batched_${(this.requestId += 1)}`,\n      jsonrpc: '2.0',\n      method,\n      params: params ?? undefined,\n    };\n\n    this.pendingRequests[request.id] = request;\n\n    return request.id;\n  }\n\n  private async sendBatch(requests: JRPC.RequestBody[]) {\n    const raw = await this.baseFetch(this.nodeUrl, {\n      method: 'POST',\n      body: stringify(requests),\n      headers: this.headers as Record<string, string>,\n    });\n\n    return raw.json();\n  }\n\n  /**\n   * Automatically batches and fetches JSON-RPC calls in a single request.\n   * @param method Method to call\n   * @param params Method parameters\n   * @param id JSON-RPC Request ID\n   * @returns JSON-RPC Response\n   */\n  public async fetch<\n    T extends keyof RPC.Methods,\n    TResponse extends JRPC.ResponseBody & {\n      result?: RPC.Methods[T]['result'];\n      error?: JRPC.Error;\n    },\n  >(method: T, params?: RPC.Methods[T]['params'], id?: string | number): Promise<TResponse> {\n    const requestId = this.addPendingRequest(method, params, id);\n\n    // Wait for the interval to pass before sending the batch\n    await this.wait();\n\n    // Get the pending requests and clear the object\n    const requests = this.pendingRequests;\n    this.pendingRequests = {};\n\n    // If there is no promise for this batch, create one and send the batch\n    if (!this.batchPromises[requestId]) {\n      const promise = this.sendBatch(Object.values(requests));\n      Object.keys(requests).forEach((key) => {\n        this.batchPromises[key] = promise;\n      });\n    }\n\n    const results = await this.batchPromises[requestId];\n    delete this.batchPromises[requestId];\n\n    // Find this request in the results and return it\n    const result = results.find((res: any) => res.id === requestId);\n    if (!result) throw new Error(`Couldn't find the result for the request. Method: ${method}`);\n\n    return result as TResponse;\n  }\n}\n","/**\n * Asserts that the given condition is true, otherwise throws an error with an optional message.\n * @param {boolean} condition - The condition to check.\n * @param {string} [message] - The optional message to include in the error.\n * @throws {Error} Throws an error if the condition is false.\n * @example\n * ```typescript\n * const address = '0xa7ee790591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf';\n * assert(/^(0x)?[0-9a-fA-F]{64}$/.test(address), 'Invalid address format');\n * ```\n */\nexport default function assert(condition: boolean, message?: string): asserts condition {\n  if (!condition) {\n    throw new Error(message || 'Assertion failure');\n  }\n}\n","import { hexToBytes as hexToBytesNoble } from '@noble/curves/abstract/utils';\nimport { sha256 } from '@noble/hashes/sha256';\n\nimport { MASK_31 } from '../global/constants';\nimport { BigNumberish } from '../types';\nimport assert from './assert';\nimport { addHexPrefix, buf2hex, removeHexPrefix } from './encode';\nimport { isBigInt, isNumber, isString } from './typed';\n\n/** @deprecated prefer importing from 'types' over 'num' */\nexport type { BigNumberish };\n\n/**\n * Test if string is hex-string\n *\n * @param hex hex-string\n * @returns {boolean} true if the input string is a hexadecimal string, false otherwise\n * @example\n * ```typescript\n * const hexString1 = \"0x2fd23d9182193775423497fc0c472e156c57c69e4089a1967fb288a2d84e914\";\n * const result1 = isHex(hexString1);\n * // result1 = true\n *\n * const hexString2 = \"2fd23d9182193775423497fc0c472e156c57c69e4089a1967fb288a2d84e914\";\n * const result2 = isHex(hexString2);\n * // result2 = false\n * ```\n */\nexport function isHex(hex: string): boolean {\n  return /^0x[0-9a-f]*$/i.test(hex);\n}\n\n/**\n * Convert BigNumberish to bigint\n *\n * @param {BigNumberish} value value to convert\n * @returns {BigInt} converted value\n * @example\n * ```typescript\n * const str = '123';\n * const result = toBigInt(str);\n * // result = 123n\n * ```\n */\nexport function toBigInt(value: BigNumberish): bigint {\n  return BigInt(value);\n}\n\n/**\n * Convert BigNumberish to hex-string\n *\n * @param {BigNumberish} value value to convert\n * @returns {string} converted number in hex-string format\n * @example\n * ```typescript\n * toHex(100); // '0x64'\n * toHex('200'); // '0xc8'\n * ```\n */\nexport function toHex(value: BigNumberish): string {\n  return addHexPrefix(toBigInt(value).toString(16));\n}\n\n/**\n * Alias of ToHex\n */\nexport const toHexString = toHex;\n\n/**\n * Convert BigNumberish to storage-key-string\n *\n * Same as toHex but conforming to the STORAGE_KEY pattern `^0x0[0-7]{1}[a-fA-F0-9]{0,62}$`.\n *\n * A storage key is represented as up to 62 hex digits, 3 bits, and 5 leading zeroes:\n * `0x0 + [0-7] + 62 hex = 0x + 64 hex`\n * @returns format: storage-key-string\n * @example\n * ```typescript\n * toStorageKey(0x123); // '0x0000000000000000000000000000000000000000000000000000000000000123'\n * toStorageKey(123); // '0x000000000000000000000000000000000000000000000000000000000000007b'\n * toStorageKey('test'); // 'Error'\n * ```\n */\nexport function toStorageKey(number: BigNumberish): string {\n  // TODO: This is not completely correct as it will not enforce first 0 and second [0-7], 0x82bda... will pass as valid and should be false\n  return addHexPrefix(toBigInt(number).toString(16).padStart(64, '0'));\n}\n\n/**\n * Convert BigNumberish to hex format 0x + 64 hex chars\n *\n * Similar as toStorageKey but conforming to exactly 0x(64 hex chars).\n *\n * @returns format: hex-0x(64)-string\n * @example\n * ```typescript\n * toHex64(123); // '0x000000000000000000000000000000000000000000000000000000000000007b'\n * toHex64(123n); // '0x000000000000000000000000000000000000000000000000000000000000007b'\n * toHex64('test'); // 'Error'\n * ```\n */\nexport function toHex64(number: BigNumberish): string {\n  const res = addHexPrefix(toBigInt(number).toString(16).padStart(64, '0'));\n  if (res.length !== 66) throw TypeError('number is too big for hex 0x(64) representation');\n  return res;\n}\n\n/**\n * Convert hexadecimal string to decimal string\n *\n * @param {string} hex hex-string to convert\n * @returns {string} converted number in decimal string format\n * @example\n * ```typescript\n * hexToDecimalString('64'); // '100'\n * hexToDecimalString('c8'); // '200'\n * ```\n */\nexport function hexToDecimalString(hex: string): string {\n  return BigInt(addHexPrefix(hex)).toString(10);\n}\n\n/**\n * Remove hex-string leading zeroes and lowercase it\n *\n * @param {string} hex hex-string\n * @returns {string} updated string in hex-string format\n * @example\n * ```typescript\n * cleanHex('0x00023AB'); // '0x23ab'\n * ```\n */\nexport function cleanHex(hex: string): string {\n  return hex.toLowerCase().replace(/^(0x)0+/, '$1');\n}\n\n/**\n * Asserts input is equal to or greater then lowerBound and lower then upperBound.\n *\n * The `inputName` parameter is used in the assertion message.\n * @param input Value to check\n * @param lowerBound Lower bound value\n * @param upperBound Upper bound value\n * @param inputName Name of the input for error message\n * @throws Error if input is out of range\n * @example\n * ```typescript\n * const input1:BigNumberish = 10;\n * assertInRange(input1, 5, 20, 'value')\n *\n * const input2: BigNumberish = 25;\n * assertInRange(input2, 5, 20, 'value');\n * // throws Error: Message not signable, invalid value length.\n * ```\n */\nexport function assertInRange(\n  input: BigNumberish,\n  lowerBound: BigNumberish,\n  upperBound: BigNumberish,\n  inputName = ''\n) {\n  const messageSuffix = inputName === '' ? 'invalid length' : `invalid ${inputName} length`;\n  const inputBigInt = BigInt(input);\n  const lowerBoundBigInt = BigInt(lowerBound);\n  const upperBoundBigInt = BigInt(upperBound);\n\n  assert(\n    inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt,\n    `Message not signable, ${messageSuffix}.`\n  );\n}\n\n/**\n * Convert BigNumberish array to decimal string array\n *\n * @param {BigNumberish[]} data array of big-numberish elements\n * @returns {string[]} array of decimal strings\n * @example\n * ```typescript\n * const data = [100, 200n];\n * const result = bigNumberishArrayToDecimalStringArray(data);\n * // result = ['100', '200']\n * ```\n */\nexport function bigNumberishArrayToDecimalStringArray(data: BigNumberish[]): string[] {\n  return data.map((x) => toBigInt(x).toString(10));\n}\n\n/**\n * Convert BigNumberish array to hexadecimal string array\n *\n * @param {BigNumberish[]} data array of big-numberish elements\n * @returns array of hex-strings\n * @example\n * ```typescript\n * const data = [100, 200n];\n * const result = bigNumberishArrayToHexadecimalStringArray(data);\n * // result = ['0x64', '0xc8']\n * ```\n */\nexport function bigNumberishArrayToHexadecimalStringArray(data: BigNumberish[]): string[] {\n  return data.map((x) => toHex(x));\n}\n\n/**\n * Test if string is a whole number (0, 1, 2, 3...)\n *\n * @param {string} str string to test\n * @returns {boolean}: true if string is a whole number, false otherwise\n * @example\n * ```typescript\n * isStringWholeNumber('100'); // true\n * isStringWholeNumber('10.0'); // false\n * isStringWholeNumber('test'); // false\n * ```\n */\nexport function isStringWholeNumber(str: string): boolean {\n  return /^\\d+$/.test(str);\n}\n\n/**\n * Convert string to decimal string\n *\n * @param {string} str string to convert\n * @returns converted string in decimal format\n * @throws str needs to be a number string in hex or whole number format\n * @example\n * ```typescript\n * const result = getDecimalString(\"0x1a\");\n * // result = \"26\"\n *\n * const result2 = getDecimalString(\"Hello\");\n * // throws Error: \"Hello needs to be a hex-string or whole-number-string\"\n * ```\n */\nexport function getDecimalString(str: string) {\n  if (isHex(str)) {\n    return hexToDecimalString(str);\n  }\n  if (isStringWholeNumber(str)) {\n    return str;\n  }\n  throw new Error(`${str} needs to be a hex-string or whole-number-string`);\n}\n\n/**\n * Convert string to hexadecimal string\n *\n * @param {string} str string to convert\n * @returns converted hex-string\n * @throws str needs to be a number string in hex or whole number format\n * @example\n * ```typescript\n * const result = getHexString(\"123\");\n * // result = \"0x7b\"\n *\n * const result2 = getHexString(\"Hello\");\n * // throws Error: Hello needs to be a hex-string or whole-number-string\n * ```\n */\nexport function getHexString(str: string) {\n  if (isHex(str)) {\n    return str;\n  }\n  if (isStringWholeNumber(str)) {\n    return toHexString(str);\n  }\n  throw new Error(`${str} needs to be a hex-string or whole-number-string`);\n}\n\n/**\n * Convert string array to hex-string array\n *\n * @param {Array<string>} array array of string elements\n * @returns array of converted elements in hex-string format\n * @example\n * ```typescript\n * const data = ['100', '200', '0xaa'];\n * const result = getHexStringArray(data);\n * // result = ['0x64', '0xc8', '0xaa']\n * ```\n */\nexport function getHexStringArray(array: Array<string>) {\n  return array.map(getHexString);\n}\n\n/**\n * Convert boolean to \"0\" or \"1\"\n *\n * @param value The boolean value to be converted.\n * @returns {boolean} Returns true if the value is a number, otherwise returns false.\n * @example\n * ```typescript\n * const result = toCairoBool(true);\n * // result =\"1\"\n *\n * const result2 = toCairoBool(false);\n * // result2 = \"0\"\n * ```\n */\nexport function toCairoBool(value: boolean): string {\n  return (+value).toString();\n}\n\n/**\n * Convert hex-string to an array of Bytes (Uint8Array)\n *\n * @param {string} str hex-string\n * @returns {Uint8Array} array containing the converted elements\n * @throws str must be a hex-string\n * @example\n * ```typescript\n * let result;\n *\n * result = hexToBytes('0x64');\n * // result = [100]\n *\n * result = hexToBytes('test');\n * // throws Error: test needs to be a hex-string\n * ```\n */\nexport function hexToBytes(str: string): Uint8Array {\n  if (!isHex(str)) throw new Error(`${str} needs to be a hex-string`);\n\n  let adaptedValue: string = removeHexPrefix(str);\n  if (adaptedValue.length % 2 !== 0) {\n    adaptedValue = `0${adaptedValue}`;\n  }\n  return hexToBytesNoble(adaptedValue);\n}\n\n/**\n * Adds a percentage amount to the value\n *\n * @param number value to be modified\n * @param percent integer as percent ex. 50 for 50%\n * @returns {bigint} modified value\n * @example\n * ```typescript\n * addPercent(100, 50); // 150n\n * addPercent(100, 100); // 200n\n * addPercent(200, 50); // 300n\n * addPercent(200, -50); // 100n\n * addPercent(200, -100); // 0n\n * addPercent(200, -150); // -100n\n * ```\n */\nexport function addPercent(number: BigNumberish, percent: number): bigint {\n  const bigIntNum = BigInt(number);\n  return bigIntNum + (bigIntNum * BigInt(percent)) / 100n;\n}\n\n/**\n * Calculate the sha256 hash of an utf8 string, then encode the\n * result in an uint8Array of 4 elements.\n * Useful in wallet path calculation.\n * @param {string} str utf8 string (hex string not handled).\n * @returns a uint8Array of 4 bytes.\n * @example\n * ```typescript\n * const ledgerPathApplicationName = 'LedgerW';\n * const path2Buffer = num.stringToSha256ToArrayBuff4(ledgerPathApplicationName);\n * // path2Buffer = Uint8Array(4) [43, 206, 231, 219]\n * ```\n */\nexport function stringToSha256ToArrayBuff4(str: string): Uint8Array {\n  // eslint-disable-next-line no-bitwise\n  const int31 = (n: bigint) => Number(n & MASK_31);\n  const result: number = int31(BigInt(addHexPrefix(buf2hex(sha256(str)))));\n  return hexToBytes(toHex(result));\n}\n\n/**\n * Checks if a given value is of BigNumberish type.\n * 234, 234n, \"234\", \"0xea\" are valid\n * @param {unknown} input a value\n * @returns {boolean} true if type of input is `BigNumberish`\n * @example\n * ```typescript\n * const res = num.isBigNumberish(\"ZERO\");\n * // res = false\n *  ```\n */\nexport function isBigNumberish(input: unknown): input is BigNumberish {\n  return (\n    isNumber(input) ||\n    isBigInt(input) ||\n    (isString(input) && (isHex(input) || isStringWholeNumber(input)))\n  );\n}\n","/**\n * Check if a value is a undefined.\n *\n * @param {unknown} value - The value to check.\n * @returns {boolean} Returns true if the value is a undefined, otherwise returns false.\n * @example\n * ```typescript\n * const result = isUndefined(undefined);\n * // result = true\n *\n * const result2 = isUndefined('existing value');\n * // result2 = false\n * ```\n * @return {boolean} Returns true if the value is undefined, otherwise returns false.\n */\nexport const isUndefined = (value: unknown): value is undefined => {\n  return typeof value === 'undefined' || value === undefined;\n};\n\n/**\n * Check if a value is a number.\n *\n * @param {unknown} value - The value to check.\n * @returns {boolean} Returns true if the value is a number, otherwise returns false.\n * @example\n * ```typescript\n * const result = isNumber(123);\n * // result = true\n *\n * const result2 = isNumber(\"123\");\n * // result2 = false\n * ```\n * @return {boolean} Returns true if the value is a number, otherwise returns false.\n */\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number';\n}\n\n/**\n * Checks if a given value is of boolean type.\n *\n * @param {unknown} value - The value to check.\n * @returns {boolean} - True if the value is of boolean type, false otherwise.\n * @example\n * ```typescript\n * const result = isBoolean(true);\n * // result = true\n *\n * const result2 = isBoolean(false);\n * // result2 = false\n * ```\n * @return {boolean} - True if the value is of boolean type, false otherwise.\n */\nexport function isBoolean(value: unknown): value is boolean {\n  return typeof value === 'boolean';\n}\n\n/**\n * Test if value is bigint\n *\n * @param value value to test\n * @returns {boolean} true if value is bigint, false otherwise\n * @example\n * ```typescript\n * isBigInt(10n); // true\n * isBigInt(BigInt('10')); // true\n * isBigInt(10); // false\n * isBigInt('10'); // false\n * isBigInt(null); // false\n * ```\n */\nexport function isBigInt(value: any): value is bigint {\n  return typeof value === 'bigint';\n}\n\n/**\n * Checks if a given value is a string.\n * @param {unknown} value the value to be checked.\n * @return {boolean} returns true if the value is a string, false otherwise.\n * @example\n * ```typescript\n * const result = shortString.isString(\"12345\");\n * // result = true\n * ```\n */\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\n/**\n * Checks if a given value is an object (Object or Array)\n * @param {unknown} item the tested item\n * @returns {boolean}\n * @example\n * ```typescript\n * const result = events.isObject({event: \"pending\"});\n * // result = true\n * ```\n */\nexport function isObject(item: unknown | undefined): boolean {\n  return !!item && typeof item === 'object' && !Array.isArray(item);\n}\n","import { keccak } from '@scure/starknet';\nimport { keccak_256 } from '@noble/hashes/sha3';\nimport { bytesToHex } from '@noble/curves/abstract/utils';\nimport { MASK_250 } from '../../global/constants';\nimport { BigNumberish } from '../../types';\nimport { addHexPrefix, removeHexPrefix, utf8ToArray } from '../encode';\nimport { hexToBytes, isHex, isStringWholeNumber, toHex } from '../num';\nimport { isBigInt, isNumber } from '../typed';\n\n/**\n * Calculate the hex-string Starknet Keccak hash for a given BigNumberish\n *\n * @param value value to hash\n * @returns hex-string Keccak hash\n * @example\n * ```typescript\n * const result = keccakBn('0xabc');\n * // result = '0x11cf08aac85935e32397f410e48217a127b6855d41b1e3877eb4179c0904b77'\n * ```\n */\nexport function keccakBn(value: BigNumberish): string {\n  const hexWithoutPrefix = removeHexPrefix(toHex(BigInt(value)));\n  const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;\n  return addHexPrefix(keccak(hexToBytes(addHexPrefix(evenHex))).toString(16));\n}\n\n/**\n * [internal]\n * Calculate hex-string Starknet Keccak hash for a given string\n *\n * String -> hex-string Keccak hash\n * @returns format: hex-string\n */\nfunction keccakHex(str: string): string {\n  return addHexPrefix(keccak(utf8ToArray(str)).toString(16));\n}\n\n/**\n * Calculate the BigInt Starknet Keccak hash for a given string\n * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/public/abi.py#L38)\n *\n * @param str value to hash\n * @returns BigInt Keccak hash\n * @example\n * ```typescript\n * const result = starknetKeccak('test').toString();\n * // result = '61835310290161785288773114225739080147441215596947647498723774891619563096'\n * ```\n */\nexport function starknetKeccak(str: string): bigint {\n  const hash = BigInt(keccakHex(str));\n  // eslint-disable-next-line no-bitwise\n  return hash & MASK_250;\n}\n\n/**\n * Calculate the hex-string selector for a given abi function name\n * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/public/abi.py#L46)\n *\n * @param funcName abi function name\n * @returns hex-string selector\n * @example\n * ```typescript\n * const result = getSelectorFromName('myFunction');\n * // result = '0xc14cfe23f3fa7ce7b1f8db7d7682305b1692293f71a61cc06637f0d8d8b6c8'\n * ```\n */\nexport function getSelectorFromName(funcName: string) {\n  // sometimes BigInteger pads the hex string with zeros, which is not allowed in the starknet api\n  return toHex(starknetKeccak(funcName));\n}\n\n/**\n * Calculate the hex-string selector from a given abi function name or of any representation of number.\n *\n * @param value ascii-string | hex-string | dec-string | number | BigInt\n * @returns hex-string selector\n * @example\n * ```typescript\n * const selector1: string = getSelector(\"myFunction\");\n * // selector1 = \"0xc14cfe23f3fa7ce7b1f8db7d7682305b1692293f71a61cc06637f0d8d8b6c8\"\n *\n * const selector2: string = getSelector(\"0x123abc\");\n * // selector2 = \"0x123abc\"\n *\n * const selector3: string = getSelector(\"123456\");\n * // selector3 = \"0x1e240\"\n *\n * const selector4: string = getSelector(123456n);\n * // selector4 = \"0x1e240\"\n * ```\n */\nexport function getSelector(value: string | BigNumberish) {\n  if (isNumber(value) || isBigInt(value)) return toHex(value);\n  if (isHex(value)) return value;\n  if (isStringWholeNumber(value)) return toHex(value);\n  return getSelectorFromName(value);\n}\n\n/**\n * Solidity hash of an array of uint256\n * @param {BigNumberish[]} params an array of uint256 numbers\n * @returns the hash of the array of Solidity uint256\n * @example\n * ```typescript\n * const result = hash.solidityUint256PackedKeccak256(['0x100', '200', 300, 400n]);\n * // result = '0xd1e6cb422b65269603c491b0c85463295edabebfb2a6844e4fdc389ff1dcdd97'\n * ```\n */\nexport function solidityUint256PackedKeccak256(params: BigNumberish[]): string {\n  const myEncode = addHexPrefix(\n    params.reduce(\n      (res: string, par: BigNumberish) => res + removeHexPrefix(toHex(par)).padStart(64, '0'),\n      ''\n    )\n  );\n  return addHexPrefix(bytesToHex(keccak_256(hexToBytes(myEncode))));\n}\n\n/**\n * Calculate the L2 message hash related by a message L1->L2\n * @param {BigNumberish} l1FromAddress L1 account address that paid the message.\n * @param {BigNumberish} l2ToAddress L2 contract address to execute.\n * @param {string | BigNumberish} l2Selector can be a function name (\"bridge_withdraw\") or a number (BigNumberish).\n * @param {RawCalldata} l2Calldata an array of BigNumberish of the raw parameters passed to the above function.\n * @param {BigNumberish} l1Nonce The nonce of the L1 account.\n * @returns {string} hex-string of the L2 transaction hash\n * @example\n * ```typescript\n * const l1FromAddress = \"0x0000000000000000000000008453fc6cd1bcfe8d4dfc069c400b433054d47bdc\";\n * const l2ToAddress = 2158142789748719025684046545159279785659305214176670733242887773692203401023n;\n * const l2Selector = 774397379524139446221206168840917193112228400237242521560346153613428128537n;\n * const payload = [\n *     4543560n,\n *    829565602143178078434185452406102222830667255948n,\n *     3461886633118033953192540141609307739580461579986333346825796013261542798665n,\n *     9000000000000000n,\n *     0n,\n * ];\n * const l1Nonce = 8288n;\n * const result = hash.getL2MessageHash(l1FromAddress, l2ToAddress, l2Selector, payload, l1Nonce);\n * // result = \"0x2e350fa9d830482605cb68be4fdb9f0cb3e1f95a0c51623ac1a5d1bd997c2090\"\n * ```\n */\nexport function getL2MessageHash(\n  l1FromAddress: BigNumberish,\n  l2ToAddress: BigNumberish,\n  l2Selector: string | BigNumberish,\n  l2Calldata: BigNumberish[],\n  l1Nonce: BigNumberish\n): string {\n  return solidityUint256PackedKeccak256([\n    l1FromAddress,\n    l2ToAddress,\n    l1Nonce,\n    l2Selector,\n    l2Calldata.length,\n    ...l2Calldata,\n  ]);\n}\n","import { TEXT_TO_FELT_MAX_LEN } from '../global/constants';\nimport { addHexPrefix, removeHexPrefix } from './encode';\nimport { isHex, isStringWholeNumber } from './num';\nimport { isString } from './typed';\n\n/**\n * Test if string contains only ASCII characters (string can be ascii text)\n * @param {string} str The string to test\n * @returns {boolean} Returns true if the string contains only ASCII characters, otherwise false\n * @example\n * ```typescript\n * const result = shortString.isASCII(\"Hello, world!\");\n * // result = true\n * const result = shortString.isASCII(\"Hello, !\");\n * // result = false\n * ```\n */\nexport function isASCII(str: string): boolean {\n  // eslint-disable-next-line no-control-regex\n  return /^[\\x00-\\x7F]*$/.test(str);\n}\n\n/**\n * Test if a string is a Cairo short string (string with less or equal 31 characters)\n * @param {string} str the string to test\n * @returns {boolean} Returns true if the string has less than or equal to 31 characters, otherwise false.\n * @example\n * ```typescript\n * const result = shortString.isShortString(\"Hello, world!\");\n * // result = true\n * ```\n */\nexport function isShortString(str: string): boolean {\n  return str.length <= TEXT_TO_FELT_MAX_LEN;\n}\n\n/**\n * Test if string contains only numbers (string can be converted to decimal integer number)\n * @param {string} str the string to test.\n * @returns {boolean} Returns true if the string contains only numbers, otherwise false.\n * @example\n * ```typescript\n * const result = shortString.isDecimalString(\"12345\");\n * // result = true\n * const result = shortString.isDecimalString(\"12a45\");\n * // result = false\n * ```\n */\nexport function isDecimalString(str: string): boolean {\n  return /^[0-9]*$/i.test(str);\n}\n\n/**\n * Test if value is a pure string text, and not a hex string or number string\n * @param {any} val the value to test\n * @returns {boolean} returns true if the value is a free-form string text, otherwise false\n * @example\n * ```typescript\n * const result = shortString.isText(\"Hello, world!\");\n * // result = true\n * const result = shortString.isText(\"0x7aec92f706\");\n * // result = false\n * ```\n */\nexport function isText(val: any): boolean {\n  return isString(val) && !isHex(val) && !isStringWholeNumber(val);\n}\n\n/**\n * Test if value is short text\n * @param {any} val - The item to test\n * @returns {boolean} Returns true if the value is a short text (string has less or equal 31 characters), otherwise false\n * @example\n * ```typescript\n * const result = shortString.isShortText(\"Hello, world!\");\n * // result = true\n * ```\n */\nexport const isShortText = (val: any): boolean => isText(val) && isShortString(val);\n\n/**\n * Test if value is long text\n * @param {any} val the value to test\n * @returns {boolean} returns true if the value is a long text(string has more than 31 characters), otherwise false.\n * @example\n * ```typescript\n * const result = shortString.isLongText(\"Hello, world! this is some random long string to enable you test isLongText function.\");\n * // result = true\n * ```\n */\nexport const isLongText = (val: any): boolean => isText(val) && !isShortString(val);\n\n/**\n * Split long text (string greater than 31 characters) into short strings (string lesser or equal 31 characters)\n * @param {string} longStr the long text (string greater than 31 characters) to split\n * @returns {string[]} an array of short strings (string lesser or equal 31 characters).\n * @example\n * ```typescript\n * const result = shortString.splitLongString(\"Hello, world! we just testing splitLongString function.\");\n * // result = [ 'Hello, world! we just testing s', 'plitLongString function.' ]\n * ```\n */\nexport function splitLongString(longStr: string): string[] {\n  const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, 'g');\n  return longStr.match(regex) || [];\n}\n\n/**\n * Convert an ASCII short string to a hexadecimal string.\n * @param {string} str short string (ASCII string, 31 characters max)\n * @returns {string} hex-string with 248 bits max\n * @example\n * ```typescript\n * const result = shortString.encodeShortString(\"uri/pict/t38.jpg\");\n * // result = \"0x7572692f706963742f7433382e6a7067\"\n * ```\n */\nexport function encodeShortString(str: string): string {\n  if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n  if (!isShortString(str)) throw new Error(`${str} is too long`);\n  return addHexPrefix(str.replace(/./g, (char) => char.charCodeAt(0).toString(16)));\n}\n\n/**\n * Convert a hexadecimal or decimal string to an ASCII string.\n * @param {string} str representing a 248 bit max number (ex. \"0x1A4F64EA56\" or \"236942575435676423\")\n * @returns {string} short string; 31 characters max\n * @example\n * ```typescript\n * const result = shortString.decodeShortString(\"0x7572692f706963742f7433382e6a7067\");\n * // result = \"uri/pict/t38.jpg\"\n * ```\n */\nexport function decodeShortString(str: string): string {\n  if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n  if (isHex(str)) {\n    return removeHexPrefix(str).replace(/.{2}/g, (hex) => String.fromCharCode(parseInt(hex, 16)));\n  }\n  if (isDecimalString(str)) {\n    return decodeShortString('0X'.concat(BigInt(str).toString(16)));\n  }\n  throw new Error(`${str} is not Hex or decimal`);\n}\n","import { BigNumberish, ByteArray } from '../../types/lib';\nimport { toHex } from '../num';\nimport { decodeShortString, encodeShortString, splitLongString } from '../shortString';\n\n/**\n * convert a Cairo ByteArray to a JS string\n * @param myByteArray Cairo representation of a LongString\n * @returns a JS string\n * @example\n * ```typescript\n * const myByteArray = {\n *    data: [],\n *    pending_word: '0x414243444546474849',\n *    pending_word_len: 9\n * }\n * const result: String = stringFromByteArray(myByteArray); // ABCDEFGHI\n * ```\n */\nexport function stringFromByteArray(myByteArray: ByteArray): string {\n  const pending_word: string =\n    BigInt(myByteArray.pending_word) === 0n\n      ? ''\n      : decodeShortString(toHex(myByteArray.pending_word));\n  return (\n    myByteArray.data.reduce<string>((cumuledString, encodedString: BigNumberish) => {\n      const add: string =\n        BigInt(encodedString) === 0n ? '' : decodeShortString(toHex(encodedString));\n      return cumuledString + add;\n    }, '') + pending_word\n  );\n}\n\n/**\n * convert a JS string to a Cairo ByteArray\n * @param targetString a JS string\n * @returns Cairo representation of a LongString\n * @example\n * ```typescript\n * const myByteArray: ByteArray = byteArrayFromString(\"ABCDEFGHI\");\n * ```\n * Result is :\n * {\n *    data: [],\n *    pending_word: '0x414243444546474849',\n *    pending_word_len: 9\n * }\n */\nexport function byteArrayFromString(targetString: string): ByteArray {\n  const shortStrings: string[] = splitLongString(targetString);\n  const remainder: string = shortStrings[shortStrings.length - 1];\n  const shortStringsEncoded: BigNumberish[] = shortStrings.map(encodeShortString);\n\n  const [pendingWord, pendingWordLength] =\n    remainder === undefined || remainder.length === 31\n      ? ['0x00', 0]\n      : [shortStringsEncoded.pop()!, remainder.length];\n\n  return {\n    data: shortStringsEncoded.length === 0 ? [] : shortStringsEncoded,\n    pending_word: pendingWord,\n    pending_word_len: pendingWordLength,\n  };\n}\n","import {\n  Abi,\n  AbiEnums,\n  AbiStructs,\n  BigNumberish,\n  ContractVersion,\n  ETH_ADDRESS,\n  Literal,\n  NON_ZERO_PREFIX,\n  Uint,\n  Uint256,\n  Uint512,\n} from '../../types';\nimport { CairoFelt } from '../cairoDataTypes/felt';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport { CairoUint512 } from '../cairoDataTypes/uint512';\n\n// Intended for internal usage, maybe should be exported somewhere else and not exported to utils\n/**\n * Checks if the given name ends with \"_len\".\n *\n * @param {string} name - The name to be checked.\n * @returns - True if the name ends with \"_len\", false otherwise.\n */\nexport const isLen = (name: string) => /_len$/.test(name);\n/**\n * Checks if a given type is felt.\n *\n * @param {string} type - The type to check.\n * @returns - True if the type is felt, false otherwise.\n */\nexport const isTypeFelt = (type: string) => type === 'felt' || type === 'core::felt252';\n/**\n * Checks if the given type is an array type.\n *\n * @param {string} type - The type to check.\n * @returns - `true` if the type is an array type, `false` otherwise.\n */\nexport const isTypeArray = (type: string) =>\n  /\\*/.test(type) ||\n  type.startsWith('core::array::Array::') ||\n  type.startsWith('core::array::Span::');\n\n/**\n * Checks if the given type is a tuple type.\n *\n * @param {string} type - The type to be checked.\n * @returns - `true` if the type is a tuple type, otherwise `false`.\n */\nexport const isTypeTuple = (type: string) => /^\\(.*\\)$/i.test(type);\n/**\n * Checks whether a given type is a named tuple.\n *\n * @param {string} type - The type to be checked.\n * @returns - True if the type is a named tuple, false otherwise.\n */\nexport const isTypeNamedTuple = (type: string) => /\\(.*\\)/i.test(type) && type.includes(':');\n/**\n * Checks if a given type is a struct.\n *\n * @param {string} type - The type to check for existence.\n * @param {AbiStructs} structs - The collection of structs to search in.\n * @returns - True if the type exists in the structs, false otherwise.\n */\nexport const isTypeStruct = (type: string, structs: AbiStructs) => type in structs;\n/**\n * Checks if a given type is an enum.\n *\n * @param {string} type - The type to check.\n * @param {AbiEnums} enums - The enumeration to search in.\n * @returns - True if the type exists in the enumeration, otherwise false.\n */\nexport const isTypeEnum = (type: string, enums: AbiEnums) => type in enums;\n/**\n * Determines if the given type is an Option type.\n *\n * @param {string} type - The type to check.\n * @returns - True if the type is an Option type, false otherwise.\n */\nexport const isTypeOption = (type: string) => type.startsWith('core::option::Option::');\n/**\n * Checks whether a given type starts with 'core::result::Result::'.\n *\n * @param {string} type - The type to check.\n * @returns - True if the type starts with 'core::result::Result::', false otherwise.\n */\nexport const isTypeResult = (type: string) => type.startsWith('core::result::Result::');\n/**\n * Checks if the given value is a valid Uint type.\n *\n * @param {string} type - The value to check.\n * @returns - Returns true if the value is a valid Uint type, otherwise false.\n */\nexport const isTypeUint = (type: string) => Object.values(Uint).includes(type as Uint);\n// Legacy Export\n/**\n * Checks if the given type is `uint256`.\n *\n * @param {string} type - The type to be checked.\n * @returns - Returns true if the type is `uint256`, otherwise false.\n */\nexport const isTypeUint256 = (type: string) => CairoUint256.isAbiType(type);\n/**\n * Checks if the given type is a literal type.\n *\n * @param {string} type - The type to check.\n * @returns - True if the type is a literal type, false otherwise.\n */\nexport const isTypeLiteral = (type: string) => Object.values(Literal).includes(type as Literal);\n/**\n * Checks if the given type is a boolean type.\n *\n * @param {string} type - The type to be checked.\n * @returns - Returns true if the type is a boolean type, otherwise false.\n */\nexport const isTypeBool = (type: string) => type === 'core::bool';\n/**\n * Checks if the provided type is equal to 'core::starknet::contract_address::ContractAddress'.\n * @param {string} type - The type to be checked.\n * @returns - true if the type matches 'core::starknet::contract_address::ContractAddress', false otherwise.\n */\nexport const isTypeContractAddress = (type: string) => type === Literal.ContractAddress;\n/**\n * Determines if the given type is an Ethereum address type.\n *\n * @param {string} type - The type to check.\n * @returns - Returns true if the given type is 'core::starknet::eth_address::EthAddress', otherwise false.\n */\nexport const isTypeEthAddress = (type: string) => type === ETH_ADDRESS;\n/**\n * Checks if the given type is 'core::bytes_31::bytes31'.\n *\n * @param {string} type - The type to check.\n * @returns - True if the type is 'core::bytes_31::bytes31', false otherwise.\n */\nexport const isTypeBytes31 = (type: string) => type === 'core::bytes_31::bytes31';\n/**\n * Checks if the given type is equal to the 'core::byte_array::ByteArray'.\n *\n * @param {string} type - The type to check.\n * @returns - True if the given type is equal to 'core::byte_array::ByteArray', false otherwise.\n */\nexport const isTypeByteArray = (type: string) => type === 'core::byte_array::ByteArray';\n\n/**\n * Checks if the given type is equal to the u96 type\n *\n * @param {string} type - The type to check.\n * @returns - True if the given type is equal to u96, false otherwise.\n */\nexport const isTypeU96 = (type: string) =>\n  type === 'core::internal::bounded_int::BoundedInt::<0, 79228162514264337593543950335>';\n\nexport const isTypeSecp256k1Point = (type: string) => type === Literal.Secp256k1Point;\n\nexport const isCairo1Type = (type: string) => type.includes('::');\n/**\n * Retrieves the array type from the given type string.\n *\n * Works also for core::zeroable::NonZero type.\n * @param {string} type - The type string.\n * @returns - The array type.\n */\nexport const getArrayType = (type: string) => {\n  return isCairo1Type(type)\n    ? type.substring(type.indexOf('<') + 1, type.lastIndexOf('>'))\n    : type.replace('*', '');\n};\n\n/**\n * Test if an ABI comes from a Cairo 1 contract\n * @param abi representing the interface of a Cairo contract\n * @returns TRUE if it is an ABI from a Cairo1 contract\n * @example\n * ```typescript\n * const isCairo1: boolean = isCairo1Abi(myAbi: Abi);\n * ```\n */\nexport function isCairo1Abi(abi: Abi): boolean {\n  const { cairo } = getAbiContractVersion(abi);\n  if (cairo === undefined) {\n    throw Error('Unable to determine Cairo version');\n  }\n  return cairo === '1';\n}\n\n/**\n * Checks if the given type is a NonZero type.\n *\n * @param {string} type The type to check.\n * @returns `true` if the type is NonZero type, `false` otherwise.\n * @example\n * ```typescript\n * const result = cairo.isTypeNonZero(\"core::zeroable::NonZero::<u8>\");\n * //result = true\n * ```\n */\nexport function isTypeNonZero(type: string): boolean {\n  return type.startsWith(NON_ZERO_PREFIX);\n}\n\n/**\n * Return ContractVersion (Abi version) based on Abi\n * or undefined for unknown version\n * @param abi\n * @returns string\n */\nexport function getAbiContractVersion(abi: Abi): ContractVersion {\n  // determine by interface for \"Cairo 1.2\"\n  if (abi.find((it) => it.type === 'interface')) {\n    return { cairo: '1', compiler: '2' };\n  }\n\n  // determine by function io types \"Cairo 1.1\" or \"Cairo 0.0\"\n  // find first function with inputs or outputs\n  const testSubject = abi.find(\n    (it) =>\n      (it.type === 'function' || it.type === 'constructor') &&\n      (it.inputs.length || it.outputs.length)\n  );\n\n  if (!testSubject) {\n    return { cairo: undefined, compiler: undefined };\n  }\n  const io = testSubject.inputs.length ? testSubject.inputs : testSubject.outputs;\n  if (isCairo1Type(io[0].type)) {\n    return { cairo: '1', compiler: '1' };\n  }\n  return { cairo: '0', compiler: '0' };\n}\n\n/**\n * named tuple cairo type is described as js object {}\n * struct cairo type are described as js object {}\n * array cairo type are described as js array []\n */\n\n/**\n * Create Uint256 Cairo type (helper for common struct type)\n * @example\n * ```typescript\n * uint256('892349863487563453485768723498');\n * ```\n */\nexport const uint256 = (it: BigNumberish): Uint256 => {\n  return new CairoUint256(it).toUint256DecimalString();\n};\n\n/**\n * Create Uint512 Cairo type (helper for common struct type)\n * @param it BigNumberish representation of a 512 bits unsigned number\n * @returns Uint512 struct\n * @example\n * ```typescript\n * uint512('345745685892349863487563453485768723498');\n * ```\n */\nexport const uint512 = (it: BigNumberish): Uint512 => {\n  return new CairoUint512(it).toUint512DecimalString();\n};\n\n/**\n * Create unnamed tuple Cairo type (helper same as common struct type)\n * @example\n * ```typescript\n * tuple(1, '0x101', 16);\n * ```\n */\nexport const tuple = (\n  ...args: (BigNumberish | object | boolean)[]\n): Record<number, BigNumberish | object | boolean> => ({ ...args });\n\n/**\n * Create felt Cairo type (cairo type helper)\n * @returns format: felt-string\n */\nexport function felt(it: BigNumberish): string {\n  return CairoFelt(it);\n}\n","// TODO Convert to CairoFelt base on CairoUint256 and implement it in the codebase in the backward compatible manner\n\nimport { BigNumberish, isHex, isStringWholeNumber } from '../num';\nimport { encodeShortString, isShortString, isText } from '../shortString';\nimport { isBoolean, isString, isBigInt } from '../typed';\n\n/**\n * Create felt Cairo type (cairo type helper)\n * @returns format: felt-string\n */\nexport function CairoFelt(it: BigNumberish): string {\n  // BN or number\n  if (isBigInt(it) || Number.isInteger(it)) {\n    return it.toString();\n  }\n\n  // Handling strings\n  if (isString(it)) {\n    // Hex strings\n    if (isHex(it)) {\n      return BigInt(it).toString();\n    }\n    // Text strings that must be short\n    if (isText(it)) {\n      if (!isShortString(it)) {\n        throw new Error(\n          `${it} is a long string > 31 chars. Please split it into an array of short strings.`\n        );\n      }\n      // Assuming encodeShortString returns a hex representation of the string\n      return BigInt(encodeShortString(it)).toString();\n    }\n    // Whole numeric strings\n    if (isStringWholeNumber(it)) {\n      return it;\n    }\n  }\n  // bool to felt\n  if (isBoolean(it)) {\n    return `${+it}`;\n  }\n\n  throw new Error(`${it} can't be computed by felt()`);\n}\n","/* eslint-disable no-bitwise */\n/**\n * Singular class handling cairo u256 data type\n */\n\nimport { BigNumberish, Uint256 } from '../../types';\nimport { addHexPrefix } from '../encode';\nimport { CairoFelt } from './felt';\n\nexport const UINT_128_MAX = (1n << 128n) - 1n;\nexport const UINT_256_MAX = (1n << 256n) - 1n;\nexport const UINT_256_MIN = 0n;\nexport const UINT_256_LOW_MAX = 340282366920938463463374607431768211455n;\nexport const UINT_256_HIGH_MAX = 340282366920938463463374607431768211455n;\nexport const UINT_256_LOW_MIN = 0n;\nexport const UINT_256_HIGH_MIN = 0n;\n\nexport class CairoUint256 {\n  public low: bigint;\n\n  public high: bigint;\n\n  static abiSelector = 'core::integer::u256';\n\n  /**\n   * Default constructor (Lib usage)\n   * @param bigNumberish BigNumberish value representing uin256\n   */\n  public constructor(bigNumberish: BigNumberish);\n  /**\n   * Direct props initialization (Api response)\n   */\n  public constructor(low: BigNumberish, high: BigNumberish);\n  /**\n   * Initialization from Uint256 object\n   */\n  public constructor(uint256: Uint256);\n\n  public constructor(...arr: any[]) {\n    if (typeof arr[0] === 'object' && arr.length === 1 && 'low' in arr[0] && 'high' in arr[0]) {\n      const props = CairoUint256.validateProps(arr[0].low, arr[0].high);\n      this.low = props.low;\n      this.high = props.high;\n    } else if (arr.length === 1) {\n      const bigInt = CairoUint256.validate(arr[0]);\n      this.low = bigInt & UINT_128_MAX;\n      this.high = bigInt >> 128n;\n    } else if (arr.length === 2) {\n      const props = CairoUint256.validateProps(arr[0], arr[1]);\n      this.low = props.low;\n      this.high = props.high;\n    } else {\n      throw Error('Incorrect constructor parameters');\n    }\n  }\n\n  /**\n   * Validate if BigNumberish can be represented as Unit256\n   */\n  static validate(bigNumberish: BigNumberish) {\n    const bigInt = BigInt(bigNumberish);\n    if (bigInt < UINT_256_MIN) throw Error('bigNumberish is smaller than UINT_256_MIN');\n    if (bigInt > UINT_256_MAX) throw new Error('bigNumberish is bigger than UINT_256_MAX');\n    return bigInt;\n  }\n\n  /**\n   * Validate if low and high can be represented as Unit256\n   */\n  static validateProps(low: BigNumberish, high: BigNumberish) {\n    const bigIntLow = BigInt(low);\n    const bigIntHigh = BigInt(high);\n    if (bigIntLow < UINT_256_LOW_MIN || bigIntLow > UINT_256_LOW_MAX) {\n      throw new Error('low is out of range UINT_256_LOW_MIN - UINT_256_LOW_MAX');\n    }\n    if (bigIntHigh < UINT_256_HIGH_MIN || bigIntHigh > UINT_256_HIGH_MAX) {\n      throw new Error('high is out of range UINT_256_HIGH_MIN - UINT_256_HIGH_MAX');\n    }\n    return { low: bigIntLow, high: bigIntHigh };\n  }\n\n  /**\n   * Check if BigNumberish can be represented as Unit256\n   */\n  static is(bigNumberish: BigNumberish) {\n    try {\n      CairoUint256.validate(bigNumberish);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string) {\n    return abiType === CairoUint256.abiSelector;\n  }\n\n  /**\n   * Return bigint representation\n   */\n  toBigInt() {\n    return (this.high << 128n) + this.low;\n  }\n\n  /**\n   * Return Uint256 structure with HexString props\n   * {low: HexString, high: HexString}\n   */\n  toUint256HexString() {\n    return {\n      low: addHexPrefix(this.low.toString(16)),\n      high: addHexPrefix(this.high.toString(16)),\n    };\n  }\n\n  /**\n   * Return Uint256 structure with DecimalString props\n   * {low: DecString, high: DecString}\n   */\n  toUint256DecimalString() {\n    return {\n      low: this.low.toString(10),\n      high: this.high.toString(10),\n    };\n  }\n\n  /**\n   * Return api requests representation witch is felt array\n   */\n  toApiRequest() {\n    return [CairoFelt(this.low), CairoFelt(this.high)];\n  }\n}\n","/* eslint-disable no-bitwise */\n/**\n * Singular class handling cairo u512 data type\n */\n\nimport { BigNumberish, type Uint512 } from '../../types';\nimport { addHexPrefix } from '../encode';\nimport { CairoFelt } from './felt';\nimport { UINT_128_MAX } from './uint256';\n\nexport const UINT_512_MAX = (1n << 512n) - 1n;\nexport const UINT_512_MIN = 0n;\nexport const UINT_128_MIN = 0n;\n\nexport class CairoUint512 {\n  public limb0: bigint;\n\n  public limb1: bigint;\n\n  public limb2: bigint;\n\n  public limb3: bigint;\n\n  static abiSelector = 'core::integer::u512';\n\n  /**\n   * Default constructor (Lib usage)\n   * @param bigNumberish BigNumberish value representing u512\n   */\n  public constructor(bigNumberish: BigNumberish);\n  /**\n   * Direct props initialization (Api response)\n   */\n  public constructor(\n    limb0: BigNumberish,\n    limb1: BigNumberish,\n    limb2: BigNumberish,\n    limb3: BigNumberish\n  );\n  /**\n   * Initialization from Uint512 object\n   */\n  public constructor(uint512: Uint512);\n\n  public constructor(...arr: any[]) {\n    if (\n      typeof arr[0] === 'object' &&\n      arr.length === 1 &&\n      'limb0' in arr[0] &&\n      'limb1' in arr[0] &&\n      'limb2' in arr[0] &&\n      'limb3' in arr[0]\n    ) {\n      const props = CairoUint512.validateProps(\n        arr[0].limb0,\n        arr[0].limb1,\n        arr[0].limb2,\n        arr[0].limb3\n      );\n      this.limb0 = props.limb0;\n      this.limb1 = props.limb1;\n      this.limb2 = props.limb2;\n      this.limb3 = props.limb3;\n    } else if (arr.length === 1) {\n      const bigInt = CairoUint512.validate(arr[0]);\n      this.limb0 = bigInt & UINT_128_MAX;\n      this.limb1 = (bigInt & (UINT_128_MAX << 128n)) >> 128n;\n      this.limb2 = (bigInt & (UINT_128_MAX << 256n)) >> 256n;\n      this.limb3 = bigInt >> 384n;\n    } else if (arr.length === 4) {\n      const props = CairoUint512.validateProps(arr[0], arr[1], arr[2], arr[3]);\n      this.limb0 = props.limb0;\n      this.limb1 = props.limb1;\n      this.limb2 = props.limb2;\n      this.limb3 = props.limb3;\n    } else {\n      throw Error('Incorrect Uint512 constructor parameters');\n    }\n  }\n\n  /**\n   * Validate if BigNumberish can be represented as Uint512\n   */\n  static validate(bigNumberish: BigNumberish): bigint {\n    const bigInt = BigInt(bigNumberish);\n    if (bigInt < UINT_512_MIN) throw Error('bigNumberish is smaller than UINT_512_MIN.');\n    if (bigInt > UINT_512_MAX) throw Error('bigNumberish is bigger than UINT_512_MAX.');\n    return bigInt;\n  }\n\n  /**\n   * Validate if limbs can be represented as Uint512\n   */\n  static validateProps(\n    limb0: BigNumberish,\n    limb1: BigNumberish,\n    limb2: BigNumberish,\n    limb3: BigNumberish\n  ): { limb0: bigint; limb1: bigint; limb2: bigint; limb3: bigint } {\n    const l0 = BigInt(limb0);\n    const l1 = BigInt(limb1);\n    const l2 = BigInt(limb2);\n    const l3 = BigInt(limb3);\n    [l0, l1, l2, l3].forEach((value: bigint, index) => {\n      if (value < UINT_128_MIN || value > UINT_128_MAX) {\n        throw Error(`limb${index} is not in the range of a u128 number`);\n      }\n    });\n    return { limb0: l0, limb1: l1, limb2: l2, limb3: l3 };\n  }\n\n  /**\n   * Check if BigNumberish can be represented as Uint512\n   */\n  static is(bigNumberish: BigNumberish): boolean {\n    try {\n      CairoUint512.validate(bigNumberish);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string): boolean {\n    return abiType === CairoUint512.abiSelector;\n  }\n\n  /**\n   * Return bigint representation\n   */\n  toBigInt(): bigint {\n    return (this.limb3 << 384n) + (this.limb2 << 256n) + (this.limb1 << 128n) + this.limb0;\n  }\n\n  /**\n   * Return Uint512 structure with HexString props\n   * limbx: HexString\n   */\n  toUint512HexString() {\n    return {\n      limb0: addHexPrefix(this.limb0.toString(16)),\n      limb1: addHexPrefix(this.limb1.toString(16)),\n      limb2: addHexPrefix(this.limb2.toString(16)),\n      limb3: addHexPrefix(this.limb3.toString(16)),\n    };\n  }\n\n  /**\n   * Return Uint512 structure with DecimalString props\n   * limbx DecString\n   */\n  toUint512DecimalString() {\n    return {\n      limb0: this.limb0.toString(10),\n      limb1: this.limb1.toString(10),\n      limb2: this.limb2.toString(10),\n      limb3: this.limb3.toString(10),\n    };\n  }\n\n  /**\n   * Return api requests representation witch is felt array\n   */\n  toApiRequest(): string[] {\n    // lower limb first : https://github.com/starkware-libs/cairo/blob/07484c52791b76abcc18fd86265756904557d0d2/corelib/src/test/integer_test.cairo#L767\n    return [\n      CairoFelt(this.limb0),\n      CairoFelt(this.limb1),\n      CairoFelt(this.limb2),\n      CairoFelt(this.limb3),\n    ];\n  }\n}\n","import { isUndefined } from '../../typed';\n\nexport type CairoEnumRaw = Record<string, any>;\n\n/**\n * Class to handle Cairo custom Enum\n * @param enumContent object containing the variants and its content. Example :\n *  {Success: 234, Warning: undefined, Error: undefined}.\n *  Only one variant with a value, object, array.\n * @returns an instance representing a Cairo custom Enum.\n * @example\n * ```typescript\n * const myCairoEnum = new CairoCustomEnum( {Success: undefined, Warning: \"0x7f32ea\", Error: undefined})\n * ```\n */\nexport class CairoCustomEnum {\n  /**\n   * direct readonly access to variants of the Cairo Custom Enum.\n   * @returns a value of type any\n   * @example\n   * ```typescript\n   * const successValue = myCairoEnum.variant.Success;\n   */\n  readonly variant: CairoEnumRaw;\n\n  /**\n   * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.\n   */\n  constructor(enumContent: CairoEnumRaw) {\n    const variantsList = Object.values(enumContent);\n    if (variantsList.length === 0) {\n      throw new Error('This Enum must have at least 1 variant');\n    }\n    const nbActiveVariants = variantsList.filter((content) => !isUndefined(content)).length;\n    if (nbActiveVariants !== 1) {\n      throw new Error('This Enum must have exactly one active variant');\n    }\n    this.variant = enumContent;\n  }\n\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   */\n  public unwrap(): any {\n    const variants = Object.values(this.variant);\n    return variants.find((item) => !isUndefined(item));\n  }\n\n  /**\n   *\n   * @returns the name of the valid variant of a Cairo custom Enum.\n   */\n  public activeVariant(): string {\n    const variants = Object.entries(this.variant);\n    const activeVariant = variants.find((item) => !isUndefined(item[1]));\n    return isUndefined(activeVariant) ? '' : activeVariant[0];\n  }\n}\n","import { ValuesType } from '../../../types/helpers/valuesType';\nimport { isUndefined } from '../../typed';\n\nexport const CairoOptionVariant = {\n  Some: 0,\n  None: 1,\n} as const;\n\nexport type CairoOptionVariant = ValuesType<typeof CairoOptionVariant>;\n\n/**\n * Class to handle Cairo Option\n * @param variant CairoOptionVariant.Some or CairoOptionVariant.None\n * @param content value of type T.\n * @returns an instance representing a Cairo Option.\n * @example\n * ```typescript\n * const myOption = new CairoOption<BigNumberish>(CairoOptionVariant.Some, \"0x54dda8\");\n * ```\n */\nexport class CairoOption<T> {\n  readonly Some?: T;\n\n  readonly None?: boolean;\n\n  constructor(variant: CairoOptionVariant | number, content?: T) {\n    if (!(variant in Object.values(CairoOptionVariant))) {\n      throw new Error('Wrong variant! It should be CairoOptionVariant.Some or .None.');\n    }\n    if (variant === CairoOptionVariant.Some) {\n      if (isUndefined(content)) {\n        throw new Error(\n          'The creation of a Cairo Option with \"Some\" variant needs a content as input.'\n        );\n      }\n      this.Some = content;\n      this.None = undefined;\n    } else {\n      this.Some = undefined;\n      this.None = true;\n    }\n  }\n\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   *  If None, returns 'undefined'.\n   */\n  public unwrap(): T | undefined {\n    return this.None ? undefined : this.Some;\n  }\n\n  /**\n   *\n   * @returns true if the valid variant is 'isSome'.\n   */\n  public isSome(): boolean {\n    return !isUndefined(this.Some);\n  }\n\n  /**\n   *\n   * @returns true if the valid variant is 'isNone'.\n   */\n  public isNone(): boolean {\n    return this.None === true;\n  }\n}\n","import { ValuesType } from '../../../types/helpers/valuesType';\nimport { isUndefined } from '../../typed';\n\nexport const CairoResultVariant = {\n  Ok: 0,\n  Err: 1,\n} as const;\n\nexport type CairoResultVariant = ValuesType<typeof CairoResultVariant>;\n\n/**\n * Class to handle Cairo Result\n * @param variant CairoResultVariant.Ok or CairoResultVariant.Err\n * @param resultContent value of type T or U.\n * @returns an instance representing a Cairo Result.\n * @example\n * ```typescript\n * const myOption = new CairoResult<BigNumberish, CustomError>(CairoResultVariant.Ok, \"0x54dda8\");\n * ```\n */\nexport class CairoResult<T, U> {\n  readonly Ok?: T;\n\n  readonly Err?: U;\n\n  constructor(variant: CairoResultVariant | number, resultContent: T | U) {\n    if (!(variant in Object.values(CairoResultVariant))) {\n      throw new Error('Wrong variant! It should be CairoResultVariant.Ok or .Err.');\n    }\n    if (variant === CairoResultVariant.Ok) {\n      this.Ok = resultContent as T;\n      this.Err = undefined;\n    } else {\n      this.Ok = undefined;\n      this.Err = resultContent as U;\n    }\n  }\n\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo Result.\n   */\n  public unwrap(): T | U {\n    if (!isUndefined(this.Ok)) {\n      return this.Ok;\n    }\n    if (!isUndefined(this.Err)) {\n      return this.Err;\n    }\n    throw new Error('Both Result.Ok and .Err are undefined. Not authorized.');\n  }\n\n  /**\n   *\n   * @returns true if the valid variant is 'Ok'.\n   */\n  public isOk(): boolean {\n    return !isUndefined(this.Ok);\n  }\n\n  /**\n   *\n   * @returns true if the valid variant is 'isErr'.\n   */\n  public isErr(): boolean {\n    return !isUndefined(this.Err);\n  }\n}\n","import { isBigInt, isObject } from '../typed';\nimport { decodeShortString } from '../shortString';\n\nconst guard = {\n  /**\n   * Checks if the data is a BigInt (BN) and throws an error if not.\n   *\n   * @param {Record<string, any>} data - The data object containing the key to check.\n   * @param {Record<string, any>} type - The type definition object.\n   * @param {string} key - The key in the data object to check.\n   * @throws {Error} If the data type does not match the expected BigInt (BN) type.\n   */\n  isBN: (data: Record<string, any>, type: Record<string, any>, key: string) => {\n    if (!isBigInt(data[key]))\n      throw new Error(\n        `Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${\n          data[key]\n        } to be BN instead it is ${typeof data[key]}`\n      );\n  },\n  /**\n   * Throws an error for unhandled formatter types.\n   *\n   * @param {Record<string, any>} data - The data object containing the key.\n   * @param {Record<string, any>} type - The type definition object.\n   * @param {string} key - The key in the data object to check.\n   * @throws {Error} If the formatter encounters an unknown type.\n   */\n  unknown: (data: Record<string, any>, type: Record<string, any>, key: string) => {\n    throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);\n  },\n};\n\n/**\n * Formats the given data based on the provided type definition.\n *\n * @param {Record<string, any>} data - The data to be formatted.\n * @param {Record<string, any>} type - The type definition for the data.\n * @param {any} [sameType] - The same type definition to be used (optional).\n * @returns {Record<string, any>} The formatted data.\n *\n * @example\n * // Example 1: Formatting a simple object\n * const data = { value: 1n, name: 2n };\n * const type = { value: 'number', name: 'string' };\n * const formatted = formatter(data, type);\n * // formatted: { value: 1n, name: '2n' }\n *\n * @example\n * // Example 2: Formatting an object with nested structures\n * const data = { test: { id: 1n, value: 30n }, active: 1n };\n * const type = { test: { id: 'number', value: 'number' }, active: 'number' };\n * const formatted = formatter(data, type);\n * // formatted: { test: { id: 1n, value: 30n }, active: 1n }\n *\n * @example\n * // Example 3: Handling arrays in the data object\n * const data = { items: [1n, 2n, 3n], value: 4n };\n * const type = { items: ['number'], value: 'string' };\n * const formatted = formatter(data, type);\n * // formatted: { items: [1n, 2n, 3n], value: '4n' }\n */\nexport default function formatter(\n  data: Record<string, any>,\n  type: Record<string, any>,\n  sameType?: any\n): Record<string, any> {\n  // match data element with type element\n  return Object.entries(data).reduce(\n    (acc, [key, value]: [any, any]) => {\n      const elType = sameType ?? type[key];\n\n      if (!(key in type) && !sameType) {\n        // no type definition for element return original element\n        acc[key] = value;\n        return acc;\n      }\n\n      if (elType === 'string') {\n        if (Array.isArray(data[key])) {\n          // long string (felt*)\n          const arrayStr = formatter(\n            data[key],\n            data[key].map((_: any) => elType)\n          );\n          acc[key] = Object.values(arrayStr).join('');\n          return acc;\n        }\n        guard.isBN(data, type, key);\n        acc[key] = decodeShortString(value);\n        return acc;\n      }\n      if (elType === 'number') {\n        guard.isBN(data, type, key);\n        acc[key] = Number(value);\n        return acc;\n      }\n      if (typeof elType === 'function') {\n        acc[key] = elType(value);\n        return acc;\n      }\n      if (Array.isArray(elType)) {\n        const arrayObj = formatter(data[key], elType, elType[0]);\n        acc[key] = Object.values(arrayObj);\n        return acc;\n      }\n      if (isObject(elType)) {\n        acc[key] = formatter(data[key], elType);\n        return acc;\n      }\n\n      guard.unknown(data, type, key);\n      return acc;\n    },\n    {} as Record<string, any>\n  );\n}\n","import { Abi, FunctionAbi } from '../../../types';\nimport { isLen } from '../cairo';\nimport { AbiParserInterface } from './interface';\n\nexport class AbiParser1 implements AbiParserInterface {\n  abi: Abi;\n\n  constructor(abi: Abi) {\n    this.abi = abi;\n  }\n\n  /**\n   * abi method inputs length without '_len' inputs\n   * cairo 0 reducer\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */\n  public methodInputsLength(abiMethod: FunctionAbi) {\n    return abiMethod.inputs.reduce((acc, input) => (!isLen(input.name) ? acc + 1 : acc), 0);\n  }\n\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  public getMethod(name: string): FunctionAbi | undefined {\n    return this.abi.find((it) => it.name === name);\n  }\n\n  /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */\n  public getLegacyFormat() {\n    return this.abi;\n  }\n}\n","import {\n  Abi,\n  FunctionAbi,\n  AbiEvent,\n  AbiStruct,\n  InterfaceAbi,\n  type LegacyEvent,\n} from '../../../types';\nimport { AbiParserInterface } from './interface';\n\nexport class AbiParser2 implements AbiParserInterface {\n  abi: Abi;\n\n  constructor(abi: Abi) {\n    this.abi = abi;\n  }\n\n  /**\n   * abi method inputs length\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */\n  public methodInputsLength(abiMethod: FunctionAbi) {\n    return abiMethod.inputs.length;\n  }\n\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  public getMethod(name: string): FunctionAbi | undefined {\n    const intf = this.abi.find(\n      (it: FunctionAbi | AbiEvent | AbiStruct | InterfaceAbi) => it.type === 'interface'\n    ) as InterfaceAbi;\n    return intf?.items?.find((it) => it.name === name);\n  }\n\n  /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */\n  public getLegacyFormat(): Abi {\n    return this.abi.flatMap((it: FunctionAbi | LegacyEvent | AbiStruct | InterfaceAbi) => {\n      return it.type === 'interface' ? it.items : it;\n    });\n  }\n}\n","import { Abi, FunctionAbi, RawArgs } from '../../../types';\nimport { isCairo1Abi } from '../cairo';\nimport { AbiParserInterface } from './interface';\nimport { AbiParser1 } from './parser-0-1.1.0';\nimport { AbiParser2 } from './parser-2.0.0';\n\n/**\n * Creates ABI parser\n *\n * @param {Abi} abi\n * @returns {AbiParserInterface} abi parser interface\n *\n * @example\n * const abiParser2 = createAbiParser([getInterfaceAbi('struct')]);\n * // abiParser2 instanceof AbiParser2 === true\n *\n * const abiParser1 = createAbiParser([getFunctionAbi('struct')]);\n * // abiParser1 instanceof AbiParser1 === true\n */\nexport function createAbiParser(abi: Abi): AbiParserInterface {\n  const version = getAbiVersion(abi);\n  if (version === 0 || version === 1) {\n    return new AbiParser1(abi);\n  }\n  if (version === 2) {\n    return new AbiParser2(abi);\n  }\n  throw Error(`Unsupported ABI version ${version}`);\n}\n\n/**\n * Retrieves ABI version\n *\n * @param {Abi} abi\n * @returns {1 | 2 | 0} abi 1, 2 or 0 version\n *\n * @example\n * // Example 1: Return ABI version 2\n * const version = getAbiVersion([getInterfaceAbi()]);\n * // version === 2\n *\n * // Example 2: Return ABI version 1\n * const version = getAbiVersion([getInterfaceAbi('core::bool')]);\n * // version === 1\n *\n * // Example 3: Return ABI version 0\n * const version = getAbiVersion([getInterfaceAbi('felt')]);\n * // version === 0\n */\nexport function getAbiVersion(abi: Abi): 1 | 2 | 0 {\n  if (abi.find((it) => it.type === 'interface')) return 2;\n  if (isCairo1Abi(abi)) return 1;\n  return 0;\n}\n\n/**\n * Checks if no constructor valid\n *\n * @param {string} method\n * @param {RawArgs} argsCalldata\n * @param {FunctionAbi} abiMethod\n * @returns boolean\n *\n * @example\n * const result1 = isNoConstructorValid('constructor', [])\n * // result1 === true\n * const result2 = isNoConstructorValid('test', ['test'])\n * // result2 === false\n */\nexport function isNoConstructorValid(\n  method: string,\n  argsCalldata: RawArgs,\n  abiMethod?: FunctionAbi\n): boolean {\n  // No constructor in abi and validly empty args\n  return method === 'constructor' && !abiMethod && !argsCalldata.length;\n}\n","/* eslint-disable no-plusplus */\nimport { isCairo1Type, isTypeNamedTuple } from './cairo';\n\nfunction parseNamedTuple(namedTuple: string): any {\n  const name = namedTuple.substring(0, namedTuple.indexOf(':'));\n  const type = namedTuple.substring(name.length + ':'.length);\n  return { name, type };\n}\n\nfunction parseSubTuple(s: string) {\n  if (!s.includes('(')) return { subTuple: [], result: s };\n  const subTuple: string[] = [];\n  let result = '';\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === '(') {\n      let counter = 1;\n      const lBracket = i;\n      i++;\n      while (counter) {\n        if (s[i] === ')') counter--;\n        if (s[i] === '(') counter++;\n        i++;\n      }\n      subTuple.push(s.substring(lBracket, i));\n      result += ' ';\n      i--;\n    } else {\n      result += s[i];\n    }\n    i++;\n  }\n\n  return {\n    subTuple,\n    result,\n  };\n}\n\nfunction extractCairo0Tuple(type: string) {\n  const cleanType = type.replace(/\\s/g, '').slice(1, -1); // remove first lvl () and spaces\n\n  // Decompose subTuple\n  const { subTuple, result } = parseSubTuple(cleanType);\n\n  // Recompose subTuple\n  let recomposed = result.split(',').map((it) => {\n    return subTuple.length ? it.replace(' ', subTuple.shift() as string) : it;\n  });\n\n  // Parse named tuple\n  if (isTypeNamedTuple(type)) {\n    recomposed = recomposed.reduce((acc, it) => {\n      return acc.concat(parseNamedTuple(it));\n    }, []);\n  }\n\n  return recomposed;\n}\n\nfunction getClosureOffset(input: string, open: string, close: string): number {\n  for (let i = 0, counter = 0; i < input.length; i++) {\n    if (input[i] === open) {\n      counter++;\n    } else if (input[i] === close && --counter === 0) {\n      return i;\n    }\n  }\n  return Number.POSITIVE_INFINITY;\n}\n\nfunction extractCairo1Tuple(type: string): string[] {\n  // un-named tuples support\n  const input = type.slice(1, -1); // remove first lvl ()\n  const result: string[] = [];\n\n  let currentIndex: number = 0;\n  let limitIndex: number;\n\n  while (currentIndex < input.length) {\n    switch (true) {\n      // Tuple\n      case input[currentIndex] === '(': {\n        limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), '(', ')') + 1;\n        break;\n      }\n      case input.startsWith('core::result::Result::<', currentIndex) ||\n        input.startsWith('core::array::Array::<', currentIndex) ||\n        input.startsWith('core::option::Option::<', currentIndex): {\n        limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), '<', '>') + 1;\n        break;\n      }\n      default: {\n        const commaIndex = input.indexOf(',', currentIndex);\n        limitIndex = commaIndex !== -1 ? commaIndex : Number.POSITIVE_INFINITY;\n      }\n    }\n\n    result.push(input.slice(currentIndex, limitIndex));\n    currentIndex = limitIndex + 2; // +2 to skip ', '\n  }\n\n  return result;\n}\n\n/**\n * Convert a tuple string definition into an object-like definition.\n * Supports both Cairo 0 and Cairo 1 tuple formats.\n *\n * @param type - The tuple string definition (e.g., \"(u8, u8)\" or \"(x:u8, y:u8)\").\n * @returns An array of strings or objects representing the tuple components.\n *\n * @example\n * // Cairo 0 Tuple\n * const cairo0Tuple = \"(u8, u8)\";\n * const result = extractTupleMemberTypes(cairo0Tuple);\n * // result: [\"u8\", \"u8\"]\n *\n * @example\n * // Named Cairo 0 Tuple\n * const namedCairo0Tuple = \"(x:u8, y:u8)\";\n * const namedResult = extractTupleMemberTypes(namedCairo0Tuple);\n * // namedResult: [{ name: \"x\", type: \"u8\" }, { name: \"y\", type: \"u8\" }]\n *\n * @example\n * // Cairo 1 Tuple\n * const cairo1Tuple = \"(core::result::Result::<u8, u8>, u8)\";\n * const cairo1Result = extractTupleMemberTypes(cairo1Tuple);\n * // cairo1Result: [\"core::result::Result::<u8, u8>\", \"u8\"]\n */\nexport default function extractTupleMemberTypes(type: string): (string | object)[] {\n  return isCairo1Type(type) ? extractCairo1Tuple(type) : extractCairo0Tuple(type);\n}\n","import assert from '../assert';\n\nexport class CairoFixedArray {\n  /**\n   * JS array representing a Cairo fixed array.\n   */\n  public readonly content: any[];\n\n  /**\n   * Cairo fixed array type.\n   */\n  public readonly arrayType: string;\n\n  /**\n   * Create an instance representing a Cairo fixed Array.\n   * @param {any[]} content JS array representing a Cairo fixed array.\n   * @param {string} arrayType Cairo fixed array type.\n   */\n  constructor(content: any[], arrayType: string) {\n    assert(\n      CairoFixedArray.isTypeFixedArray(arrayType),\n      `The type ${arrayType} is not a Cairo fixed array. Needs [type; length].`\n    );\n    try {\n      CairoFixedArray.getFixedArrayType(arrayType);\n    } catch {\n      throw new Error(\n        `The type ${arrayType} do not includes any content type. Needs [type; length].`\n      );\n    }\n    try {\n      CairoFixedArray.getFixedArraySize(arrayType);\n    } catch {\n      throw new Error(\n        `The type ${arrayType} type do not includes any length. Needs [type; length].`\n      );\n    }\n    assert(\n      CairoFixedArray.getFixedArraySize(arrayType) === content.length,\n      `The ABI type ${arrayType} is expecting ${CairoFixedArray.getFixedArraySize(arrayType)} items. ${content.length} items provided.`\n    );\n    this.content = content;\n    this.arrayType = arrayType;\n  }\n\n  /**\n   * Retrieves the array size from the given type string representing a Cairo fixed array.\n   * @param {string} type - The Cairo fixed array type.\n   * @returns {number} The array size.\n   * @example\n   * ```typescript\n   * const result = CairoFixedArray.getFixedArraySize(\"[core::integer::u32; 8]\");\n   * // result = 8\n   * ```\n   */\n  static getFixedArraySize(type: string) {\n    const matchArray = type.match(/(?<=; )\\d+(?=\\])/);\n    if (matchArray === null)\n      throw new Error(`ABI type ${type} do not includes a valid number after ';' character.`);\n    return Number(matchArray[0]);\n  }\n\n  /**\n   * Retrieves the Cairo fixed array size from the CairoFixedArray instance.\n   * @returns {number} The fixed array size.\n   * @example\n   * ```typescript\n   * const fArray = new CairoFixedArray([10,20,30], \"[core::integer::u32; 3]\");\n   * const result = fArray.getFixedArraySize();\n   * // result = 3\n   * ```\n   */\n  getFixedArraySize() {\n    return CairoFixedArray.getFixedArraySize(this.arrayType);\n  }\n\n  /**\n   * Retrieve the Cairo content type from a Cairo fixed array type.\n   * @param {string} type - The type string.\n   * @returns {string} The fixed-array type.\n   * @example\n   * ```typescript\n   * const result = CairoFixedArray.getFixedArrayType(\"[core::integer::u32; 8]\");\n   * // result = \"core::integer::u32\"\n   * ```\n   */\n  static getFixedArrayType = (type: string) => {\n    const matchArray = type.match(/(?<=\\[).+(?=;)/);\n    if (matchArray === null)\n      throw new Error(`ABI type ${type} do not includes a valid type of data.`);\n    return matchArray[0];\n  };\n\n  /**\n   * Retrieve the Cairo content type of the Cairo fixed array.\n   * @returns {string} The fixed-array content type.\n   * @example\n   * ```typescript\n   * const fArray = new CairoFixedArray([10,20,30], \"[core::integer::u32; 3]\");\n   * const result = fArray.getFixedArrayType();\n   * // result = \"core::integer::u32\"\n   * ```\n   */\n  getFixedArrayType() {\n    return CairoFixedArray.getFixedArrayType(this.arrayType);\n  }\n\n  /**\n   * Create an object from a Cairo fixed array.\n   * Be sure to have an array length conform to the ABI.\n   * To be used with CallData.compile().\n   * @param {Array<any>} input JS array representing a Cairo fixed array.\n   * @returns {Object} a specific struct representing a fixed Array.\n   * @example\n   * ```typescript\n   * const result = CairoFixedArray.compile([10,20,30]);\n   * // result = { '0': 10, '1': 20, '2': 30 }\n   * ```\n   */\n  static compile(input: Array<any>): Object {\n    return input.reduce((acc: any, item: any, idx: number) => {\n      acc[idx] = item;\n      return acc;\n    }, {});\n  }\n\n  /**\n   * Generate an object from the Cairo fixed array instance.\n   * To be used with CallData.compile().\n   * @returns a specific struct representing a fixed array.\n   * @example\n   * ```typescript\n   * const fArray = new CairoFixedArray([10,20,30], \"[core::integer::u32; 3]\");\n   * const result = fArray.compile();\n   * // result = { '0': 10, '1': 20, '2': 30 }\n   * ```\n   */\n  public compile(): Object {\n    return CairoFixedArray.compile(this.content);\n  }\n\n  /**\n   * Checks if the given Cairo type is a fixed-array type.\n   *\n   * @param {string} type - The type to check.\n   * @returns - `true` if the type is a fixed array type, `false` otherwise.\n   * ```typescript\n   * const result = CairoFixedArray.isTypeFixedArray(\"[core::integer::u32; 8]\");\n   * // result = true\n   */\n  static isTypeFixedArray(type: string) {\n    return (\n      /^\\[.*;\\s.*\\]$/.test(type) && /(?<=\\[).+(?=;)/.test(type) && /(?<=; )\\d+(?=\\])/.test(type)\n    );\n  }\n}\n","import { AbiEntry, AbiEnums, AbiStructs, CairoEnum, RawArgsObject } from '../../types';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport { CairoUint512 } from '../cairoDataTypes/uint512';\nimport {\n  getArrayType,\n  isCairo1Type,\n  isLen,\n  isTypeArray,\n  isTypeByteArray,\n  isTypeEnum,\n  isTypeEthAddress,\n  isTypeNonZero,\n  isTypeOption,\n  isTypeResult,\n  isTypeSecp256k1Point,\n  isTypeStruct,\n  isTypeTuple,\n  isTypeU96,\n} from './cairo';\nimport {\n  CairoCustomEnum,\n  CairoOption,\n  CairoOptionVariant,\n  CairoResult,\n  CairoResultVariant,\n} from './enum';\nimport extractTupleMemberTypes from './tuple';\nimport { isUndefined, isString } from '../typed';\nimport { CairoFixedArray } from '../cairoDataTypes/fixedArray';\n\nfunction errorU256(key: string) {\n  return Error(\n    `Your object includes the property : ${key}, containing an Uint256 object without the 'low' and 'high' keys.`\n  );\n}\n\nfunction errorU512(key: string) {\n  return Error(\n    `Your object includes the property : ${key}, containing an Uint512 object without the 'limb0' to 'limb3' keys.`\n  );\n}\n\nexport default function orderPropsByAbi(\n  unorderedObject: RawArgsObject,\n  abiOfObject: AbiEntry[],\n  structs: AbiStructs,\n  enums: AbiEnums\n): object {\n  const orderInput = (unorderedItem: any, abiType: string): any => {\n    if (CairoFixedArray.isTypeFixedArray(abiType)) {\n      return orderFixedArray(unorderedItem, abiType);\n    }\n    if (isTypeArray(abiType)) {\n      return orderArray(unorderedItem, abiType);\n    }\n    if (isTypeEnum(abiType, enums)) {\n      const abiObj = enums[abiType];\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return orderEnum(unorderedItem, abiObj);\n    }\n    if (isTypeTuple(abiType)) {\n      return orderTuple(unorderedItem, abiType);\n    }\n    if (isTypeEthAddress(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeNonZero(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeByteArray(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeU96(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeSecp256k1Point(abiType)) {\n      return unorderedItem;\n    }\n    if (CairoUint256.isAbiType(abiType)) {\n      const u256 = unorderedItem;\n      if (typeof u256 !== 'object') {\n        // BigNumberish --> just copy\n        return u256;\n      }\n      if (!('low' in u256 && 'high' in u256)) {\n        throw errorU256(abiType);\n      }\n      return { low: u256.low, high: u256.high };\n    }\n    if (CairoUint512.isAbiType(abiType)) {\n      const u512 = unorderedItem;\n      if (typeof u512 !== 'object') {\n        // BigNumberish --> just copy\n        return u512;\n      }\n      if (!['limb0', 'limb1', 'limb2', 'limb3'].every((key) => key in u512)) {\n        throw errorU512(abiType);\n      }\n      return { limb0: u512.limb0, limb1: u512.limb1, limb2: u512.limb2, limb3: u512.limb3 };\n    }\n    if (isTypeStruct(abiType, structs)) {\n      const abiOfStruct = structs[abiType].members;\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return orderStruct(unorderedItem, abiOfStruct);\n    }\n    // literals\n    return unorderedItem;\n  };\n\n  const orderStruct = (unorderedObject2: RawArgsObject, abiObject: AbiEntry[]): object => {\n    const orderedObject2 = abiObject.reduce((orderedObject, abiParam) => {\n      const setProperty = (value?: any) =>\n        Object.defineProperty(orderedObject, abiParam.name, {\n          enumerable: true,\n          value: value ?? unorderedObject2[abiParam.name],\n        });\n\n      if (unorderedObject2[abiParam.name] === 'undefined') {\n        if (isCairo1Type(abiParam.type) || !isLen(abiParam.name)) {\n          throw Error(`Your object needs a property with key : ${abiParam.name} .`);\n        }\n      }\n      setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));\n      return orderedObject;\n    }, {});\n    return orderedObject2;\n  };\n\n  function orderArray(myArray: Array<any> | string, abiParam: string): Array<any> | string {\n    const typeInArray = getArrayType(abiParam);\n    if (isString(myArray)) {\n      return myArray; // longstring\n    }\n    return myArray.map((myElem) => orderInput(myElem, typeInArray));\n  }\n\n  function orderFixedArray(input: Array<any> | Record<string, any>, abiParam: string): Array<any> {\n    const typeInFixedArray = CairoFixedArray.getFixedArrayType(abiParam);\n    const arraySize = CairoFixedArray.getFixedArraySize(abiParam);\n    if (Array.isArray(input)) {\n      if (arraySize !== input.length) {\n        throw new Error(\n          `ABI type ${abiParam}: array provided do not includes  ${arraySize} items. ${input.length} items provided.`\n        );\n      }\n      return input.map((myElem) => orderInput(myElem, typeInFixedArray));\n    }\n    if (arraySize !== Object.keys(input).length) {\n      throw new Error(\n        `ABI type ${abiParam}: object provided do not includes  ${arraySize} properties. ${Object.keys(input).length} items provided.`\n      );\n    }\n    return orderInput(input, typeInFixedArray);\n  }\n\n  function orderTuple(unorderedObject2: RawArgsObject, abiParam: string): object {\n    const typeList = extractTupleMemberTypes(abiParam);\n    const orderedObject2 = typeList.reduce((orderedObject: object, abiTypeCairoX: any, index) => {\n      const myObjKeys: string[] = Object.keys(unorderedObject2);\n      const setProperty = (value?: any) =>\n        Object.defineProperty(orderedObject, index.toString(), {\n          enumerable: true,\n          value: value ?? unorderedObject2[myObjKeys[index]],\n        });\n      const abiType: string = abiTypeCairoX?.type ? abiTypeCairoX.type : abiTypeCairoX; // Named tuple, or tuple\n      setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType));\n      return orderedObject;\n    }, {});\n    return orderedObject2;\n  }\n\n  const orderEnum = (unorderedObject2: CairoEnum, abiObject: AbiEntry): CairoEnum => {\n    if (isTypeResult(abiObject.name)) {\n      const unorderedResult = unorderedObject2 as CairoResult<any, any>;\n      const resultOkType: string = abiObject.name.substring(\n        abiObject.name.indexOf('<') + 1,\n        abiObject.name.lastIndexOf(',')\n      );\n      const resultErrType: string = abiObject.name.substring(\n        abiObject.name.indexOf(',') + 1,\n        abiObject.name.lastIndexOf('>')\n      );\n      if (unorderedResult.isOk()) {\n        return new CairoResult<any, any>(\n          CairoResultVariant.Ok,\n          orderInput(unorderedObject2.unwrap(), resultOkType)\n        );\n      }\n      return new CairoResult<any, any>(\n        CairoResultVariant.Err,\n        orderInput(unorderedObject2.unwrap(), resultErrType)\n      );\n    }\n    if (isTypeOption(abiObject.name)) {\n      const unorderedOption = unorderedObject2 as CairoOption<any>;\n      const resultSomeType: string = abiObject.name.substring(\n        abiObject.name.indexOf('<') + 1,\n        abiObject.name.lastIndexOf('>')\n      );\n      if (unorderedOption.isSome()) {\n        return new CairoOption<any>(\n          CairoOptionVariant.Some,\n          orderInput(unorderedOption.unwrap(), resultSomeType)\n        );\n      }\n      // none(())\n      return new CairoOption<any>(CairoOptionVariant.None, {});\n    }\n    // custom Enum\n    const unorderedCustomEnum = unorderedObject2 as CairoCustomEnum;\n    const variants = Object.entries(unorderedCustomEnum.variant);\n    const newEntries = variants.map((variant) => {\n      if (isUndefined(variant[1])) {\n        return variant;\n      }\n      const variantType: string = abiObject.type.substring(\n        abiObject.type.lastIndexOf('<') + 1,\n        abiObject.type.lastIndexOf('>')\n      );\n      if (variantType === '()') {\n        return variant;\n      }\n      return [variant[0], orderInput(unorderedCustomEnum.unwrap(), variantType)];\n    });\n    return new CairoCustomEnum(Object.fromEntries(newEntries));\n  };\n\n  // Order Call Parameters\n  const finalOrderedObject = abiOfObject.reduce((orderedObject, abiParam) => {\n    const setProperty = (value: any) =>\n      Object.defineProperty(orderedObject, abiParam.name, {\n        enumerable: true,\n        value,\n      });\n    if (isLen(abiParam.name) && !isCairo1Type(abiParam.type)) {\n      return orderedObject;\n    }\n    setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));\n    return orderedObject;\n  }, {});\n  return finalOrderedObject;\n}\n","import {\n  AbiEntry,\n  AbiEnums,\n  AbiStructs,\n  AllowArray,\n  BigNumberish,\n  ByteArray,\n  CairoEnum,\n  ParsedStruct,\n  Tupled,\n} from '../../types';\nimport assert from '../assert';\nimport { CairoFixedArray } from '../cairoDataTypes/fixedArray';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport { CairoUint512 } from '../cairoDataTypes/uint512';\nimport { addHexPrefix, removeHexPrefix } from '../encode';\nimport { toHex } from '../num';\nimport { encodeShortString, isText, splitLongString } from '../shortString';\nimport { isUndefined, isString } from '../typed';\nimport { byteArrayFromString } from './byteArray';\nimport {\n  felt,\n  getArrayType,\n  isTypeArray,\n  isTypeByteArray,\n  isTypeBytes31,\n  isTypeEnum,\n  isTypeEthAddress,\n  isTypeNonZero,\n  isTypeOption,\n  isTypeResult,\n  isTypeSecp256k1Point,\n  isTypeStruct,\n  isTypeTuple,\n  uint256,\n} from './cairo';\nimport {\n  CairoCustomEnum,\n  CairoOption,\n  CairoOptionVariant,\n  CairoResult,\n  CairoResultVariant,\n} from './enum';\nimport extractTupleMemberTypes from './tuple';\n\n/**\n * parse base types\n * @param type type from abi\n * @param val value provided\n * @returns string | string[]\n */\nfunction parseBaseTypes(type: string, val: BigNumberish): AllowArray<string> {\n  switch (true) {\n    case CairoUint256.isAbiType(type):\n      return new CairoUint256(val).toApiRequest();\n    case CairoUint512.isAbiType(type):\n      return new CairoUint512(val).toApiRequest();\n    case isTypeBytes31(type):\n      return encodeShortString(val.toString());\n    case isTypeSecp256k1Point(type): {\n      const pubKeyETH = removeHexPrefix(toHex(val)).padStart(128, '0');\n      const pubKeyETHy = uint256(addHexPrefix(pubKeyETH.slice(-64)));\n      const pubKeyETHx = uint256(addHexPrefix(pubKeyETH.slice(0, -64)));\n      return [\n        felt(pubKeyETHx.low),\n        felt(pubKeyETHx.high),\n        felt(pubKeyETHy.low),\n        felt(pubKeyETHy.high),\n      ];\n    }\n    default:\n      return felt(val);\n  }\n}\n\n/**\n * Parse tuple type string to array of known objects\n * @param element request element\n * @param typeStr tuple type string\n * @returns Tupled[]\n */\nfunction parseTuple(element: object, typeStr: string): Tupled[] {\n  const memberTypes = extractTupleMemberTypes(typeStr);\n  const elements = Object.values(element);\n\n  if (elements.length !== memberTypes.length) {\n    throw Error(\n      `ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${elements}\n      expected: ${memberTypes}`\n    );\n  }\n\n  return memberTypes.map((it: any, dx: number) => {\n    return {\n      element: elements[dx],\n      type: it.type ?? it,\n    };\n  });\n}\n\nfunction parseByteArray(element: string): string[] {\n  const myByteArray: ByteArray = byteArrayFromString(element);\n  return [\n    myByteArray.data.length.toString(),\n    ...myByteArray.data.map((bn) => bn.toString()),\n    myByteArray.pending_word.toString(),\n    myByteArray.pending_word_len.toString(),\n  ];\n}\n\n/**\n * Deep parse of the object that has been passed to the method\n *\n * @param element - element that needs to be parsed\n * @param type  - name of the method\n * @param structs - structs from abi\n * @param enums - enums from abi\n * @return {string | string[]} - parsed arguments in format that contract is expecting\n */\nfunction parseCalldataValue(\n  element:\n    | ParsedStruct\n    | BigNumberish\n    | BigNumberish[]\n    | CairoOption<any>\n    | CairoResult<any, any>\n    | CairoEnum,\n  type: string,\n  structs: AbiStructs,\n  enums: AbiEnums\n): string | string[] {\n  if (element === undefined) {\n    throw Error(`Missing parameter for type ${type}`);\n  }\n\n  // value is fixed array\n  if (CairoFixedArray.isTypeFixedArray(type)) {\n    const arrayType = CairoFixedArray.getFixedArrayType(type);\n    let values: any[] = [];\n    if (Array.isArray(element)) {\n      const array = new CairoFixedArray(element, type);\n      values = array.content;\n    } else if (typeof element === 'object') {\n      values = Object.values(element);\n      assert(\n        values.length === CairoFixedArray.getFixedArraySize(type),\n        `ABI type ${type}: object provided do not includes  ${CairoFixedArray.getFixedArraySize(type)} items. ${values.length} items provided.`\n      );\n    } else {\n      throw new Error(`ABI type ${type}: not an Array representing a cairo.fixedArray() provided.`);\n    }\n    return values.reduce((acc, it) => {\n      return acc.concat(parseCalldataValue(it, arrayType, structs, enums));\n    }, [] as string[]);\n  }\n\n  // value is Array\n  if (Array.isArray(element)) {\n    const result: string[] = [];\n    result.push(felt(element.length)); // Add length to array\n    const arrayType = getArrayType(type);\n\n    return element.reduce((acc, it) => {\n      return acc.concat(parseCalldataValue(it, arrayType, structs, enums));\n    }, result);\n  }\n\n  // checking if the passed element is struct\n  if (structs[type] && structs[type].members.length) {\n    if (CairoUint256.isAbiType(type)) {\n      return new CairoUint256(element as any).toApiRequest();\n    }\n    if (CairoUint512.isAbiType(type)) {\n      return new CairoUint512(element as any).toApiRequest();\n    }\n    if (isTypeEthAddress(type)) return parseBaseTypes(type, element as BigNumberish);\n\n    if (isTypeByteArray(type)) return parseByteArray(element as string);\n\n    const { members } = structs[type];\n    const subElement = element as any;\n\n    return members.reduce((acc, it: AbiEntry) => {\n      return acc.concat(parseCalldataValue(subElement[it.name], it.type, structs, enums));\n    }, [] as string[]);\n  }\n  // check if abi element is tuple\n  if (isTypeTuple(type)) {\n    const tupled = parseTuple(element as object, type);\n\n    return tupled.reduce((acc, it: Tupled) => {\n      const parsedData = parseCalldataValue(it.element, it.type, structs, enums);\n      return acc.concat(parsedData);\n    }, [] as string[]);\n  }\n  // check if u256 C1v0\n  if (CairoUint256.isAbiType(type)) {\n    return new CairoUint256(element as any).toApiRequest();\n  }\n  // check if u512\n  if (CairoUint512.isAbiType(type)) {\n    return new CairoUint512(element as any).toApiRequest();\n  }\n  // check if Enum\n  if (isTypeEnum(type, enums)) {\n    const { variants } = enums[type];\n    // Option Enum\n    if (isTypeOption(type)) {\n      const myOption = element as CairoOption<any>;\n      if (myOption.isSome()) {\n        const listTypeVariant = variants.find((variant) => variant.name === 'Some');\n        if (isUndefined(listTypeVariant)) {\n          throw Error(`Error in abi : Option has no 'Some' variant.`);\n        }\n        const typeVariantSome = listTypeVariant.type;\n        if (typeVariantSome === '()') {\n          return CairoOptionVariant.Some.toString();\n        }\n        const parsedParameter = parseCalldataValue(\n          myOption.unwrap(),\n          typeVariantSome,\n          structs,\n          enums\n        );\n        if (Array.isArray(parsedParameter)) {\n          return [CairoOptionVariant.Some.toString(), ...parsedParameter];\n        }\n        return [CairoOptionVariant.Some.toString(), parsedParameter];\n      }\n      return CairoOptionVariant.None.toString();\n    }\n    // Result Enum\n    if (isTypeResult(type)) {\n      const myResult = element as CairoResult<any, any>;\n      if (myResult.isOk()) {\n        const listTypeVariant = variants.find((variant) => variant.name === 'Ok');\n        if (isUndefined(listTypeVariant)) {\n          throw Error(`Error in abi : Result has no 'Ok' variant.`);\n        }\n        const typeVariantOk = listTypeVariant.type;\n        if (typeVariantOk === '()') {\n          return CairoResultVariant.Ok.toString();\n        }\n        const parsedParameter = parseCalldataValue(\n          myResult.unwrap(),\n          typeVariantOk,\n          structs,\n          enums\n        );\n        if (Array.isArray(parsedParameter)) {\n          return [CairoResultVariant.Ok.toString(), ...parsedParameter];\n        }\n        return [CairoResultVariant.Ok.toString(), parsedParameter];\n      }\n\n      // is Result::Err\n      const listTypeVariant = variants.find((variant) => variant.name === 'Err');\n      if (isUndefined(listTypeVariant)) {\n        throw Error(`Error in abi : Result has no 'Err' variant.`);\n      }\n      const typeVariantErr = listTypeVariant.type;\n      if (typeVariantErr === '()') {\n        return CairoResultVariant.Err.toString();\n      }\n      const parsedParameter = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);\n      if (Array.isArray(parsedParameter)) {\n        return [CairoResultVariant.Err.toString(), ...parsedParameter];\n      }\n      return [CairoResultVariant.Err.toString(), parsedParameter];\n    }\n    // Custom Enum\n    const myEnum = element as CairoCustomEnum;\n    const activeVariant: string = myEnum.activeVariant();\n    const listTypeVariant = variants.find((variant) => variant.name === activeVariant);\n    if (isUndefined(listTypeVariant)) {\n      throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);\n    }\n    const typeActiveVariant = listTypeVariant.type;\n    const numActiveVariant = variants.findIndex((variant) => variant.name === activeVariant); // can not fail due to check of listTypeVariant\n    if (typeActiveVariant === '()') {\n      return numActiveVariant.toString();\n    }\n    const parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);\n    if (Array.isArray(parsedParameter)) {\n      return [numActiveVariant.toString(), ...parsedParameter];\n    }\n    return [numActiveVariant.toString(), parsedParameter];\n  }\n\n  if (isTypeNonZero(type)) {\n    return parseBaseTypes(getArrayType(type), element as BigNumberish);\n  }\n\n  if (typeof element === 'object') {\n    throw Error(`Parameter ${element} do not align with abi parameter ${type}`);\n  }\n  return parseBaseTypes(type, element);\n}\n\n/**\n * Parse one field of the calldata by using input field from the abi for that method\n *\n * @param argsIterator - Iterator for value of the field\n * @param input  - input(field) information from the abi that will be used to parse the data\n * @param structs - structs from abi\n * @param enums - enums from abi\n * @return {string | string[]} - parsed arguments in format that contract is expecting\n *\n * @example\n * const abiEntry = { name: 'test', type: 'struct' };\n * const abiStructs: AbiStructs = {\n *  struct: {\n *    members: [\n *        {\n *          name: 'test_name',\n *          type: 'test_type',\n *          offset: 1,\n *        },\n *    ],\n *    size: 2,\n *    name: 'cairo__struct',\n *    type: 'struct',\n *   },\n * };\n *\n * const abiEnums: AbiEnums = {\n *   enum: {\n *     variants: [\n *       {\n *         name: 'test_name',\n *         type: 'cairo_struct_variant',\n *         offset: 1,\n *       },\n *     ],\n *     size: 2,\n *     name: 'test_cairo',\n *     type: 'enum',\n *   },\n * };\n *\n * const args = [{ test_name: 'test' }];\n * const argsIterator = args[Symbol.iterator]();\n * const parsedField = parseCalldataField(\n *   argsIterator,\n *   abiEntry,\n *   abiStructs,\n *   abiEnums\n * );\n * // parsedField === ['1952805748']\n */\nexport function parseCalldataField(\n  argsIterator: Iterator<any>,\n  input: AbiEntry,\n  structs: AbiStructs,\n  enums: AbiEnums\n): string | string[] {\n  const { name, type } = input;\n  let { value } = argsIterator.next();\n\n  switch (true) {\n    // Fixed array\n    case CairoFixedArray.isTypeFixedArray(type):\n      if (!Array.isArray(value) && !(typeof value === 'object')) {\n        throw Error(`ABI expected parameter ${name} to be an array or an object, got ${value}`);\n      }\n      return parseCalldataValue(value, input.type, structs, enums);\n    // Normal Array\n    case isTypeArray(type):\n      if (!Array.isArray(value) && !isText(value)) {\n        throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);\n      }\n      if (isString(value)) {\n        // long string match cairo felt*\n        value = splitLongString(value);\n      }\n      return parseCalldataValue(value, input.type, structs, enums);\n    case isTypeNonZero(type):\n      return parseBaseTypes(getArrayType(type), value);\n    case isTypeEthAddress(type):\n      return parseBaseTypes(type, value);\n    // Struct or Tuple\n    case isTypeStruct(type, structs) || isTypeTuple(type) || CairoUint256.isAbiType(type):\n      return parseCalldataValue(value as ParsedStruct | BigNumberish[], type, structs, enums);\n\n    // Enums\n    case isTypeEnum(type, enums):\n      return parseCalldataValue(\n        value as CairoOption<any> | CairoResult<any, any> | CairoEnum,\n        type,\n        structs,\n        enums\n      );\n\n    // Felt or unhandled\n    default:\n      return parseBaseTypes(type, value);\n  }\n}\n","/* eslint-disable no-case-declarations */\nimport {\n  AbiEntry,\n  AbiEnums,\n  AbiStructs,\n  Args,\n  BigNumberish,\n  ByteArray,\n  CairoEnum,\n  EventEntry,\n  ParsedStruct,\n} from '../../types';\nimport { CairoFixedArray } from '../cairoDataTypes/fixedArray';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport { CairoUint512 } from '../cairoDataTypes/uint512';\nimport { addHexPrefix, removeHexPrefix } from '../encode';\nimport { toHex } from '../num';\nimport { decodeShortString } from '../shortString';\nimport { stringFromByteArray } from './byteArray';\nimport {\n  getArrayType,\n  isCairo1Type,\n  isLen,\n  isTypeArray,\n  isTypeBool,\n  isTypeByteArray,\n  isTypeBytes31,\n  isTypeEnum,\n  isTypeEthAddress,\n  isTypeNonZero,\n  isTypeSecp256k1Point,\n  isTypeTuple,\n} from './cairo';\nimport {\n  CairoCustomEnum,\n  CairoEnumRaw,\n  CairoOption,\n  CairoOptionVariant,\n  CairoResult,\n  CairoResultVariant,\n} from './enum';\nimport extractTupleMemberTypes from './tuple';\n\n/**\n * Parse base types\n * @param type type of element\n * @param it iterator\n * @returns bigint | boolean\n */\nfunction parseBaseTypes(type: string, it: Iterator<string>) {\n  let temp;\n  switch (true) {\n    case isTypeBool(type):\n      temp = it.next().value;\n      return Boolean(BigInt(temp));\n    case CairoUint256.isAbiType(type):\n      const low = it.next().value;\n      const high = it.next().value;\n      return new CairoUint256(low, high).toBigInt();\n    case CairoUint512.isAbiType(type):\n      const limb0 = it.next().value;\n      const limb1 = it.next().value;\n      const limb2 = it.next().value;\n      const limb3 = it.next().value;\n      return new CairoUint512(limb0, limb1, limb2, limb3).toBigInt();\n    case isTypeEthAddress(type):\n      temp = it.next().value;\n      return BigInt(temp);\n    case isTypeBytes31(type):\n      temp = it.next().value;\n      return decodeShortString(temp);\n    case isTypeSecp256k1Point(type):\n      const xLow = removeHexPrefix(it.next().value).padStart(32, '0');\n      const xHigh = removeHexPrefix(it.next().value).padStart(32, '0');\n      const yLow = removeHexPrefix(it.next().value).padStart(32, '0');\n      const yHigh = removeHexPrefix(it.next().value).padStart(32, '0');\n      const pubK = BigInt(addHexPrefix(xHigh + xLow + yHigh + yLow));\n      return pubK;\n    default:\n      temp = it.next().value;\n      return BigInt(temp);\n  }\n}\n\n/**\n * Parse of the response elements that are converted to Object (Struct) by using the abi\n *\n * @param responseIterator - iterator of the response\n * @param element - element of the field {name: string, type: string}\n * @param structs - structs from abi\n * @param enums\n * @return {any} - parsed arguments in format that contract is expecting\n */\nfunction parseResponseValue(\n  responseIterator: Iterator<string>,\n  element: { name: string; type: string },\n  structs?: AbiStructs,\n  enums?: AbiEnums\n): BigNumberish | ParsedStruct | boolean | any[] | CairoEnum {\n  if (element.type === '()') {\n    return {};\n  }\n  // type uint256 struct (c1v2)\n  if (CairoUint256.isAbiType(element.type)) {\n    const low = responseIterator.next().value;\n    const high = responseIterator.next().value;\n    return new CairoUint256(low, high).toBigInt();\n  }\n  // type uint512 struct\n  if (CairoUint512.isAbiType(element.type)) {\n    const limb0 = responseIterator.next().value;\n    const limb1 = responseIterator.next().value;\n    const limb2 = responseIterator.next().value;\n    const limb3 = responseIterator.next().value;\n    return new CairoUint512(limb0, limb1, limb2, limb3).toBigInt();\n  }\n  // type C1 ByteArray struct, representing a LongString\n  if (isTypeByteArray(element.type)) {\n    const parsedBytes31Arr: BigNumberish[] = [];\n    const bytes31ArrLen = BigInt(responseIterator.next().value);\n    while (parsedBytes31Arr.length < bytes31ArrLen) {\n      parsedBytes31Arr.push(toHex(responseIterator.next().value));\n    }\n    const pending_word = toHex(responseIterator.next().value);\n    const pending_word_len = BigInt(responseIterator.next().value);\n    const myByteArray: ByteArray = {\n      data: parsedBytes31Arr,\n      pending_word,\n      pending_word_len,\n    };\n    return stringFromByteArray(myByteArray);\n  }\n\n  // type fixed-array\n  if (CairoFixedArray.isTypeFixedArray(element.type)) {\n    const parsedDataArr: (BigNumberish | ParsedStruct | boolean | any[] | CairoEnum)[] = [];\n    const el: AbiEntry = { name: '', type: CairoFixedArray.getFixedArrayType(element.type) };\n    const arraySize = CairoFixedArray.getFixedArraySize(element.type);\n    while (parsedDataArr.length < arraySize) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n    }\n    return parsedDataArr;\n  }\n\n  // type c1 array\n  if (isTypeArray(element.type)) {\n    // eslint-disable-next-line no-case-declarations\n    const parsedDataArr: (BigNumberish | ParsedStruct | boolean | any[] | CairoEnum)[] = [];\n    const el: AbiEntry = { name: '', type: getArrayType(element.type) };\n    const len = BigInt(responseIterator.next().value); // get length\n    while (parsedDataArr.length < len) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n    }\n    return parsedDataArr;\n  }\n\n  // type NonZero\n  if (isTypeNonZero(element.type)) {\n    // eslint-disable-next-line no-case-declarations\n    // const parsedDataArr: (BigNumberish | ParsedStruct | boolean | any[] | CairoEnum)[] = [];\n    const el: AbiEntry = { name: '', type: getArrayType(element.type) };\n    // parsedDataArr.push();\n    return parseResponseValue(responseIterator, el, structs, enums);\n  }\n\n  // type struct\n  if (structs && element.type in structs && structs[element.type]) {\n    if (isTypeEthAddress(element.type)) {\n      return parseBaseTypes(element.type, responseIterator);\n    }\n    return structs[element.type].members.reduce((acc, el) => {\n      acc[el.name] = parseResponseValue(responseIterator, el, structs, enums);\n      return acc;\n    }, {} as any);\n  }\n\n  // type Enum (only CustomEnum)\n  if (enums && element.type in enums && enums[element.type]) {\n    const variantNum: number = Number(responseIterator.next().value); // get variant number\n    const rawEnum = enums[element.type].variants.reduce((acc, variant, num) => {\n      if (num === variantNum) {\n        acc[variant.name] = parseResponseValue(\n          responseIterator,\n          { name: '', type: variant.type },\n          structs,\n          enums\n        );\n        return acc;\n      }\n      acc[variant.name] = undefined;\n      return acc;\n    }, {} as CairoEnumRaw);\n    // Option\n    if (element.type.startsWith('core::option::Option')) {\n      const content = variantNum === CairoOptionVariant.Some ? rawEnum.Some : undefined;\n      return new CairoOption<Object>(variantNum, content);\n    }\n    // Result\n    if (element.type.startsWith('core::result::Result')) {\n      let content: Object;\n      if (variantNum === CairoResultVariant.Ok) {\n        content = rawEnum.Ok;\n      } else {\n        content = rawEnum.Err;\n      }\n      return new CairoResult<Object, Object>(variantNum, content);\n    }\n    // Cairo custom Enum\n    const customEnum = new CairoCustomEnum(rawEnum);\n    return customEnum;\n  }\n\n  // type tuple\n  if (isTypeTuple(element.type)) {\n    const memberTypes = extractTupleMemberTypes(element.type);\n    return memberTypes.reduce((acc, it: any, idx) => {\n      const name = it?.name ? it.name : idx;\n      const type = it?.type ? it.type : it;\n      const el = { name, type };\n      acc[name] = parseResponseValue(responseIterator, el, structs, enums);\n      return acc;\n    }, {} as any);\n  }\n\n  // type c1 array\n  if (isTypeArray(element.type)) {\n    // eslint-disable-next-line no-case-declarations\n    const parsedDataArr: (BigNumberish | ParsedStruct | boolean | any[] | CairoEnum)[] = [];\n    const el = { name: '', type: getArrayType(element.type) };\n    const len = BigInt(responseIterator.next().value); // get length\n    while (parsedDataArr.length < len) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n    }\n    return parsedDataArr;\n  }\n\n  // base type\n  return parseBaseTypes(element.type, responseIterator);\n}\n\n/**\n * Parse elements of the response and structuring them into one field by using output property from the abi for that method\n *\n * @param responseIterator - iterator of the response\n * @param output - output(field) information from the abi that will be used to parse the data\n * @param structs - structs from abi\n * @param parsedResult\n * @return - parsed response corresponding to the abi structure of the field\n */\nexport default function responseParser(\n  responseIterator: Iterator<string>,\n  output: AbiEntry | EventEntry,\n  structs?: AbiStructs,\n  enums?: AbiEnums,\n  parsedResult?: Args | ParsedStruct\n): any {\n  const { name, type } = output;\n  let temp;\n\n  switch (true) {\n    case isLen(name):\n      temp = responseIterator.next().value;\n      return BigInt(temp);\n\n    case (structs && type in structs) || isTypeTuple(type):\n      return parseResponseValue(responseIterator, output, structs, enums);\n\n    case enums && isTypeEnum(type, enums):\n      return parseResponseValue(responseIterator, output, structs, enums);\n\n    case CairoFixedArray.isTypeFixedArray(type):\n      return parseResponseValue(responseIterator, output, structs, enums);\n\n    case isTypeArray(type):\n      // C1 Array\n      if (isCairo1Type(type)) {\n        return parseResponseValue(responseIterator, output, structs, enums);\n      }\n      // C0 Array\n      // eslint-disable-next-line no-case-declarations\n      const parsedDataArr: (BigNumberish | ParsedStruct | boolean | any[] | CairoEnum)[] = [];\n      if (parsedResult && parsedResult[`${name}_len`]) {\n        const arrLen = parsedResult[`${name}_len`] as number;\n        while (parsedDataArr.length < arrLen) {\n          parsedDataArr.push(\n            parseResponseValue(\n              responseIterator,\n              { name, type: output.type.replace('*', '') },\n              structs,\n              enums\n            )\n          );\n        }\n      }\n      return parsedDataArr;\n\n    case isTypeNonZero(type):\n      return parseResponseValue(responseIterator, output, structs, enums);\n\n    default:\n      return parseBaseTypes(type, responseIterator);\n  }\n}\n","import {\n  AbiEntry,\n  AbiEnums,\n  AbiStructs,\n  BigNumberish,\n  FunctionAbi,\n  Literal,\n  Uint,\n} from '../../types';\nimport assert from '../assert';\nimport { CairoFixedArray } from '../cairoDataTypes/fixedArray';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport { CairoUint512 } from '../cairoDataTypes/uint512';\nimport { isHex, toBigInt } from '../num';\nimport { isLongText } from '../shortString';\nimport { isBoolean, isNumber, isString, isBigInt, isObject } from '../typed';\nimport {\n  getArrayType,\n  isLen,\n  isTypeArray,\n  isTypeBool,\n  isTypeByteArray,\n  isTypeBytes31,\n  isTypeEnum,\n  isTypeEthAddress,\n  isTypeFelt,\n  isTypeLiteral,\n  isTypeNonZero,\n  isTypeOption,\n  isTypeResult,\n  isTypeStruct,\n  isTypeTuple,\n  isTypeUint,\n} from './cairo';\n\nconst validateFelt = (parameter: any, input: AbiEntry) => {\n  assert(\n    isString(parameter) || isNumber(parameter) || isBigInt(parameter),\n    `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`\n  );\n  if (isString(parameter) && !isHex(parameter)) return; // shortstring\n  const param = BigInt(parameter.toString(10));\n  assert(\n    // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1266\n    param >= 0n && param <= 2n ** 252n - 1n,\n    `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n  );\n};\n\nconst validateBytes31 = (parameter: any, input: AbiEntry) => {\n  assert(isString(parameter), `Validate: arg ${input.name} should be a string.`);\n  assert(\n    parameter.length < 32,\n    `Validate: arg ${input.name} cairo typed ${input.type} should be a string of less than 32 characters.`\n  );\n};\n\nconst validateByteArray = (parameter: any, input: AbiEntry) => {\n  assert(isString(parameter), `Validate: arg ${input.name} should be a string.`);\n};\n\nconst validateUint = (parameter: any, input: AbiEntry) => {\n  if (isNumber(parameter)) {\n    assert(\n      parameter <= Number.MAX_SAFE_INTEGER,\n      'Validation: Parameter is too large to be typed as Number use (BigInt or String)'\n    );\n  }\n  assert(\n    isString(parameter) ||\n      isNumber(parameter) ||\n      isBigInt(parameter) ||\n      (isObject(parameter) && 'low' in parameter && 'high' in parameter) ||\n      (isObject(parameter) &&\n        ['limb0', 'limb1', 'limb2', 'limb3'].every((key) => key in parameter)),\n    `Validate: arg ${input.name} of cairo type ${\n      input.type\n    } should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`\n  );\n  let param: bigint;\n  switch (input.type) {\n    case Uint.u256:\n      param = new CairoUint256(parameter).toBigInt();\n      break;\n    case Uint.u512:\n      param = new CairoUint512(parameter).toBigInt();\n      break;\n    default:\n      param = toBigInt(parameter);\n  }\n  switch (input.type) {\n    case Uint.u8:\n      assert(\n        param >= 0n && param <= 255n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`\n      );\n      break;\n\n    case Uint.u16:\n      assert(\n        param >= 0n && param <= 65535n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`\n      );\n      break;\n\n    case Uint.u32:\n      assert(\n        param >= 0n && param <= 4294967295n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`\n      );\n      break;\n\n    case Uint.u64:\n      assert(\n        param >= 0n && param <= 2n ** 64n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`\n      );\n      break;\n\n    case Uint.u128:\n      assert(\n        param >= 0n && param <= 2n ** 128n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`\n      );\n      break;\n\n    case Uint.u256:\n      assert(\n        param >= 0n && param <= 2n ** 256n - 1n,\n        `Validate: arg ${input.name} is ${input.type} should be in range 0 - 2^256-1`\n      );\n      break;\n\n    case Uint.u512:\n      assert(\n        CairoUint512.is(param),\n        `Validate: arg ${input.name} is ${input.type} should be in range 0 - 2^512-1`\n      );\n      break;\n\n    case Literal.ClassHash:\n      assert(\n        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1670\n        param >= 0n && param <= 2n ** 252n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n      );\n      break;\n\n    case Literal.ContractAddress:\n      assert(\n        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1245\n        param >= 0n && param <= 2n ** 252n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n      );\n      break;\n    case Literal.Secp256k1Point: {\n      assert(\n        param >= 0n && param <= 2n ** 512n - 1n,\n        `Validate: arg ${input.name} must be ${input.type} : a 512 bits number.`\n      );\n      break;\n    }\n    case Literal.U96: {\n      assert(\n        param >= 0n && param <= 2n ** 96n - 1n,\n        `Validate: arg ${input.name} must be ${input.type} : a 96 bits number.`\n      );\n      break;\n    }\n\n    default:\n      break;\n  }\n};\n\nconst validateBool = (parameter: any, input: AbiEntry) => {\n  assert(\n    isBoolean(parameter),\n    `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`\n  );\n};\n\nconst validateStruct = (parameter: any, input: AbiEntry, structs: AbiStructs) => {\n  // c1v2 uint256 or u512 in struct\n  if (input.type === Uint.u256 || input.type === Uint.u512) {\n    validateUint(parameter, input);\n    return;\n  }\n\n  if (isTypeEthAddress(input.type)) {\n    assert(!isObject(parameter), `EthAddress type is waiting a BigNumberish. Got \"${parameter}\"`);\n    const param = BigInt(parameter.toString(10));\n    assert(\n      // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1259\n      param >= 0n && param <= 2n ** 160n - 1n,\n      `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`\n    );\n    return;\n  }\n\n  assert(\n    isObject(parameter),\n    `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as a js object (not array)`\n  );\n\n  // shallow struct validation, only first depth level\n  structs[input.type].members.forEach(({ name }) => {\n    assert(\n      Object.keys(parameter).includes(name),\n      `Validate: arg ${input.name} should have a property ${name}`\n    );\n  });\n};\n\nconst validateEnum = (parameter: any, input: AbiEntry) => {\n  assert(\n    isObject(parameter),\n    `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as a js object (not array)`\n  );\n\n  const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));\n  const keys = [...Object.getOwnPropertyNames(parameter), ...methodsKeys];\n  if (isTypeOption(input.type) && keys.includes('isSome') && keys.includes('isNone')) {\n    return; // Option Enum\n  }\n  if (isTypeResult(input.type) && keys.includes('isOk') && keys.includes('isErr')) {\n    return; // Result Enum\n  }\n  if (keys.includes('variant') && keys.includes('activeVariant')) {\n    return; // Custom Enum\n  }\n  throw new Error(\n    `Validate Enum: argument ${input.name}, type ${input.type}, value received \"${parameter}\", is not an Enum.`\n  );\n};\n\nconst validateTuple = (parameter: any, input: AbiEntry) => {\n  assert(isObject(parameter), `Validate: arg ${input.name} should be a tuple (defined as object)`);\n  // todo: skip tuple structural validation for now\n};\n\nconst validateArray = (\n  parameterArray: Array<any> | Record<string, any>,\n  input: AbiEntry,\n  structs: AbiStructs,\n  enums: AbiEnums\n) => {\n  const isNormalArray = isTypeArray(input.type);\n  const baseType = isNormalArray\n    ? getArrayType(input.type)\n    : CairoFixedArray.getFixedArrayType(input.type);\n\n  // Long text (special case when parameter is not an array but long text)\n  if (isNormalArray && isTypeFelt(baseType) && isLongText(parameterArray)) {\n    return;\n  }\n  let parameter: Array<any> = [];\n  if (isNormalArray) {\n    assert(Array.isArray(parameterArray), `Validate: arg ${input.name} should be an Array`);\n    parameter = parameterArray;\n  } else {\n    // fixedArray\n    switch (true) {\n      case Array.isArray(parameterArray):\n        // the type cast is just for the documentation generation, TS narrowing works as expected\n        parameter = parameterArray as any;\n        break;\n      case typeof parameterArray === 'object':\n        parameter = Object.values(parameterArray);\n        break;\n      default:\n        throw new Error(`Validate: arg ${input.name} should be an Array or an object.`);\n    }\n  }\n\n  switch (true) {\n    case isTypeFelt(baseType):\n      parameter.forEach((param: BigNumberish) => validateFelt(param, input));\n      break;\n    case isTypeTuple(baseType):\n      parameter.forEach((it: any) => validateTuple(it, { name: input.name, type: baseType }));\n      break;\n\n    case isTypeArray(baseType):\n      parameter.forEach((param: any) =>\n        validateArray(param, { name: '', type: baseType }, structs, enums)\n      );\n      break;\n    case isTypeStruct(baseType, structs):\n      parameter.forEach((it: any) =>\n        validateStruct(it, { name: input.name, type: baseType }, structs)\n      );\n      break;\n    case isTypeEnum(baseType, enums):\n      parameter.forEach((it: any) => validateEnum(it, { name: input.name, type: baseType }));\n      break;\n    case isTypeUint(baseType) || isTypeLiteral(baseType):\n      parameter.forEach((param: BigNumberish) => validateUint(param, { name: '', type: baseType }));\n      break;\n    case isTypeBool(baseType):\n      parameter.forEach((param: BigNumberish) => validateBool(param, input));\n      break;\n    default:\n      throw new Error(\n        `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n      );\n  }\n};\n\nconst validateNonZero = (parameter: any, input: AbiEntry) => {\n  // Telegram : https://t.me/sncorestars/11902/45433\n  // Author : Ori Ziv (08/apr/2024)\n  // \"NonZero is only supported for purely numeric types (u*, i* and felt252) and EcPoint.\"\n  //\n  // As EcPoint do not includes trait Serde, it can't be seen in an ABI.\n  // u512 is not compatible.\n  // i* are not currently handled by Starknet.js (and core::zeroable::NonZero::<i*> seems not to work in Cairo 2.6.3).\n  // so, are authorized here : u8, u16, u32, u64, u128, u256 and felt252.\n\n  const baseType = getArrayType(input.type);\n\n  assert(\n    (isTypeUint(baseType) && baseType !== CairoUint512.abiSelector) || isTypeFelt(baseType),\n    `Validate: ${input.name} type is not authorized for NonZero type.`\n  );\n  switch (true) {\n    case isTypeFelt(baseType):\n      validateFelt(parameter, input);\n      assert(\n        BigInt(parameter.toString(10)) > 0,\n        'Validate: value 0 is not authorized in NonZero felt252 type.'\n      );\n      break;\n    case isTypeUint(baseType):\n      validateUint(parameter, { name: '', type: baseType });\n\n      switch (baseType) {\n        case Uint.u256:\n          assert(\n            new CairoUint256(parameter).toBigInt() > 0,\n            'Validate: value 0 is not authorized in NonZero uint256 type.'\n          );\n          break;\n        default:\n          assert(\n            toBigInt(parameter) > 0,\n            'Validate: value 0 is not authorized in NonZero uint type.'\n          );\n      }\n      break;\n    default:\n      throw new Error(\n        `Validate Unhandled: argument ${input.name}, type ${input.type}, value \"${parameter}\"`\n      );\n  }\n};\n\n/**\n * Validate cairo contract method arguments\n * Flow: Determine type from abi and than validate against parameter\n *\n * @param {FunctionAbi} abiMethod - Abi method.\n * @param {any[]} args - Arguments.\n * @param {AbiStructs} structs - ABI structs.\n * @param {AbiEnums} enums - ABI enums.\n * @returns {void} - Return void if validation passes\n *\n * @example\n * const functionAbi: FunctionAbi = {\n *   inputs: [{ name: 'test', type: 'felt' }],\n *   name: 'test',\n *   outputs: [{ name: 'test', type: 'felt' }],\n *   stateMutability: 'view',\n *   type: 'function',\n * };\n *\n * const abiStructs: AbiStructs = {\n *  abi_structs: {\n *    members: [\n *        {\n *          name: 'test_name',\n *          type: 'test_type',\n *          offset: 1,\n *        },\n *    ],\n *    size: 2,\n *    name: 'cairo_event_struct',\n *    type: 'struct',\n *   },\n * };\n *\n * const abiEnums: AbiEnums = {\n *   abi_enums: {\n *     variants: [\n *       {\n *         name: 'test_name',\n *         type: 'cairo_event_struct_variant',\n *         offset: 1,\n *       },\n *     ],\n *     size: 2,\n *     name: 'test_cairo_event',\n *     type: 'enum',\n *   },\n * };\n *\n * validateFields(functionAbi, [1n], abiStructs, abiEnums); // Returns void since validation passes\n * validateFields(functionAbi, [{}], abiStructs, abiEnums); // Throw an error because paramters are not valid\n */\nexport default function validateFields(\n  abiMethod: FunctionAbi,\n  args: any[],\n  structs: AbiStructs,\n  enums: AbiEnums\n): void {\n  abiMethod.inputs.reduce((acc, input) => {\n    const parameter = args[acc];\n\n    switch (true) {\n      case isLen(input.name):\n        return acc;\n      case isTypeFelt(input.type):\n        validateFelt(parameter, input);\n        break;\n      case isTypeBytes31(input.type):\n        validateBytes31(parameter, input);\n        break;\n      case isTypeUint(input.type) || isTypeLiteral(input.type):\n        validateUint(parameter, input);\n        break;\n      case isTypeBool(input.type):\n        validateBool(parameter, input);\n        break;\n      case isTypeByteArray(input.type):\n        validateByteArray(parameter, input);\n        break;\n      case isTypeArray(input.type) || CairoFixedArray.isTypeFixedArray(input.type):\n        validateArray(parameter, input, structs, enums);\n        break;\n      case isTypeStruct(input.type, structs):\n        validateStruct(parameter, input, structs);\n        break;\n      case isTypeEnum(input.type, enums):\n        validateEnum(parameter, input);\n        break;\n      case isTypeTuple(input.type):\n        validateTuple(parameter, input);\n        break;\n      case isTypeNonZero(input.type):\n        validateNonZero(parameter, input);\n        break;\n      default:\n        throw new Error(\n          `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n        );\n    }\n\n    return acc + 1;\n  }, 0);\n}\n","/* eslint-disable no-plusplus */\nimport {\n  Abi,\n  AbiEnums,\n  AbiStructs,\n  AllowArray,\n  Args,\n  ArgsOrCalldata,\n  Calldata,\n  FunctionAbi,\n  HexCalldata,\n  RawArgs,\n  RawArgsArray,\n  Result,\n  ValidateType,\n} from '../../types';\nimport assert from '../assert';\nimport { toHex } from '../num';\nimport { isBigInt } from '../typed';\nimport { getSelectorFromName } from '../hash/selector';\nimport { isLongText } from '../shortString';\nimport { byteArrayFromString } from './byteArray';\nimport { felt, isCairo1Type, isLen } from './cairo';\nimport {\n  CairoCustomEnum,\n  CairoOption,\n  CairoOptionVariant,\n  CairoResult,\n  CairoResultVariant,\n} from './enum';\nimport formatter from './formatter';\nimport { createAbiParser, isNoConstructorValid } from './parser';\nimport { AbiParserInterface } from './parser/interface';\nimport orderPropsByAbi from './propertyOrder';\nimport { parseCalldataField } from './requestParser';\nimport responseParser from './responseParser';\nimport validateFields from './validate';\n\nexport * as cairo from './cairo';\nexport * as byteArray from './byteArray';\nexport { parseCalldataField } from './requestParser';\n\nexport class CallData {\n  abi: Abi;\n\n  parser: AbiParserInterface;\n\n  protected readonly structs: AbiStructs;\n\n  protected readonly enums: AbiEnums;\n\n  constructor(abi: Abi) {\n    this.structs = CallData.getAbiStruct(abi);\n    this.enums = CallData.getAbiEnum(abi);\n    this.parser = createAbiParser(abi);\n    this.abi = this.parser.getLegacyFormat();\n  }\n\n  /**\n   * Validate arguments passed to the method as corresponding to the ones in the abi\n   * @param type ValidateType - type of the method\n   * @param method string - name of the method\n   * @param args ArgsOrCalldata - arguments that are passed to the method\n   */\n  public validate(type: ValidateType, method: string, args: ArgsOrCalldata = []) {\n    // ensure provided method of type exists\n    if (type !== ValidateType.DEPLOY) {\n      const invocableFunctionNames = this.abi\n        .filter((abi) => {\n          if (abi.type !== 'function') return false;\n          const isView = abi.stateMutability === 'view' || abi.state_mutability === 'view';\n          return type === ValidateType.INVOKE ? !isView : isView;\n        })\n        .map((abi) => abi.name);\n      assert(\n        invocableFunctionNames.includes(method),\n        `${type === ValidateType.INVOKE ? 'invocable' : 'viewable'} method not found in abi`\n      );\n    }\n\n    // get requested method from abi\n    const abiMethod = this.abi.find((abi) =>\n      type === ValidateType.DEPLOY\n        ? abi.name === method && abi.type === 'constructor'\n        : abi.name === method && abi.type === 'function'\n    ) as FunctionAbi;\n\n    if (isNoConstructorValid(method, args, abiMethod)) {\n      return;\n    }\n\n    // validate arguments length\n    const inputsLength = this.parser.methodInputsLength(abiMethod);\n    if (args.length !== inputsLength) {\n      throw Error(\n        `Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`\n      );\n    }\n\n    // validate parameters\n    validateFields(abiMethod, args, this.structs, this.enums);\n  }\n\n  /**\n   * Compile contract callData with abi\n   * Parse the calldata by using input fields from the abi for that method\n   * @param method string - method name\n   * @param argsCalldata RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).\n   * @return Calldata - parsed arguments in format that contract is expecting\n   * @example\n   * ```typescript\n   * const calldata = myCallData.compile(\"constructor\", [\"0x34a\", [1, 3n]]);\n   * ```\n   * ```typescript\n   * const calldata2 = myCallData.compile(\"constructor\", {list:[1, 3n], balance:\"0x34\"}); // wrong order is valid\n   * ```\n   */\n  public compile(method: string, argsCalldata: RawArgs): Calldata {\n    const abiMethod = this.abi.find((abiFunction) => abiFunction.name === method) as FunctionAbi;\n\n    if (isNoConstructorValid(method, argsCalldata, abiMethod)) {\n      return [];\n    }\n\n    let args: RawArgsArray;\n    if (Array.isArray(argsCalldata)) {\n      args = argsCalldata;\n    } else {\n      // order the object\n      const orderedObject = orderPropsByAbi(\n        argsCalldata,\n        abiMethod.inputs,\n        this.structs,\n        this.enums\n      );\n      args = Object.values(orderedObject);\n      //   // validate array elements to abi\n      validateFields(abiMethod, args, this.structs, this.enums);\n    }\n\n    const argsIterator = args[Symbol.iterator]();\n\n    const callArray = abiMethod.inputs.reduce(\n      (acc, input) =>\n        isLen(input.name) && !isCairo1Type(input.type)\n          ? acc\n          : acc.concat(parseCalldataField(argsIterator, input, this.structs, this.enums)),\n      [] as Calldata\n    );\n\n    // add compiled property to array object\n    Object.defineProperty(callArray, '__compiled__', {\n      enumerable: false,\n      writable: false,\n      value: true,\n    });\n    return callArray;\n  }\n\n  /**\n   * Compile contract callData without abi\n   * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data\n   * @returns Calldata\n   */\n  static compile(rawArgs: RawArgs): Calldata {\n    const createTree = (obj: object) => {\n      const getEntries = (o: object, prefix = '.'): any => {\n        const oe = Array.isArray(o) ? [o.length.toString(), ...o] : o;\n        return Object.entries(oe).flatMap(([k, v]) => {\n          let value = v;\n          if (k === 'entrypoint') value = getSelectorFromName(value);\n          else if (isLongText(value)) value = byteArrayFromString(value);\n          const kk = Array.isArray(oe) && k === '0' ? '$$len' : k;\n          if (isBigInt(value)) return [[`${prefix}${kk}`, felt(value)]];\n          if (Object(value) === value) {\n            const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));\n            const keys = [...Object.getOwnPropertyNames(value), ...methodsKeys];\n            if (keys.includes('isSome') && keys.includes('isNone')) {\n              // Option\n              const myOption = value as CairoOption<any>;\n              const variantNb = myOption.isSome()\n                ? CairoOptionVariant.Some\n                : CairoOptionVariant.None;\n              if (myOption.isSome())\n                return getEntries({ 0: variantNb, 1: myOption.unwrap() }, `${prefix}${kk}.`);\n              return [[`${prefix}${kk}`, felt(variantNb)]];\n            }\n            if (keys.includes('isOk') && keys.includes('isErr')) {\n              // Result\n              const myResult = value as CairoResult<any, any>;\n              const variantNb = myResult.isOk() ? CairoResultVariant.Ok : CairoResultVariant.Err;\n              return getEntries({ 0: variantNb, 1: myResult.unwrap() }, `${prefix}${kk}.`);\n            }\n            if (keys.includes('variant') && keys.includes('activeVariant')) {\n              // CustomEnum\n              const myEnum = value as CairoCustomEnum;\n              const activeVariant: string = myEnum.activeVariant();\n              const listVariants = Object.keys(myEnum.variant);\n              const activeVariantNb = listVariants.findIndex(\n                (variant: any) => variant === activeVariant\n              );\n              if (\n                typeof myEnum.unwrap() === 'object' &&\n                Object.keys(myEnum.unwrap()).length === 0 // empty object : {}\n              ) {\n                return [[`${prefix}${kk}`, felt(activeVariantNb)]];\n              }\n              return getEntries({ 0: activeVariantNb, 1: myEnum.unwrap() }, `${prefix}${kk}.`);\n            }\n            // normal object\n            return getEntries(value, `${prefix}${kk}.`);\n          }\n          return [[`${prefix}${kk}`, felt(value)]];\n        });\n      };\n      const result = Object.fromEntries(getEntries(obj));\n      return result;\n    };\n\n    let callTreeArray;\n    if (!Array.isArray(rawArgs)) {\n      // flatten structs, tuples, add array length. Process leafs as Felt\n      const callTree = createTree(rawArgs);\n      // convert to array\n      callTreeArray = Object.values(callTree);\n    } else {\n      // already compiled data but modified or raw args provided as array, recompile it\n      // recreate tree\n      const callObj = { ...rawArgs };\n      const callTree = createTree(callObj);\n      callTreeArray = Object.values(callTree);\n    }\n\n    // add compiled property to array object\n    Object.defineProperty(callTreeArray, '__compiled__', {\n      enumerable: false,\n      writable: false,\n      value: true,\n    });\n    return callTreeArray;\n  }\n\n  /**\n   * Parse elements of the response array and structuring them into response object\n   * @param method string - method name\n   * @param response string[] - response from the method\n   * @return Result - parsed response corresponding to the abi\n   */\n  public parse(method: string, response: string[]): Result {\n    const { outputs } = this.abi.find((abi) => abi.name === method) as FunctionAbi;\n    const responseIterator = response.flat()[Symbol.iterator]();\n\n    const parsed = outputs.flat().reduce((acc, output, idx) => {\n      const propName = output.name ?? idx;\n      acc[propName] = responseParser(responseIterator, output, this.structs, this.enums, acc);\n      if (acc[propName] && acc[`${propName}_len`]) {\n        delete acc[`${propName}_len`];\n      }\n      return acc;\n    }, {} as Args);\n\n    // Cairo1 avoid object.0 structure\n    return Object.keys(parsed).length === 1 && 0 in parsed ? (parsed[0] as Result) : parsed;\n  }\n\n  /**\n   * Format cairo method response data to native js values based on provided format schema\n   * @param method string - cairo method name\n   * @param response string[] - cairo method response\n   * @param format object - formatter object schema\n   * @returns Result - parsed and formatted response object\n   */\n  public format(method: string, response: string[], format: object): Result {\n    const parsed = this.parse(method, response);\n    return formatter(parsed as Record<string, any>, format);\n  }\n\n  /**\n   * Helper to extract structs from abi\n   * @param abi Abi\n   * @returns AbiStructs - structs from abi\n   */\n  static getAbiStruct(abi: Abi): AbiStructs {\n    return abi\n      .filter((abiEntry) => abiEntry.type === 'struct')\n      .reduce(\n        (acc, abiEntry) => ({\n          ...acc,\n          [abiEntry.name]: abiEntry,\n        }),\n        {}\n      );\n  }\n\n  /**\n   * Helper to extract enums from abi\n   * @param abi Abi\n   * @returns AbiEnums - enums from abi\n   */\n  static getAbiEnum(abi: Abi): AbiEnums {\n    const fullEnumList = abi\n      .filter((abiEntry) => abiEntry.type === 'enum')\n      .reduce(\n        (acc, abiEntry) => ({\n          ...acc,\n          [abiEntry.name]: abiEntry,\n        }),\n        {}\n      );\n    delete fullEnumList['core::bool'];\n    return fullEnumList;\n  }\n\n  /**\n   * Helper: Compile HexCalldata | RawCalldata | RawArgs\n   * @param rawCalldata HexCalldata | RawCalldata | RawArgs\n   * @returns Calldata\n   */\n  static toCalldata(rawCalldata: RawArgs = []): Calldata {\n    return CallData.compile(rawCalldata);\n  }\n\n  /**\n   * Helper: Convert raw to HexCalldata\n   * @param raw HexCalldata | RawCalldata | RawArgs\n   * @returns HexCalldata\n   */\n  static toHex(raw: RawArgs = []): HexCalldata {\n    const calldata = CallData.compile(raw);\n    return calldata.map((it) => toHex(it));\n  }\n\n  /**\n   * Parse the elements of a contract response and structure them into one or several Result.\n   * In Cairo 0, arrays are not supported.\n   * @param typeCairo string or string[] - Cairo type name, ex : \"hello::hello::UserData\"\n   * @param response string[] - serialized data corresponding to typeCairo.\n   * @return Result or Result[] - parsed response corresponding to typeData.\n   * @example\n   * const res2=helloCallData.decodeParameters(\"hello::hello::UserData\",[\"0x123456\",\"0x1\"]);\n   * result = { address: 1193046n, is_claimed: true }\n   */\n  public decodeParameters(typeCairo: AllowArray<string>, response: string[]): AllowArray<Result> {\n    const typeCairoArray = Array.isArray(typeCairo) ? typeCairo : [typeCairo];\n    const responseIterator = response.flat()[Symbol.iterator]();\n    const decodedArray = typeCairoArray.map(\n      (typeParam) =>\n        responseParser(\n          responseIterator,\n          { name: '', type: typeParam },\n          this.structs,\n          this.enums\n        ) as Result\n    );\n    return decodedArray.length === 1 ? decodedArray[0] : decodedArray;\n  }\n}\n","/**\n * Hashes Exports\n */\nexport * as poseidon from '@noble/curves/abstract/poseidon';\nexport * from './selector'; // Preserve legacy export structure\n\nexport * from './transactionHash';\nexport * from './classHash';\n","/**\n * Calculate Hashes for v0 - v2 transactions\n */\n\n/* eslint-disable no-param-reassign */\n/* eslint-disable import/extensions */\nimport { StarknetChainId, TransactionHashPrefix } from '../../../global/constants';\nimport { BigNumberish, RawCalldata } from '../../../types';\nimport { starkCurve } from '../../ec';\nimport { toBigInt } from '../../num';\nimport { getSelector } from '../selector';\n\n/**\n * Compute pedersen hash from data\n * @returns format: hex-string - pedersen hash\n */\nexport function computeHashOnElements(data: BigNumberish[]): string {\n  return [...data, data.length]\n    .reduce((x: BigNumberish, y: BigNumberish) => starkCurve.pedersen(toBigInt(x), toBigInt(y)), 0)\n    .toString();\n}\n\n/**\n * Calculate transaction pedersen hash for common properties\n *\n * Following implementation is based on this python [implementation #](https://github.com/starkware-libs/cairo-lang/blob/b614d1867c64f3fb2cf4a4879348cfcf87c3a5a7/src/starkware/starknet/core/os/transaction_hash/transaction_hash.py)\n * @returns format: hex-string\n */\nexport function calculateTransactionHashCommon(\n  txHashPrefix: TransactionHashPrefix,\n  version: BigNumberish,\n  contractAddress: BigNumberish,\n  entryPointSelector: BigNumberish,\n  calldata: RawCalldata,\n  maxFee: BigNumberish,\n  chainId: StarknetChainId,\n  additionalData: BigNumberish[] = []\n): string {\n  const calldataHash = computeHashOnElements(calldata);\n  const dataToHash = [\n    txHashPrefix,\n    version,\n    contractAddress,\n    entryPointSelector,\n    calldataHash,\n    maxFee,\n    chainId,\n    ...additionalData,\n  ];\n  return computeHashOnElements(dataToHash);\n}\n\n/**\n * Calculate declare transaction hash\n * @param classHash hex-string\n * @param compiledClassHash hex-string\n * @returns format: hex-string\n */\nexport function calculateDeclareTransactionHash(\n  classHash: string,\n  senderAddress: BigNumberish,\n  version: BigNumberish,\n  maxFee: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  compiledClassHash?: string\n): string {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.DECLARE,\n    version,\n    senderAddress,\n    0,\n    [classHash],\n    maxFee,\n    chainId,\n    [nonce, ...(compiledClassHash ? [compiledClassHash] : [])]\n  );\n}\n\n/**\n * Calculate deploy_account transaction hash\n * @returns format: hex-string\n */\nexport function calculateDeployAccountTransactionHash(\n  contractAddress: BigNumberish,\n  classHash: BigNumberish,\n  constructorCalldata: RawCalldata,\n  salt: BigNumberish,\n  version: BigNumberish,\n  maxFee: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish\n) {\n  const calldata = [classHash, salt, ...constructorCalldata];\n\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.DEPLOY_ACCOUNT,\n    version,\n    contractAddress,\n    0,\n    calldata,\n    maxFee,\n    chainId,\n    [nonce]\n  );\n}\n\n/**\n * Calculate invoke transaction hash\n * @returns format: hex-string\n */\nexport function calculateTransactionHash(\n  contractAddress: BigNumberish,\n  version: BigNumberish,\n  calldata: RawCalldata,\n  maxFee: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish\n): string {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.INVOKE,\n    version,\n    contractAddress,\n    0,\n    calldata,\n    maxFee,\n    chainId,\n    [nonce]\n  );\n}\n\n/**\n * Calculate the L2 transaction hash generated by a message L1->L2\n * @param {BigNumberish} l1FromAddress L1 account address that paid the message.\n * @param {BigNumberish} l2ToAddress L2 contract address to execute.\n * @param {string | BigNumberish} l2Selector can be a function name (\"bridge_withdraw\") or a number (BigNumberish).\n * @param {RawCalldata} l2Calldata an array of BigNumberish of the raw parameters passed to the above function.\n * @param {BigNumberish} l2ChainId L2 chain ID : from constants.StarknetChainId.xxx\n * @param {BigNumberish} l1Nonce The nonce of the L1 account.\n * @returns {string} hex-string of the L2 transaction hash\n * @example\n * ```typescript\n * const l1FromAddress = \"0x0000000000000000000000008453fc6cd1bcfe8d4dfc069c400b433054d47bdc\";\n * const l2ToAddress = 2158142789748719025684046545159279785659305214176670733242887773692203401023n;\n * const l2Selector = 774397379524139446221206168840917193112228400237242521560346153613428128537n;\n * const payload = [\n *     4543560n,\n *    829565602143178078434185452406102222830667255948n,\n *     3461886633118033953192540141609307739580461579986333346825796013261542798665n,\n *     9000000000000000n,\n *     0n,\n * ];\n * const l1Nonce = 8288n;\n * const result = hash.calculateL2MessageTxHash(l1FromAddress, l2ToAddress, l2Selector, payload, constants.StarknetChainId.SN_SEPOLIA, l1Nonce);\n * // result = \"0x67d959200d65d4ad293aa4b0da21bb050a1f669bce37d215c6edbf041269c07\"\n * ```\n */\nexport function calculateL2MessageTxHash(\n  l1FromAddress: BigNumberish,\n  l2ToAddress: BigNumberish,\n  l2Selector: string | BigNumberish,\n  l2Calldata: RawCalldata,\n  l2ChainId: StarknetChainId,\n  l1Nonce: BigNumberish\n): string {\n  const payload = [l1FromAddress, ...l2Calldata];\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.L1_HANDLER,\n    0,\n    l2ToAddress,\n    getSelector(l2Selector),\n    payload,\n    0,\n    l2ChainId,\n    [l1Nonce]\n  );\n}\n","// TODO rename\nexport * as starkCurve from '@scure/starknet';\nexport * as weierstrass from '@noble/curves/abstract/weierstrass';\n","/**\n * Calculate Hashes for v3 transactions\n */\n\nimport { poseidonHashMany } from '@scure/starknet';\n\nimport { StarknetChainId, TransactionHashPrefix } from '../../../global/constants';\nimport { BigNumberish, Calldata } from '../../../types';\nimport { EDAMode, ResourceBounds } from '../../../types/api';\nimport { toHex } from '../../num';\nimport { encodeShortString } from '../../shortString';\n\nconst AToBI = (array: BigNumberish[]) => array.map((it: BigNumberish) => BigInt(it));\n\n/* eslint-disable no-bitwise */\nconst DATA_AVAILABILITY_MODE_BITS = 32n;\nconst MAX_AMOUNT_BITS = 64n;\nconst MAX_PRICE_PER_UNIT_BITS = 128n;\nconst RESOURCE_VALUE_OFFSET = MAX_AMOUNT_BITS + MAX_PRICE_PER_UNIT_BITS;\nconst L1_GAS_NAME = BigInt(encodeShortString('L1_GAS'));\nconst L2_GAS_NAME = BigInt(encodeShortString('L2_GAS'));\n\nexport function hashDAMode(nonceDAMode: BigNumberish, feeDAMode: BigNumberish) {\n  return (BigInt(nonceDAMode) << DATA_AVAILABILITY_MODE_BITS) + BigInt(feeDAMode);\n}\n\n/**\n * Encode the L1&L2 gas limits of a V3 transaction\n * @param {ResourceBounds} bounds object including the limits for L1 & L2 gas\n * @returns {bigint} encoded data\n */\nexport function encodeResourceBoundsL1(bounds: ResourceBounds): bigint {\n  return (\n    (L1_GAS_NAME << RESOURCE_VALUE_OFFSET) +\n    (BigInt(bounds.l1_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) +\n    BigInt(bounds.l1_gas.max_price_per_unit)\n  );\n}\n\n/**\n * Encode the L2 bound of a V3 transaction\n * @param {ResourceBounds} bounds \n * {l1_gas: {max_amount: u64, max_price_per_unit: u128},\n *  l2_gas: {max_amount: u64, max_price_per_unit: u128}}\n}\n * @returns {bigint} encoded data\n */\nexport function encodeResourceBoundsL2(bounds: ResourceBounds): bigint {\n  return (\n    (L2_GAS_NAME << RESOURCE_VALUE_OFFSET) +\n    (BigInt(bounds.l2_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) +\n    BigInt(bounds.l2_gas.max_price_per_unit)\n  );\n}\n\nexport function hashFeeField(tip: BigNumberish, bounds: ResourceBounds) {\n  const L1Bound = encodeResourceBoundsL1(bounds);\n  const L2Bound = encodeResourceBoundsL2(bounds);\n  return poseidonHashMany([BigInt(tip), L1Bound, L2Bound]);\n}\n\nexport function calculateTransactionHashCommon(\n  txHashPrefix: TransactionHashPrefix,\n  version: BigNumberish,\n  senderAddress: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  tip: BigNumberish,\n  paymasterData: BigNumberish[],\n  nonceDataAvailabilityMode: EDAMode,\n  feeDataAvailabilityMode: EDAMode,\n  resourceBounds: ResourceBounds,\n  additionalData: BigNumberish[] = []\n): string {\n  const feeFieldHash = hashFeeField(tip, resourceBounds);\n  const dAModeHash = hashDAMode(nonceDataAvailabilityMode, feeDataAvailabilityMode);\n  const dataToHash = AToBI([\n    txHashPrefix,\n    version,\n    senderAddress,\n    feeFieldHash,\n    poseidonHashMany(AToBI(paymasterData)),\n    chainId,\n    nonce,\n    dAModeHash,\n    ...AToBI(additionalData),\n  ]);\n  return toHex(poseidonHashMany(dataToHash));\n}\n\n/**\n * Calculate v3 deploy_account transaction hash\n * @returns format: hex-string\n */\nexport function calculateDeployAccountTransactionHash(\n  contractAddress: BigNumberish,\n  classHash: BigNumberish,\n  compiledConstructorCalldata: Calldata,\n  salt: BigNumberish,\n  version: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  nonceDataAvailabilityMode: EDAMode,\n  feeDataAvailabilityMode: EDAMode,\n  resourceBounds: ResourceBounds,\n  tip: BigNumberish,\n  paymasterData: BigNumberish[]\n) {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.DEPLOY_ACCOUNT,\n    version,\n    contractAddress,\n    chainId,\n    nonce,\n    tip,\n    paymasterData,\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [poseidonHashMany(AToBI(compiledConstructorCalldata)), classHash, salt]\n  );\n}\n\n/**\n * Calculate v3 declare transaction hash\n * @returns format: hex-string\n */\nexport function calculateDeclareTransactionHash(\n  classHash: string,\n  compiledClassHash: string,\n  senderAddress: BigNumberish,\n  version: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  accountDeploymentData: BigNumberish[],\n  nonceDataAvailabilityMode: EDAMode,\n  feeDataAvailabilityMode: EDAMode,\n  resourceBounds: ResourceBounds,\n  tip: BigNumberish,\n  paymasterData: BigNumberish[]\n): string {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.DECLARE,\n    version,\n    senderAddress,\n    chainId,\n    nonce,\n    tip,\n    AToBI(paymasterData),\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [poseidonHashMany(AToBI(accountDeploymentData)), classHash, compiledClassHash]\n  );\n}\n\n/**\n * Calculate v3 invoke transaction hash\n * @returns format: hex-string\n */\nexport function calculateInvokeTransactionHash(\n  senderAddress: BigNumberish,\n  version: BigNumberish,\n  compiledCalldata: Calldata,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  accountDeploymentData: BigNumberish[],\n  nonceDataAvailabilityMode: EDAMode,\n  feeDataAvailabilityMode: EDAMode,\n  resourceBounds: ResourceBounds,\n  tip: BigNumberish,\n  paymasterData: BigNumberish[]\n): string {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.INVOKE,\n    version,\n    senderAddress,\n    chainId,\n    nonce,\n    tip,\n    paymasterData,\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [poseidonHashMany(AToBI(accountDeploymentData)), poseidonHashMany(AToBI(compiledCalldata))]\n  );\n}\n","/**\n * Transaction Hash based on Transaction Version\n */\n\nimport { StarknetChainId } from '../../../global/constants';\nimport { BigNumberish, Calldata } from '../../../types';\nimport {\n  EDAMode,\n  ETransactionVersion,\n  ETransactionVersion2,\n  ETransactionVersion3,\n  ResourceBounds,\n} from '../../../types/api';\nimport {\n  calculateDeclareTransactionHash as v2calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash as v2calculateDeployAccountTransactionHash,\n  calculateTransactionHash as v2calculateInvokeTransactionHash,\n} from './v2';\nimport {\n  calculateDeclareTransactionHash as v3calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash as v3calculateDeployAccountTransactionHash,\n  calculateInvokeTransactionHash as v3calculateInvokeTransactionHash,\n} from './v3';\n\nexport { calculateL2MessageTxHash } from './v2';\n/*\n * INVOKE TX HASH\n */\n\ntype Version = typeof ETransactionVersion.V3 | typeof ETransactionVersion.F3;\n\nfunction isV3InvokeTx(args: CalcInvokeTxHashArgs): args is CalcV3InvokeTxHashArgs {\n  return [ETransactionVersion.V3, ETransactionVersion.F3].includes(args.version as Version);\n}\n\ntype CalcV2InvokeTxHashArgs = {\n  senderAddress: BigNumberish;\n  version: `${ETransactionVersion2}`;\n  compiledCalldata: Calldata;\n  maxFee: BigNumberish;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n};\n\ntype CalcV3InvokeTxHashArgs = {\n  senderAddress: BigNumberish;\n  version: `${ETransactionVersion3}`;\n  compiledCalldata: Calldata;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n  accountDeploymentData: BigNumberish[];\n  nonceDataAvailabilityMode: EDAMode;\n  feeDataAvailabilityMode: EDAMode;\n  resourceBounds: ResourceBounds;\n  tip: BigNumberish;\n  paymasterData: BigNumberish[];\n};\n\ntype CalcInvokeTxHashArgs = CalcV2InvokeTxHashArgs | CalcV3InvokeTxHashArgs;\n\nexport function calculateInvokeTransactionHash(args: CalcInvokeTxHashArgs) {\n  if (isV3InvokeTx(args)) {\n    return v3calculateInvokeTransactionHash(\n      args.senderAddress,\n      args.version,\n      args.compiledCalldata,\n      args.chainId,\n      args.nonce,\n      args.accountDeploymentData,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n  return v2calculateInvokeTransactionHash(\n    args.senderAddress,\n    args.version,\n    args.compiledCalldata,\n    args.maxFee,\n    args.chainId,\n    args.nonce\n  );\n}\n\n/*\n * DECLARE TX HASH\n */\nfunction isV3DeclareTx(args: CalcDeclareTxHashArgs): args is CalcV3DeclareTxHashArgs {\n  return [ETransactionVersion.V3, ETransactionVersion.F3].includes(args.version as Version);\n}\n\ntype CalcV2DeclareTxHashArgs = {\n  classHash: string;\n  senderAddress: BigNumberish;\n  version: `${ETransactionVersion2}`;\n  maxFee: BigNumberish;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n  compiledClassHash?: string;\n};\n\ntype CalcV3DeclareTxHashArgs = {\n  classHash: string;\n  compiledClassHash: string;\n  senderAddress: BigNumberish;\n  version: `${ETransactionVersion3}`;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n  accountDeploymentData: BigNumberish[];\n  nonceDataAvailabilityMode: EDAMode;\n  feeDataAvailabilityMode: EDAMode;\n  resourceBounds: ResourceBounds;\n  tip: BigNumberish;\n  paymasterData: BigNumberish[];\n};\n\ntype CalcDeclareTxHashArgs = CalcV2DeclareTxHashArgs | CalcV3DeclareTxHashArgs;\n\nexport function calculateDeclareTransactionHash(args: CalcDeclareTxHashArgs) {\n  if (isV3DeclareTx(args)) {\n    return v3calculateDeclareTransactionHash(\n      args.classHash,\n      args.compiledClassHash,\n      args.senderAddress,\n      args.version,\n      args.chainId,\n      args.nonce,\n      args.accountDeploymentData,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n\n  return v2calculateDeclareTransactionHash(\n    args.classHash,\n    args.senderAddress,\n    args.version,\n    args.maxFee,\n    args.chainId,\n    args.nonce,\n    args.compiledClassHash\n  );\n}\n\n/*\n * DEPLOY ACCOUNT TX HASH\n */\n\nfunction isV3DeployAccountTx(\n  args: CalcDeployAccountTxHashArgs\n): args is CalcV3DeployAccountTxHashArgs {\n  return [ETransactionVersion.V3, ETransactionVersion.F3].includes(args.version as Version);\n}\n\ntype CalcV2DeployAccountTxHashArgs = {\n  contractAddress: BigNumberish;\n  classHash: BigNumberish;\n  constructorCalldata: Calldata;\n  salt: BigNumberish;\n  version: `${ETransactionVersion2}`;\n  maxFee: BigNumberish;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n};\n\ntype CalcV3DeployAccountTxHashArgs = {\n  contractAddress: BigNumberish;\n  classHash: BigNumberish;\n  compiledConstructorCalldata: Calldata;\n  salt: BigNumberish;\n  version: `${ETransactionVersion3}`;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n  nonceDataAvailabilityMode: EDAMode;\n  feeDataAvailabilityMode: EDAMode;\n  resourceBounds: ResourceBounds;\n  tip: BigNumberish;\n  paymasterData: BigNumberish[];\n};\n\ntype CalcDeployAccountTxHashArgs = CalcV2DeployAccountTxHashArgs | CalcV3DeployAccountTxHashArgs;\n\nexport function calculateDeployAccountTransactionHash(args: CalcDeployAccountTxHashArgs) {\n  if (isV3DeployAccountTx(args)) {\n    return v3calculateDeployAccountTransactionHash(\n      args.contractAddress,\n      args.classHash,\n      args.compiledConstructorCalldata,\n      args.salt,\n      args.version,\n      args.chainId,\n      args.nonce,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n\n  return v2calculateDeployAccountTransactionHash(\n    args.contractAddress,\n    args.classHash,\n    args.constructorCalldata,\n    args.salt,\n    args.version,\n    args.maxFee,\n    args.chainId,\n    args.nonce\n  );\n}\n","/**\n * Class Hash\n */\n\nimport { poseidonHashMany } from '@scure/starknet';\n\nimport { ADDR_BOUND, API_VERSION } from '../../global/constants';\nimport {\n  BigNumberish,\n  Builtins,\n  CompiledContract,\n  CompiledSierra,\n  CompiledSierraCasm,\n  ContractEntryPointFields,\n  LegacyCompiledContract,\n  RawArgs,\n  SierraContractEntryPointFields,\n} from '../../types';\nimport { CallData } from '../calldata';\nimport { felt } from '../calldata/cairo';\nimport { starkCurve } from '../ec';\nimport { addHexPrefix, utf8ToArray } from '../encode';\nimport { parse, stringify } from '../json';\nimport { toHex } from '../num';\nimport { encodeShortString } from '../shortString';\nimport { isString } from '../typed';\n\nexport function computePedersenHash(a: BigNumberish, b: BigNumberish): string {\n  return starkCurve.pedersen(BigInt(a), BigInt(b));\n}\n\nexport function computePoseidonHash(a: BigNumberish, b: BigNumberish): string {\n  return toHex(starkCurve.poseidonHash(BigInt(a), BigInt(b)));\n}\n\n/**\n * Compute Pedersen hash from data\n *\n * @param {BigNumberish[]} data Array of data to compute Pedersen hash on\n * @returns {string} hex-string of Pedersen hash\n *\n * @example\n * ```typescript\n * const result = hash.computeHashOnElements(['0xabc', '0x123', '0xabc123'])\n * // result = 0x148141e8f7db29d005a0187669a56f0790d7e8c2c5b2d780e4d8b9e436a5521\n * ```\n */\nexport function computeHashOnElements(data: BigNumberish[]): string {\n  return [...data, data.length]\n    .reduce((x: BigNumberish, y: BigNumberish) => starkCurve.pedersen(BigInt(x), BigInt(y)), 0)\n    .toString();\n}\n\nexport const computePedersenHashOnElements = computeHashOnElements;\n\nexport function computePoseidonHashOnElements(data: BigNumberish[]) {\n  return toHex(poseidonHashMany(data.map((x) => BigInt(x))));\n}\n\n/**\n * Calculate contract address from class hash\n *\n * @param {BigNumberish} salt Salt to be used for hashing\n * @param {BigNumberish} classHash Class hash of contract to generate address for\n * @param {RawArgs} constructorCalldata Call data for contract constructor\n * @param {BigNumberish} deployerAddress Address of contract deployer\n * @returns {string} hex-string\n * @example\n * ```typescript\n * const result = hash.calculateContractAddressFromHash(1234, 0x1cf4fe5d37868d25524cdacb89518d88bf217a9240a1e6fde71cc22c429e0e3, [1234, true, false], 0x052fb1a9ab0db3c4f81d70fea6a2f6e55f57c709a46089b25eeec0e959db3695);\n * // result = 0x5fb03d3a88d8e474976932f927ff6a9e332e06ed36642ea3e8c7e38bf010f76\n * ```\n */\nexport function calculateContractAddressFromHash(\n  salt: BigNumberish,\n  classHash: BigNumberish,\n  constructorCalldata: RawArgs,\n  deployerAddress: BigNumberish\n): string {\n  const compiledCalldata = CallData.compile(constructorCalldata);\n  const constructorCalldataHash = computeHashOnElements(compiledCalldata);\n\n  const CONTRACT_ADDRESS_PREFIX = felt('0x535441524b4e45545f434f4e54524143545f41444452455353'); // Equivalent to 'STARKNET_CONTRACT_ADDRESS'\n\n  const hash = computeHashOnElements([\n    CONTRACT_ADDRESS_PREFIX,\n    deployerAddress,\n    salt,\n    classHash,\n    constructorCalldataHash,\n  ]);\n  return toHex(BigInt(hash) % ADDR_BOUND);\n}\n\nfunction nullSkipReplacer(key: string, value: any) {\n  if (key === 'attributes' || key === 'accessible_scopes') {\n    return Array.isArray(value) && value.length === 0 ? undefined : value;\n  }\n\n  if (key === 'debug_info') {\n    return null;\n  }\n\n  return value === null ? undefined : value;\n}\n\n/**\n * Format json-string without spaces to conform starknet json-string\n * @param {string} json json-string without spaces\n * @returns {string} json-string with additional spaces after `:` and `,`\n * @example\n * ```typescript\n * const result = hash.formatSpaces(\"{'onchain':true,'isStarknet':true}\");\n * // result = \"{'onchain': true, 'isStarknet': true}\"\n * ```\n */\nexport function formatSpaces(json: string): string {\n  let insideQuotes = false;\n  const newString = [];\n  // eslint-disable-next-line no-restricted-syntax\n  for (const char of json) {\n    if (char === '\"' && (newString.length > 0 && newString.slice(-1)[0] === '\\\\') === false) {\n      insideQuotes = !insideQuotes;\n    }\n    if (insideQuotes) {\n      newString.push(char);\n    } else {\n      // eslint-disable-next-line no-nested-ternary\n      newString.push(char === ':' ? ': ' : char === ',' ? ', ' : char);\n    }\n  }\n  return newString.join('');\n}\n\n/**\n * Compute hinted class hash for legacy compiled contract (Cairo 0)\n * @param {LegacyCompiledContract} compiledContract\n * @returns {string} hex-string\n * @example\n * ```typescript\n * const compiledCairo0 = json.parse(fs.readFileSync(\"./cairo0contract.json\").toString(\"ascii\"));\n * const result=hash.computeHintedClassHash(compiledCairo0);\n * // result = \"0x293eabb06955c0a1e55557014675aa4e7a1fd69896147382b29b2b6b166a2ac\"\n * ``` */\nexport function computeHintedClassHash(compiledContract: LegacyCompiledContract): string {\n  const { abi, program } = compiledContract;\n  const contractClass = { abi, program };\n  const serializedJson = formatSpaces(stringify(contractClass, nullSkipReplacer));\n  return addHexPrefix(starkCurve.keccak(utf8ToArray(serializedJson)).toString(16));\n}\n\n/**\n * Computes the class hash for legacy compiled contract (Cairo 0)\n * @param {LegacyCompiledContract | string} contract legacy compiled contract content\n * @returns {string} hex-string of class hash\n * @example\n * ```typescript\n * const compiledCairo0 = json.parse(fs.readFileSync(\"./cairo0contract.json\").toString(\"ascii\"));\n * const result=hash.computeLegacyContractClassHash(compiledCairo0);\n * // result = \"0x4a5cae61fa8312b0a3d0c44658b403d3e4197be80027fd5020ffcdf0c803331\"\n * ```\n */\nexport function computeLegacyContractClassHash(contract: LegacyCompiledContract | string): string {\n  const compiledContract = isString(contract)\n    ? (parse(contract) as LegacyCompiledContract)\n    : contract;\n\n  const apiVersion = toHex(API_VERSION);\n\n  const externalEntryPointsHash = computeHashOnElements(\n    compiledContract.entry_points_by_type.EXTERNAL.flatMap((e) => [e.selector, e.offset])\n  );\n\n  const l1HandlerEntryPointsHash = computeHashOnElements(\n    compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e) => [e.selector, e.offset])\n  );\n\n  const constructorEntryPointHash = computeHashOnElements(\n    compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e) => [e.selector, e.offset])\n  );\n\n  const builtinsHash = computeHashOnElements(\n    compiledContract.program.builtins.map((s) => encodeShortString(s))\n  );\n\n  const hintedClassHash = computeHintedClassHash(compiledContract);\n\n  const dataHash = computeHashOnElements(compiledContract.program.data);\n\n  return computeHashOnElements([\n    apiVersion,\n    externalEntryPointsHash,\n    l1HandlerEntryPointsHash,\n    constructorEntryPointHash,\n    builtinsHash,\n    hintedClassHash,\n    dataHash,\n  ]);\n}\n\n// Cairo 1 Contract Hashes\n\nfunction hashBuiltins(builtins: Builtins) {\n  return poseidonHashMany(\n    builtins.flatMap((it: any) => {\n      return BigInt(encodeShortString(it));\n    })\n  );\n}\n\nfunction hashEntryPoint(data: ContractEntryPointFields[]) {\n  const base = data.flatMap((it: any) => {\n    return [BigInt(it.selector), BigInt(it.offset), hashBuiltins(it.builtins)];\n  });\n  return poseidonHashMany(base);\n}\n\n/**\n * Compute hash of the bytecode for Sierra v1.5.0 onwards (Cairo 2.6.0)\n * Each segment is Poseidon hashed.\n * The global hash is : 1 + PoseidonHash(len0, h0, len1, h1, ...)\n * @param {CompiledSierraCasm} casm compiled Sierra CASM file content.\n * @returns {bigint} the bytecode hash as bigint.\n * @example\n * ```typescript\n * const compiledCasm = json.parse(fs.readFileSync(\"./contractC260.casm.json\").toString(\"ascii\"));\n * const result = hash.hashByteCodeSegments(compiledCasm);\n * // result = 80499149343908132326491548897246987792410240503053732367044713070598981699n\n * ```\n */\nexport function hashByteCodeSegments(casm: CompiledSierraCasm): bigint {\n  const byteCode: bigint[] = casm.bytecode.map((n) => BigInt(n));\n  const bytecodeSegmentLengths: number[] = casm.bytecode_segment_lengths ?? [];\n  let segmentStart = 0;\n  const hashLeaves = bytecodeSegmentLengths.flatMap((len) => {\n    const segment = byteCode.slice(segmentStart, (segmentStart += len));\n    return [BigInt(len), poseidonHashMany(segment)];\n  });\n  return 1n + poseidonHashMany(hashLeaves);\n}\n\n/**\n * Compute compiled class hash for contract (Cairo 1)\n * @param {CompiledSierraCasm} casm Cairo 1 compiled contract content\n * @returns {string} hex-string of class hash\n * @example\n * ```typescript\n * const compiledCasm = json.parse(fs.readFileSync(\"./cairo260.casm.json\").toString(\"ascii\"));\n * const result = hash.computeCompiledClassHash(compiledCasm);\n * // result = \"0x4087905743b4fa2b3affc1fc71333f1390c8c5d1e8ea47d6ba70786de3fc01a\"\n```\n */\nexport function computeCompiledClassHash(casm: CompiledSierraCasm): string {\n  const COMPILED_CLASS_VERSION = 'COMPILED_CLASS_V1';\n\n  // Hash compiled class version\n  const compiledClassVersion = BigInt(encodeShortString(COMPILED_CLASS_VERSION));\n\n  // Hash external entry points.\n  const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);\n\n  // Hash L1 handler entry points.\n  const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);\n\n  // Hash constructor entry points.\n  const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);\n\n  // Hash bytecode.\n  const bytecode = casm.bytecode_segment_lengths\n    ? hashByteCodeSegments(casm)\n    : poseidonHashMany(casm.bytecode.map((it: string) => BigInt(it)));\n\n  return toHex(\n    poseidonHashMany([\n      compiledClassVersion,\n      externalEntryPointsHash,\n      l1Handlers,\n      constructor,\n      bytecode,\n    ])\n  );\n}\n\nfunction hashEntryPointSierra(data: SierraContractEntryPointFields[]) {\n  const base = data.flatMap((it: any) => {\n    return [BigInt(it.selector), BigInt(it.function_idx)];\n  });\n  return poseidonHashMany(base);\n}\n\nfunction hashAbi(sierra: CompiledSierra) {\n  const indentString = formatSpaces(stringify(sierra.abi, null));\n  return BigInt(addHexPrefix(starkCurve.keccak(utf8ToArray(indentString)).toString(16)));\n}\n\n/**\n * Compute sierra contract class hash (Cairo 1)\n * @param {CompiledSierra} sierra Cairo 1 Sierra contract content\n * @returns {string} hex-string of class hash\n * @example\n * ```typescript\n * const compiledSierra = json.parse(fs.readFileSync(\"./cairo260.sierra.json\").toString(\"ascii\"));\n * const result = hash.computeSierraContractClassHash(compiledSierra);\n * // result = \"0x67b6b4f02baded46f02feeed58c4f78e26c55364e59874d8abfd3532d85f1ba\"\n```\n */\nexport function computeSierraContractClassHash(sierra: CompiledSierra): string {\n  const CONTRACT_CLASS_VERSION = 'CONTRACT_CLASS_V0.1.0';\n\n  // Hash class version\n  const compiledClassVersion = BigInt(encodeShortString(CONTRACT_CLASS_VERSION));\n\n  // Hash external entry points.\n  const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);\n\n  // Hash L1 handler entry points.\n  const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);\n\n  // Hash constructor entry points.\n  const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);\n\n  // Hash abi_hash.\n  const abiHash = hashAbi(sierra);\n\n  // Hash Sierra program.\n  const sierraProgram = poseidonHashMany(sierra.sierra_program.map((it: string) => BigInt(it)));\n\n  return toHex(\n    poseidonHashMany([\n      compiledClassVersion,\n      externalEntryPointsHash,\n      l1Handlers,\n      constructor,\n      abiHash,\n      sierraProgram,\n    ])\n  );\n}\n\n/**\n * Compute ClassHash (sierra or legacy) based on provided contract\n * @param {CompiledContract | string} contract Cairo 1 contract content\n * @returns {string} hex-string of class hash\n * @example\n * ```typescript\n * const compiledSierra = json.parse(fs.readFileSync(\"./cairo260.sierra.json\").toString(\"ascii\"));\n * const result = hash.computeContractClassHash(compiledSierra);\n * // result = \"0x67b6b4f02baded46f02feeed58c4f78e26c55364e59874d8abfd3532d85f1ba\"\n```\n */\nexport function computeContractClassHash(contract: CompiledContract | string): string {\n  const compiledContract = isString(contract) ? parse(contract) : contract;\n\n  if ('sierra_program' in compiledContract) {\n    return computeSierraContractClassHash(compiledContract as CompiledSierra);\n  }\n\n  return computeLegacyContractClassHash(compiledContract as LegacyCompiledContract);\n}\n","import { getPublicKey, getStarkKey, utils } from '@scure/starknet';\nimport { gzip, ungzip } from 'pako';\n\nimport { ZERO, FeeMarginPercentage } from '../global/constants';\nimport {\n  ArraySignatureType,\n  BigNumberish,\n  CompressedProgram,\n  Program,\n  Signature,\n  UniversalDetails,\n} from '../types';\nimport { EDAMode, EDataAvailabilityMode, ETransactionVersion, ResourceBounds } from '../types/api';\nimport { FeeEstimate } from '../types/provider';\nimport { addHexPrefix, arrayBufferToString, atobUniversal, btoaUniversal, buf2hex } from './encode';\nimport { parse, stringify } from './json';\nimport {\n  addPercent,\n  bigNumberishArrayToDecimalStringArray,\n  bigNumberishArrayToHexadecimalStringArray,\n  toHex,\n} from './num';\nimport { isUndefined, isString, isBigInt } from './typed';\n\ntype V3Details = Required<\n  Pick<\n    UniversalDetails,\n    | 'tip'\n    | 'paymasterData'\n    | 'accountDeploymentData'\n    | 'nonceDataAvailabilityMode'\n    | 'feeDataAvailabilityMode'\n    | 'resourceBounds'\n  >\n>;\n\n/**\n * Compress compiled Cairo 0 program\n *\n * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/services/api/gateway/transaction.py#L54-L58)\n * @param {Program | string} jsonProgram Representing the compiled Cairo 0 program\n * @return {CompressedProgram} Compressed Cairo 0 program\n * @example\n * ```typescript\n * const contractCairo0 = json.parse(fs.readFileSync(\"./cairo0contract.json\").toString(\"ascii\"));\n * const result = stark.compressProgram(contractCairo0);\n * // result = \"H4sIAAAAAAAAA+1dC4/bOJL+K4aBu01me7r5EEUyixzQk/TuB...\"\n * ```\n */\nexport function compressProgram(jsonProgram: Program | string): CompressedProgram {\n  const stringified = isString(jsonProgram) ? jsonProgram : stringify(jsonProgram);\n  const compressedProgram = gzip(stringified);\n  return btoaUniversal(compressedProgram);\n}\n\n/**\n * Decompress compressed compiled Cairo 0 program\n * @param {CompressedProgram | CompressedProgram[]} base64 Compressed Cairo 0 program\n * @returns Parsed decompressed compiled Cairo 0 program\n * @example\n * ```typescript\n * const contractCairo0 = json.parse(fs.readFileSync(\"./cairo0contract.json\").toString(\"ascii\"));\n * const compressedCairo0 = stark.compressProgram(contractCairo0);\n * const result = stark.decompressProgram(compressedCairo0);\n * // result = {\n * //   abi: [\n * //     {\n * //       inputs: [Array],\n * //       name: 'increase_balance',\n * //       outputs: [],\n * //       type: 'function'\n * //     }\n * //   ],\n * //   entry_points_by_type: { CONSTRUCTOR: [], EXTERNAL: [ [Object], [Object] ], L1_HANDLER: [] },\n * //   program: {\n * //     attributes: [],\n * //     builtins: [ 'pedersen', 'range_check' ],\n * //     compiler_version: '0.10.2',\n * //     data: [\n * //       '0x480680017fff8000',\n * // ...\n * ```\n */\nexport function decompressProgram(base64: CompressedProgram | CompressedProgram[]) {\n  if (Array.isArray(base64)) return base64;\n  const decompressed = arrayBufferToString(ungzip(atobUniversal(base64)));\n  return parse(decompressed);\n}\n\n/**\n * Random Address based on random keyPair\n * @returns {string} an hex string of a random Starknet address\n * @example\n * ```typescript\n * const result = stark.randomAddress();\n * // result = \"0x51fc8126a13cd5ddb29a71ca399cb1e814f086f5af1b502d7151c14929554f\"\n * ```\n */\nexport function randomAddress(): string {\n  const randomKeyPair = utils.randomPrivateKey();\n  return getStarkKey(randomKeyPair);\n}\n\n/**\n * Lowercase and hex prefix string\n *\n * @deprecated Not used internally, naming is confusing based on functionality\n */\nexport function makeAddress(input: string): string {\n  return addHexPrefix(input).toLowerCase();\n}\n\n/**\n * Format Signature to standard type (hex array)\n * @param {Signature} [sig]\n * @returns {ArraySignatureType} Custom hex string array\n * @throws {Error} if sig not defined, or wrong format\n * @example\n * ```typescript\n * const signature = ec.starkCurve.sign(\"0x12de34\", \"0x3487123eac\");\n * const result = stark.formatSignature(signature);\n * // result = ['0xba8eecee2d69c417e8c6a20cf331c821f716b58ba9e47166c7476afdb38997',\n * //  '0x69ef7438c94104839a6e2aa2385482a77399d2f46e894ae4f50ab6d69239d1c']\n * ```\n */\nexport function formatSignature(sig?: Signature): ArraySignatureType {\n  if (!sig) throw Error('formatSignature: provided signature is undefined');\n  if (Array.isArray(sig)) {\n    return sig.map((it) => toHex(it));\n  }\n  try {\n    const { r, s } = sig;\n    return [toHex(r), toHex(s)];\n  } catch (e) {\n    throw new Error('Signature need to be weierstrass.SignatureType or an array for custom');\n  }\n}\n\n/**\n * Format Signature to decimal string array\n * @param {Signature} [sig]\n * @returns {ArraySignatureType} Custom hex string array\n * @throws {Error} if sig not defined, or wrong format\n * @example\n * ```typescript\n * const signature = ec.starkCurve.sign(\"0x12de34\", \"0x3487123eac\");\n * const result = stark.signatureToDecimalArray(signature);\n * // result = ['329619989660444495690615805546674399714973829707166906185976654753023887767',\n * //  '2994745480203297689255012826403147585778741462125743754529207781488706428188']\n * ```\n */\nexport function signatureToDecimalArray(sig?: Signature): ArraySignatureType {\n  return bigNumberishArrayToDecimalStringArray(formatSignature(sig));\n}\n\n/**\n * Format Signature to hex string array\n * @param {Signature} [sig]\n * @returns {ArraySignatureType} Custom hex string array\n * @throws {Error} if sig not defined, or wrong format\n * @example\n * ```typescript\n * const signature = ec.starkCurve.sign(\"0x12de34\", \"0x3487123eac\");\n * const result = stark.signatureToHexArray(signature);\n * // result = ['0xba8eecee2d69c417e8c6a20cf331c821f716b58ba9e47166c7476afdb38997',\n * //  '0x69ef7438c94104839a6e2aa2385482a77399d2f46e894ae4f50ab6d69239d1c']\n * ```\n */\nexport function signatureToHexArray(sig?: Signature): ArraySignatureType {\n  return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));\n}\n\n/**\n * Convert estimated fee to max fee including a margin\n * @param {BigNumberish} estimatedFee - The estimated fee\n * @param {number} [overhead = feeMarginPercentage.MAX_FEE] - The overhead added to the gas\n * @returns {bigint} The maximum fee with the margin\n * @example\n * ```typescript\n * const result = stark.estimatedFeeToMaxFee(\"8982300000000\", 50);\n * // result = \"13473450000000n\"\n * ```\n */\nexport function estimatedFeeToMaxFee(\n  estimatedFee: BigNumberish,\n  overhead: number = FeeMarginPercentage.MAX_FEE\n): bigint {\n  return addPercent(estimatedFee, overhead);\n}\n\n/**\n * Calculates the maximum resource bounds for fee estimation.\n *\n * @param {FeeEstimate | 0n} estimate The estimate for the fee. If a BigInt is provided, the returned bounds will be set to '0x0'.\n * @param {number} [amountOverhead = feeMarginPercentage.L1_BOUND_MAX_AMOUNT] - The percentage overhead added to the gas consumed or overall fee amount.\n * @param {number} [priceOverhead = feeMarginPercentage.L1_BOUND_MAX_PRICE_PER_UNIT] The percentage overhead added to the gas price per unit.\n * @returns {ResourceBounds} The maximum resource bounds for fee estimation.\n * @throws {Error} If the estimate object is undefined or does not have the required properties.\n * @example\n * ```typescript\n * const feeEstimated: FeeEstimate = {\n  gas_consumed: \"0x3456a\",\n  gas_price: \"0xa45567567567ae4\",\n  overall_fee: \"0x2198F463A77A899A5668\",\n  unit: \"WEI\"\n};\nconst result = stark.estimateFeeToBounds(feeEstimated, 70, 50);\n * // result = {\n * //   l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n * //   l1_gas: { max_amount: '0x58f9a', max_price_per_unit: '0xf6801b01b01b856' }\n * // }\n * ```\n */\nexport function estimateFeeToBounds(\n  estimate: FeeEstimate | 0n,\n  amountOverhead: number = FeeMarginPercentage.L1_BOUND_MAX_AMOUNT,\n  priceOverhead: number = FeeMarginPercentage.L1_BOUND_MAX_PRICE_PER_UNIT\n): ResourceBounds {\n  if (isBigInt(estimate)) {\n    return {\n      l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n      l1_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n    };\n  }\n\n  if (isUndefined(estimate.gas_consumed) || isUndefined(estimate.gas_price)) {\n    throw Error('estimateFeeToBounds: estimate is undefined');\n  }\n\n  const maxUnits =\n    estimate.data_gas_consumed !== undefined && estimate.data_gas_price !== undefined // RPC v0.7\n      ? toHex(addPercent(BigInt(estimate.overall_fee) / BigInt(estimate.gas_price), amountOverhead))\n      : toHex(addPercent(estimate.gas_consumed, amountOverhead));\n  const maxUnitPrice = toHex(addPercent(estimate.gas_price, priceOverhead));\n  return {\n    l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n    l1_gas: { max_amount: maxUnits, max_price_per_unit: maxUnitPrice },\n  };\n}\n\n/**\n * Converts the data availability mode from EDataAvailabilityMode to EDAMode.\n *\n * @param {EDataAvailabilityMode} dam The data availability mode to be converted.\n * @return {EDAMode} The converted data availability mode.\n * @throws {Error} If the data availability mode is not a valid value.\n * @example\n * ```typescript\n * const result = stark.intDAM(RPC.EDataAvailabilityMode.L1);\n * // result = 0\n * ```\n */\nexport function intDAM(dam: EDataAvailabilityMode): EDAMode {\n  if (dam === EDataAvailabilityMode.L1) return EDAMode.L1;\n  if (dam === EDataAvailabilityMode.L2) return EDAMode.L2;\n  throw Error('EDAM conversion');\n}\n\n/**\n * Convert to ETransactionVersion or throw an error.\n * Return providedVersion is specified else return defaultVersion\n * @param {BigNumberish} defaultVersion default estimate transaction version\n * @param {BigNumberish} [providedVersion] estimate transaction version\n * @returns {ETransactionVersion} if providedVersion is not provided, returns the default estimate version, else return the provided version\n * @throws {Error} if estimate transaction version or default estimate transaction version is unknown\n * @example\n * ```typescript\n * const result = stark.toTransactionVersion(\"0x100000000000000000000000000000003\", stark.toFeeVersion(2));\n * // result = \"0x100000000000000000000000000000002\"\n * ```\n */\nexport function toTransactionVersion(\n  defaultVersion: BigNumberish,\n  providedVersion?: BigNumberish\n): ETransactionVersion {\n  const providedVersion0xs = providedVersion ? toHex(providedVersion) : undefined;\n  const defaultVersion0xs = toHex(defaultVersion);\n\n  if (providedVersion && !Object.values(ETransactionVersion).includes(providedVersion0xs as any)) {\n    throw Error(`providedVersion ${providedVersion} is not ETransactionVersion`);\n  }\n  if (!Object.values(ETransactionVersion).includes(defaultVersion0xs as any)) {\n    throw Error(`defaultVersion ${defaultVersion} is not ETransactionVersion`);\n  }\n\n  return (providedVersion ? providedVersion0xs : defaultVersion0xs) as ETransactionVersion;\n}\n\n/**\n * Convert Transaction version to Fee version or throw an error\n * @param {BigNumberish} [providedVersion] 0..3 number representing the transaction version\n * @returns {ETransactionVersion | undefined} the fee estimation version corresponding to the transaction version provided\n * @throws {Error} if the transaction version is unknown\n * @example\n * ```typescript\n * const result = stark.toFeeVersion(2);\n * // result = \"0x100000000000000000000000000000002\"\n * ```\n */\nexport function toFeeVersion(providedVersion?: BigNumberish): ETransactionVersion | undefined {\n  if (!providedVersion) return undefined;\n  const version = toHex(providedVersion);\n\n  if (version === ETransactionVersion.V0) return ETransactionVersion.F0;\n  if (version === ETransactionVersion.V1) return ETransactionVersion.F1;\n  if (version === ETransactionVersion.V2) return ETransactionVersion.F2;\n  if (version === ETransactionVersion.V3) return ETransactionVersion.F3;\n\n  throw Error(`toFeeVersion: ${version} is not supported`);\n}\n\n/**\n * Return provided or default v3 tx details\n * @param {UniversalDetails} details details of the transaction\n * @return {V3Details} an object including the V3 transaction details.\n * @example\n * ```typescript\n * const detail: UniversalDetails = { tip: 3456n };\n * const result = stark.v3Details(detail);\n * // result = {\n * //   tip: 3456n,\n * //   paymasterData: [],\n * //   accountDeploymentData: [],\n * //   nonceDataAvailabilityMode: 'L1',\n * //   feeDataAvailabilityMode: 'L1',\n * //   resourceBounds: {\n * //     l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n * //     l1_gas: { max_amount: '0x0', max_price_per_unit: '0x0' }\n * //   }\n * // }\n * ```\n */\n\nexport function v3Details(details: UniversalDetails): V3Details {\n  return {\n    tip: details.tip || 0,\n    paymasterData: details.paymasterData || [],\n    accountDeploymentData: details.accountDeploymentData || [],\n    nonceDataAvailabilityMode: details.nonceDataAvailabilityMode || EDataAvailabilityMode.L1,\n    feeDataAvailabilityMode: details.feeDataAvailabilityMode || EDataAvailabilityMode.L1,\n    resourceBounds: details.resourceBounds ?? estimateFeeToBounds(ZERO),\n  };\n}\n\n/**\n * It will reduce V2 to V1, else (V3) stay the same\n * F2 -> F1\n * V2 -> V1\n * F3 -> F3\n * V3 -> V3\n * @param {ETransactionVersion} providedVersion\n * @returns {ETransactionVersion} if v2 then returns v1. if v3 then return v3\n * @example\n * ```typescript\n * const result = stark.reduceV2(constants.TRANSACTION_VERSION.V2);\n * // result = \"0x1\"\n * ```\n */\nexport function reduceV2(providedVersion: ETransactionVersion): ETransactionVersion {\n  if (providedVersion === ETransactionVersion.F2) return ETransactionVersion.F1;\n  if (providedVersion === ETransactionVersion.V2) return ETransactionVersion.V1;\n  return providedVersion;\n}\n\n/**\n * get the hex string of the full public key related to a Starknet private key.\n * @param {BigNumberish} privateKey a 252 bits private key.\n * @returns {string} an hex string of a 520 bit number, representing the full public key related to `privateKey`.\n * @example\n * ```typescript\n * const result = ec.getFullPublicKey(\"0x43b7240d227aa2fb8434350b3321c40ac1b88c7067982549e7609870621b535\");\n * // result = \"0x0400b730bd22358612b5a67f8ad52ce80f9e8e893639ade263537e6ef35852e5d3057795f6b090f7c6985ee143f798608a53b3659222c06693c630857a10a92acf\"\n * ```\n */\nexport function getFullPublicKey(privateKey: BigNumberish): string {\n  const privKey = toHex(privateKey);\n  const fullPrivKey = addHexPrefix(buf2hex(getPublicKey(privKey, false)));\n  return fullPrivKey;\n}\n","import { ContractClassResponse } from '../types';\nimport {\n  CairoContract,\n  CompiledSierra,\n  LegacyCompiledContract,\n  LegacyContractClass,\n  SierraContractClass,\n} from '../types/lib/contract/index';\nimport { CompleteDeclareContractPayload, DeclareContractPayload } from '../types/lib/index';\nimport { computeCompiledClassHash, computeContractClassHash } from './hash';\nimport { parse } from './json';\nimport { decompressProgram } from './stark';\nimport { isString } from './typed';\n\n/**\n * Checks if a given contract is in Sierra (Safe Intermediate Representation) format.\n *\n * @param {CairoContract | string} contract - The contract to check. Can be either a CairoContract object or a string representation of the contract.\n * @return {boolean} - Returns true if the contract is a Sierra contract, otherwise false.\n * @example\n * ```typescript\n * const result = isSierra(contract);\n * // result = true | false\n * ```\n */\nexport function isSierra(\n  contract: CairoContract | string\n): contract is SierraContractClass | CompiledSierra {\n  const compiledContract = isString(contract) ? parse(contract) : contract;\n  return 'sierra_program' in compiledContract;\n}\n\n/**\n * Extracts contract hashes from `DeclareContractPayload`.\n *\n * @param {DeclareContractPayload} payload - The payload containing contract information.\n * @return {CompleteDeclareContractPayload} - The `CompleteDeclareContractPayload` with extracted contract hashes.\n * @throws {Error} - If extraction of compiledClassHash or classHash fails.\n * @example\n * ```typescript\n * const result = extractContractHashes(contract);\n * // result = {\n * //   contract: ...,\n * //   classHash: ...,\n * //   casm: ...,\n * //   compiledClassHash: ...,\n * // }\n * ```\n */\nexport function extractContractHashes(\n  payload: DeclareContractPayload\n): CompleteDeclareContractPayload {\n  const response = { ...payload } as CompleteDeclareContractPayload;\n\n  if (isSierra(payload.contract)) {\n    if (!payload.compiledClassHash && payload.casm) {\n      response.compiledClassHash = computeCompiledClassHash(payload.casm);\n    }\n    if (!response.compiledClassHash)\n      throw new Error(\n        'Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash'\n      );\n  }\n\n  response.classHash = payload.classHash ?? computeContractClassHash(payload.contract);\n  if (!response.classHash)\n    throw new Error('Extract classHash failed, provide (CompiledContract).json file or classHash');\n\n  return response;\n}\n\n/**\n * Helper to redeclare response Cairo0 contract\n */\nexport function contractClassResponseToLegacyCompiledContract(ccr: ContractClassResponse) {\n  if (isSierra(ccr)) {\n    throw Error('ContractClassResponse need to be LegacyContractClass (cairo0 response class)');\n  }\n  const contract = ccr as LegacyContractClass;\n  return { ...contract, program: decompressProgram(contract.program) } as LegacyCompiledContract;\n}\n","import { secp256k1 } from '@noble/curves/secp256k1';\n\nimport { addHexPrefix, buf2hex, removeHexPrefix, sanitizeHex } from './encode';\nimport type { BigNumberish } from '../types';\nimport { assertInRange, toHex } from './num';\nimport { ZERO } from '../global/constants';\nimport assert from './assert';\n\n/**\n * Get random Ethereum private Key.\n * @returns an Hex string\n * @example\n * ```typescript\n * const myPK: string = randomAddress()\n * // result = \"0xf04e69ac152fba37c02929c2ae78c9a481461dda42dbc6c6e286be6eb2a8ab83\"\n * ```\n */\nexport function ethRandomPrivateKey(): string {\n  return sanitizeHex(buf2hex(secp256k1.utils.randomPrivateKey()));\n}\n\n/**\n * Get a string formatted for an Ethereum address, without uppercase characters.\n * @param {BigNumberish} address Address of an Ethereum account.\n * @returns an Hex string coded on 20 bytes\n * @example\n * ```typescript\n * const myEthAddress: string = validateAndParseEthAddress(\"0x8359E4B0152ed5A731162D3c7B0D8D56edB165\")\n * // result = \"0x008359e4b0152ed5a731162d3c7b0d8d56edb165\"\n * ```\n */\nexport function validateAndParseEthAddress(address: BigNumberish): string {\n  assertInRange(address, ZERO, 2n ** 160n - 1n, 'Ethereum Address ');\n  const result = addHexPrefix(removeHexPrefix(toHex(address)).padStart(40, '0'));\n  assert(Boolean(result.match(/^(0x)?[0-9a-f]{40}$/)), 'Invalid Ethereum Address Format');\n  return result;\n}\n","// the ts-ignore suppresses an esm to cjs import error that is resolved with entry point resolution\n// @ts-ignore\nimport makeFetchCookie from 'fetch-cookie';\nimport isomorphicFetch from 'isomorphic-fetch';\nimport { IS_BROWSER } from './encode';\nimport { isUndefined } from './typed';\n\nexport default (IS_BROWSER && window.fetch.bind(window)) || // use built-in fetch in browser if available\n  (!isUndefined(global) && makeFetchCookie(global.fetch)) || // use built-in fetch in node, react-native and service worker if available\n  isomorphicFetch; // ponyfill fetch in node and browsers that don't have it\n","import { NetworkName, RPC_NODES } from '../global/constants';\nimport {\n  BlockIdentifier,\n  BlockTag,\n  CompiledContract,\n  CompiledSierra,\n  ContractClass,\n  GetBlockResponse,\n  InvocationsDetailsWithNonce,\n  LegacyContractClass,\n  PendingBlock,\n  PendingStateUpdate,\n  SierraContractClass,\n  StateUpdateResponse,\n  V3TransactionDetails,\n} from '../types';\nimport { ETransactionVersion } from '../types/api';\nimport { isSierra } from './contract';\nimport { formatSpaces } from './hash';\nimport { parse, stringify } from './json';\nimport { isHex, toHex } from './num';\nimport { isDecimalString } from './shortString';\nimport { isBigInt, isNumber, isString } from './typed';\nimport { compressProgram } from './stark';\nimport type { GetTransactionReceiptResponse } from './transactionReceipt';\nimport { logger } from '../global/logger';\n\n/**\n * Helper - Async Sleep for 'delay' time\n *\n * @param {number} delay - Number of milliseconds to delay\n * @returns {Promise<unknown>}\n * @example\n * ```typescript\n * await provider.wait(1000) // 1000 milliseconds == 1 second\n * ```\n */\nexport function wait(delay: number): Promise<unknown> {\n  return new Promise((res) => {\n    setTimeout(res, delay);\n  });\n}\n\n/**\n * Create Sierra compressed Contract Class from a given Compiled Sierra\n *\n * CompiledSierra -> SierraContractClass\n *\n * @param {CompiledSierra} contract sierra code from the Cairo compiler\n * @returns {SierraContractClass} compressed Sierra\n * @example\n * ```typescript\n * const result = provider.createSierraContractClass({\n    \"sierra_program\": [\n        \"0x1\",\n        \"0x4\",\n        \"0x0\",\n        \"0x2\",\n        \"0x4\",\n        \"0x1\",\n        \"0x3b4\",\n        \"0x4c\",\n        \"0x65\",\n        \"0x52616e6765436865636b\",...})\n * // result = {sierra_program: 'H4sIAAAAAAAAA6x9WZbsrI7uVGqd53qgb8ZynwzYY7jDv5JAAmxHZuQ+96yq/L0jIzEINZ8axP/5j/q/+j//+z/wH9f/o/p/zPbh+Iot49+u9v8G3//rTdDhDDF4Z0MKPthQ+m+S2v6n1S//638VvdXW2PQ6RvxuDG+jiybCXKJ7Hef6ZRi9E+Q89WmKLilfqbrsL6PUCf8...}\n * ```\n */\nexport function createSierraContractClass(contract: CompiledSierra): SierraContractClass {\n  const result = { ...contract } as any;\n  delete result.sierra_program_debug_info;\n  result.abi = formatSpaces(stringify(contract.abi));\n  result.sierra_program = formatSpaces(stringify(contract.sierra_program));\n  result.sierra_program = compressProgram(result.sierra_program);\n  return result;\n}\n\n/**\n * Create a compressed contract from a given compiled Cairo 0 & 1 contract or a string.\n * @param {CompiledContract | string} contract - Compiled Cairo 0 or Cairo 1 contract, or string\n * @returns {ContractClass} Cairo 0 or Cairo 1 compressed contract\n * @example\n * ```typescript\n * const result = provider.parseContract({\n    \"sierra_program\": [\n        \"0x1\",\n        \"0x4\",\n        \"0x0\",\n        \"0x2\",\n        \"0x4\",\n        \"0x1\",\n        \"0x3b4\",\n        \"0x4c\",\n        \"0x65\",\n        \"0x52616e6765436865636b\",...})\n * // result = {sierra_program: 'H4sIAAAAAAAAA6x9WZbsrI7uVGqd53qgb8ZynwzYY7jDv5JAAmxHZuQ+96yq/L0jIzEINZ8axP/5j/q/+j//+z/wH9f/o/p/zPbh+Iot49+u9v8G3//rTdDhDDF4Z0MKPthQ+m+S2v6n1S//638VvdXW2PQ6RvxuDG+jiybCXKJ7Hef6ZRi9E+Q89WmKLilfqbrsL6PUCf8...}\n * ```\n */\nexport function parseContract(contract: CompiledContract | string): ContractClass {\n  const parsedContract = isString(contract) ? (parse(contract) as CompiledContract) : contract;\n\n  if (!isSierra(contract)) {\n    return {\n      ...parsedContract,\n      ...('program' in parsedContract && { program: compressProgram(parsedContract.program) }),\n    } as LegacyContractClass;\n  }\n\n  return createSierraContractClass(parsedContract as CompiledSierra);\n}\n\n/**\n * Return randomly select available public node\n * @param {NetworkName} networkName NetworkName\n * @param {boolean} mute mute public node warning\n * @returns {string} default node url\n * @example\n * ```typescript\n * const result= provider.getDefaultNodeUrl(constants.NetworkName.SN_MAIN,false);\n * // console : \"Using default public node url, please provide nodeUrl in provider options!\"\n * // result = \"https://starknet-mainnet.public.blastapi.io/rpc/v0_7\"\n * ```\n */\nexport const getDefaultNodeUrl = (networkName?: NetworkName, mute: boolean = false): string => {\n  if (!mute) {\n    logger.info('Using default public node url, please provide nodeUrl in provider options!');\n  }\n  const nodes = RPC_NODES[networkName ?? NetworkName.SN_SEPOLIA];\n  const randIdx = Math.floor(Math.random() * nodes.length);\n  return nodes[randIdx];\n};\n\nexport const validBlockTags = Object.values(BlockTag);\n\n/**\n * This class is formatting the identifier of a block.\n *\n * hex string and BigInt are detected as block hashes. identifier return { block_hash: hash }\n *\n * decimal string and number are detected as block numbers. identifier return { block_number: number }\n *\n * text string are detected as block tag. identifier return tag\n *\n * null is detected as 'pending' block tag. identifier return 'pending'\n * @example\n * ```typescript\n * const result = new provider.Block(null).identifier;\n * // result = \"pending\"\n * ```\n */\nexport class Block {\n  /**\n   * @param {BlockIdentifier} hash if not null, contains the block hash\n   */\n  hash: BlockIdentifier = null;\n\n  /**\n   * @param {BlockIdentifier} number if not null, contains the block number\n   */\n  number: BlockIdentifier = null;\n\n  /**\n   * @param {BlockIdentifier} tag if not null, contains \"pending\" or \"latest\"\n   */\n  tag: BlockIdentifier = null;\n\n  private setIdentifier(__identifier: BlockIdentifier): void {\n    if (isString(__identifier)) {\n      if (isDecimalString(__identifier)) {\n        this.number = parseInt(__identifier, 10);\n      } else if (isHex(__identifier)) {\n        this.hash = __identifier;\n      } else if (validBlockTags.includes(__identifier as BlockTag)) {\n        this.tag = __identifier;\n      } else {\n        throw TypeError(`Block identifier unmanaged: ${__identifier}`);\n      }\n    } else if (isBigInt(__identifier)) {\n      this.hash = toHex(__identifier);\n    } else if (isNumber(__identifier)) {\n      this.number = __identifier;\n    } else {\n      this.tag = BlockTag.PENDING;\n    }\n\n    if (isNumber(this.number) && this.number < 0) {\n      throw TypeError(`Block number (${this.number}) can't be negative`);\n    }\n  }\n\n  /**\n   * Create a Block instance\n   * @param {BlockIdentifier} _identifier  hex string and BigInt are detected as block hashes.\n   * decimal string and number are detected as block numbers.\n   * text string are detected as block tag.\n   * null is considered as a 'pending' block tag.\n   */\n  constructor(_identifier: BlockIdentifier) {\n    this.setIdentifier(_identifier);\n  }\n\n  // TODO: fix any\n  /**\n   * @returns {any} the identifier as a string\n   * @example\n   * ```typescript\n   * const result = new provider.Block(123456n).queryIdentifier;\n   * // result = \"blockHash=0x1e240\"\n   * ```\n   */\n  get queryIdentifier(): any {\n    if (this.number !== null) {\n      return `blockNumber=${this.number}`;\n    }\n\n    if (this.hash !== null) {\n      return `blockHash=${this.hash}`;\n    }\n\n    return `blockNumber=${this.tag}`;\n  }\n\n  // TODO: fix any\n  /**\n   * @returns {any} the identifier as an object\n   * @example\n   * ```typescript\n   * const result = new provider.Block(56789).identifier;\n   * // result = { block_number: 56789 }\n   * ```\n   */\n  get identifier(): any {\n    if (this.number !== null) {\n      return { block_number: this.number };\n    }\n\n    if (this.hash !== null) {\n      return { block_hash: this.hash };\n    }\n\n    return this.tag;\n  }\n\n  /**\n   * change the identifier of an existing Block instance\n   * @example\n   * ```typescript\n   * const myBlock = new provider.Block(\"latest\");\n   * myBlock.identifier =\"0x3456789abc\";\n   * const result = myBlock.identifier;\n   * // result = { block_hash: '0x3456789abc' }\n   * ```\n   */\n  set identifier(_identifier: BlockIdentifier) {\n    this.setIdentifier(_identifier);\n  }\n\n  valueOf = () => this.number;\n\n  toString = () => this.hash;\n}\n\n/**\n * Check if the given transaction details is a V3 transaction.\n *\n * @param {InvocationsDetailsWithNonce} details The transaction details to be checked.\n * @return {boolean} Returns true if the transaction is a V3 transaction, otherwise false.\n * @example\n * ```typescript\n * const invocation: InvocationsDetailsWithNonce = {\n *   nonce: 1,\n *   version: 3,\n *   maxFee: 10 ** 15,\n *   feeDataAvailabilityMode: RPC.EDataAvailabilityMode.L1,\n *   tip: 10 ** 13,\n *   paymasterData: [],\n *   resourceBounds: {\n *       l1_gas: { max_amount: num.toHex(10 ** 14), max_price_per_unit: num.toHex(50) },\n *       l2_gas: { max_amount: num.toHex(0), max_price_per_unit: num.toHex(0) }}};\n * const result = provider.isV3Tx(invocation);\n * // result = true\n * ```\n */\nexport function isV3Tx(details: InvocationsDetailsWithNonce): details is V3TransactionDetails {\n  const version = details.version ? toHex(details.version) : ETransactionVersion.V3;\n  return version === ETransactionVersion.V3 || version === ETransactionVersion.F3;\n}\n\n/**\n * Determines if the given response matches the specified version.\n *\n * @param {('0.5' | '0.6' | '0.7')} version The version to compare against the response.\n * @param {string} response The response to check against the version.\n * @returns {boolean} True if the response matches the version, false otherwise.\n * @example\n * ``` typescript\n * const result = provider.isVersion(\"0.7\",\"0_7\");\n * // result = false\n * ```\n */\nexport function isVersion(version: '0.5' | '0.6' | '0.7', response: string): boolean {\n  const [majorS, minorS] = version.split('.');\n  const [majorR, minorR] = response.split('.');\n\n  return majorS === majorR && minorS === minorR;\n}\n\n/**\n * Guard Pending Block\n * @param {GetBlockResponse} response answer of myProvider.getBlock()\n * @return {boolean} true if block is the pending block\n * @example\n * ```typescript\n * const block = await myProvider.getBlock(\"pending\");\n * const result = provider.isPendingBlock(block);\n * // result = true\n * ```\n */\nexport function isPendingBlock(response: GetBlockResponse): response is PendingBlock {\n  return response.status === 'PENDING';\n}\n\n/**\n * Guard Pending Transaction\n * @param {GetTransactionReceiptResponse} response transaction Receipt\n * @return {boolean} true if the transaction is part of the pending block\n * @example\n * ```typescript\n * const block = await myProvider.getBlockWithTxs(\"pending\");\n * const txR = await myProvider.getTransactionReceipt(block.transactions[0].transaction_hash);\n * const result = provider.isPendingTransaction(txR);\n * // result = true\n * ```\n */\nexport function isPendingTransaction(response: GetTransactionReceiptResponse): boolean {\n  return !('block_hash' in response);\n}\n\n/**\n * Guard Pending State Update\n * @param {StateUpdateResponse} response State of a block\n * @return {boolean} true if the block is pending\n * @example\n * ```typescript\n * const state: StateUpdateResponse = await myProvider.getStateUpdate(\"pending\");\n * const result = provider.isPendingStateUpdate(state);\n * // result = true\n * ```\n */\nexport function isPendingStateUpdate(\n  response: StateUpdateResponse\n): response is PendingStateUpdate {\n  return !('block_hash' in response);\n}\n","import { DEFAULT_GLOBAL_CONFIG } from './constants';\n\ntype DefaultConfig = typeof DEFAULT_GLOBAL_CONFIG;\ntype CustomConfig = { [key: string]: any };\n\ntype ConfigData = DefaultConfig & CustomConfig;\n\nclass Configuration {\n  private static instance: Configuration;\n\n  private config!: ConfigData;\n\n  private constructor() {\n    this.initialize();\n  }\n\n  private initialize(): void {\n    this.config = { ...DEFAULT_GLOBAL_CONFIG };\n  }\n\n  public static getInstance(): Configuration {\n    if (!Configuration.instance) {\n      Configuration.instance = new Configuration();\n    }\n    return Configuration.instance;\n  }\n\n  public get<K extends keyof DefaultConfig>(key: K): DefaultConfig[K];\n  public get(key: string, defaultValue?: any): any;\n  public get(key: string, defaultValue?: any) {\n    return this.config[key] ?? defaultValue;\n  }\n\n  public set<K extends keyof DefaultConfig>(key: K, value: DefaultConfig[K]): void;\n  public set(key: string, value: any): void;\n  public set(key: string, value: any): void {\n    this.config[key] = value;\n  }\n\n  public update(configData: Partial<DefaultConfig> & CustomConfig): void {\n    this.config = {\n      ...this.config,\n      ...configData,\n    };\n  }\n\n  public getAll(): ConfigData {\n    return { ...this.config };\n  }\n\n  public reset(): void {\n    this.initialize();\n  }\n\n  public delete<K extends keyof DefaultConfig>(key: K): void;\n  public delete(key: string): void;\n  public delete(key: string): void {\n    delete this.config[key];\n  }\n\n  public hasKey<K extends keyof DefaultConfig>(key: K): boolean;\n  public hasKey(key: string): boolean;\n  public hasKey(key: string): boolean {\n    return key in this.config;\n  }\n}\n\n// Export a single instance\nexport const config = Configuration.getInstance();\n","import { ValuesType } from '../types/helpers/valuesType';\n\nexport const LogLevelIndex = {\n  DEBUG: 5,\n  INFO: 4,\n  WARN: 3,\n  ERROR: 2,\n  FATAL: 1,\n  OFF: 0,\n};\n\nexport type LogLevelIndex = ValuesType<typeof LogLevelIndex>;\n\nexport type LogLevel = keyof typeof LogLevelIndex;\n","/* eslint-disable no-console */\nimport { config } from './config';\nimport { LogLevelIndex, LogLevel } from './logger.type';\n\ninterface LogMessage {\n  level: LogLevel;\n  message: string;\n  timestamp: string;\n  data?: any;\n}\n/**\n * Logging class providing different levels of log\n */\nclass Logger {\n  private static instance: Logger;\n\n  private config: typeof config;\n\n  private constructor() {\n    this.config = config;\n  }\n\n  public static getInstance(): Logger {\n    if (!Logger.instance) {\n      Logger.instance = new Logger();\n    }\n    return Logger.instance;\n  }\n\n  private getTimestamp(): string {\n    return new Date().toISOString();\n  }\n\n  private shouldLog(messageLevel: LogLevelIndex): boolean {\n    const configLevel = this.config.get('logLevel', 'INFO');\n    return messageLevel <= LogLevelIndex[configLevel as LogLevel];\n  }\n\n  private formatMessage(logMessage: LogMessage): string {\n    const { level, message, timestamp, data } = logMessage;\n    let formattedMessage = `[${timestamp}] ${level}: ${message}`;\n\n    if (data) {\n      try {\n        formattedMessage += `\\n${JSON.stringify(data, null, 2)}`;\n      } catch (error) {\n        formattedMessage += `\\n[JSON.stringify Error/Circular]: ${error}`;\n      }\n    }\n\n    return formattedMessage;\n  }\n\n  private log(level: LogLevel, message: string, data?: any): void {\n    if (!this.shouldLog(LogLevelIndex[level])) {\n      return;\n    }\n\n    const logMessage: LogMessage = {\n      level,\n      message,\n      timestamp: this.getTimestamp(),\n      data,\n    };\n\n    const formattedMessage = this.formatMessage(logMessage);\n\n    switch (level) {\n      case 'DEBUG':\n        console.debug(formattedMessage);\n        break;\n      case 'INFO':\n        console.info(formattedMessage);\n        break;\n      case 'WARN':\n        console.warn(formattedMessage);\n        break;\n      case 'ERROR':\n      case 'FATAL':\n        console.error(formattedMessage);\n        break;\n      case 'OFF':\n        // Do nothing when logging is off\n        break;\n      default:\n        console.log(formattedMessage); // Default fallback for unknown log levels\n        break;\n    }\n  }\n\n  /**\n   * debug will be displayed when LogLevel level is set to DEBUG(5)\n   */\n  public debug(message: string, data?: any): void {\n    this.log('DEBUG', message, data);\n  }\n\n  /**\n   * info will be displayed when LogLevel level is set to DEBUG(5), INFO(4)\n   */\n  public info(message: string, data?: any): void {\n    this.log('INFO', message, data);\n  }\n\n  /**\n   * warn will be displayed when LogLevel level is set to DEBUG(5), INFO(4), WARN(3)\n   */\n  public warn(message: string, data?: any): void {\n    this.log('WARN', message, data);\n  }\n\n  /**\n   * error will be displayed when LogLevel level is set to DEBUG(5), INFO(4), WARN(3), ERROR(2)\n   */\n  public error(message: string, data?: any): void {\n    this.log('ERROR', message, data);\n  }\n\n  /**\n   * fatal will be displayed when LogLevel level is set to DEBUG(5), INFO(4), WARN(3), ERROR(2), FATAL(1)\n   */\n  public fatal(message: string, data?: any): void {\n    this.log('FATAL', message, data);\n  }\n\n  /**\n   * Set the logging level you would like system to display\n   * * 5 DEBUG  - show all logs\n   * * 4 INFO\n   * * 3 WARN\n   * * 2 ERROR\n   * * 1 FATAL\n   * * 0 OFF    - disable logs\n   */\n  public setLogLevel(level: LogLevel): void {\n    this.config.set('logLevel', level);\n  }\n\n  public getLogLevel(): LogLevel {\n    return this.config.get('logLevel', 'INFO');\n  }\n\n  /**\n   *\n   * @returns logs levels displayed on the configured LogLevel\n   */\n  public getEnabledLogLevels() {\n    return Object.keys(LogLevelIndex).filter((s) => {\n      return this.shouldLog(LogLevelIndex[s as LogLevel]) && s !== 'OFF';\n    });\n  }\n}\n\n// Export a single instance\n/**\n * Logger instance, use for the system logging.\n * Higher the logger level index, higher the LogLevel required to display log.\n * Default should be INFO\n *\n * DEBUG: 5,\n * INFO: 4,\n * WARN: 3,\n * ERROR: 2,\n * FATAL: 1,\n */\nexport const logger = Logger.getInstance();\n","import { UDC } from '../global/constants';\nimport {\n  BigNumberish,\n  CairoVersion,\n  Call,\n  CallStruct,\n  Calldata,\n  ParsedStruct,\n  RawArgs,\n  UniversalDeployerContractPayload,\n} from '../types';\nimport { ETransactionVersion } from '../types/api';\nimport { CallData } from './calldata';\nimport { starkCurve } from './ec';\nimport { calculateContractAddressFromHash, getSelectorFromName } from './hash';\nimport { toBigInt, toCairoBool } from './num';\nimport { randomAddress } from './stark';\n\n/**\n * Transforms a list of Calls, each with their own calldata, into\n * two arrays: one with the entry points, and one with the concatenated calldata\n * @param {Call[]} calls the list of calls to transform.\n * @returns {callArray: ParsedStruct[], calldata: BigNumberish[]} An object containing two arrays: callArray and calldata.\n * @example\n * ```typescript\n * const calls: Call[] = [\n * \t{\n * \t\tcontractAddress: \"0x1234567890123456789012345678901234567890\",\n * \t\tentrypoint: \"functionName\",\n * \t\tcalldata: [1,2,3]\n * \t},\n * \t{\n * \t\tcontractAddress: \"0x0987654321098765432109876543210987654321\",\n * \t\tentrypoint: \"anotherFunction\",\n * \t\tcalldata: [4,5,6]\n * \t}\n * ];\n * const result = transaction.transformCallsToMulticallArrays(calls);\n * // result = {\n * // callArray: [\n * // { to: \"0x1234567890123456789012345678901234567890\", selector: \"1234567890\",\n * // data_offset: \"0\", data_len: \"3\" },\n * // { to: \"0x0987654321098765432109876543210987654321\", selector: \"1234567890\",\n * // data_offset: \"0987654321\", data_offset: \"3\", data_len: \"3\"}\n * // ], calldata: [1, 2, 3, 4, 5, 6]\n * // }\n * ```\n */\nexport const transformCallsToMulticallArrays = (calls: Call[]) => {\n  const callArray: ParsedStruct[] = [];\n  const calldata: BigNumberish[] = [];\n  calls.forEach((call) => {\n    const data = CallData.compile(call.calldata || []);\n    callArray.push({\n      to: toBigInt(call.contractAddress).toString(10),\n      selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n      data_offset: calldata.length.toString(),\n      data_len: data.length.toString(),\n    });\n    calldata.push(...data);\n  });\n  return {\n    callArray,\n    calldata: CallData.compile({ calldata }),\n  };\n};\n\n/**\n * Transforms a list of calls into the Cairo 0 `__execute__` calldata.\n * @param {Call[]} calls the list of calls to transform\n * @returns {Calldata} the Cairo 0 `__execute__` calldata\n * @example\n * ```typescript\n * const calls: Call[] = [\n * \t{\n * \t\tcontractAddress: \"0x1234567890123456789012345678901234567890\",\n * \t\tentrypoint: \"functionName\",\n * \t\tcalldata: [1, 2, 3]\n * \t},\n * \t{\n * \t\tcontractAddress: \"0x0987654321098765432109876543210987654321\",\n * \t\tentrypoint: \"anotherFunction\",\n * \t\tcalldata: [4, 5, 6]\n * \t}\n * ];\n * const result = transaction.fromCallsToExecuteCalldata(calls);\n * // result = ['2', '103929005307130220006098923584552504982110632080',\n * //   '784552248838722632831848474045274978537388011177294206940059575485454596699', '0',\n * //   '3', '54400338722927882010739357306608455014511100705',\n * //   '836430224577382061379420368022192503799782058803937958828224424676927281484',\n * //   '3', '3', '6', '1', '2', '3', '4', '5', '6']\n * ```\n */\nexport const fromCallsToExecuteCalldata = (calls: Call[]) => {\n  const { callArray, calldata } = transformCallsToMulticallArrays(calls);\n  const compiledCalls = CallData.compile({ callArray });\n  return [...compiledCalls, ...calldata] as Calldata;\n};\n\n/**\n * Transforms a list of calls into the Cairo 0 `__execute__` calldata including nonce.\n * @deprecated\n */\nexport const fromCallsToExecuteCalldataWithNonce = (calls: Call[], nonce: BigNumberish) => {\n  return [...fromCallsToExecuteCalldata(calls), toBigInt(nonce).toString()] as Calldata;\n};\n\n/**\n * Format Data inside Calls\n * @deprecated Not required for getting execute Calldata\n */\nexport const transformCallsToMulticallArrays_cairo1 = (calls: Call[]) => {\n  const callArray = calls.map<CallStruct>((call) => ({\n    to: toBigInt(call.contractAddress).toString(10),\n    selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n    calldata: CallData.compile(call.calldata || []),\n  }));\n  return callArray;\n};\n\n/**\n * Transforms a list of calls into the Cairo 1 `__execute__` calldata.\n * @param {Call[]} calls the list of calls to transform.\n * @returns {Calldata} the Cairo 1 `__execute__` calldata.\n * @example\n * ```typescript\n * const calls: Call[] = [\n * \t{\n * \t\tcontractAddress: \"0x1234567890123456789012345678901234567890\",\n * \t\tentrypoint: \"functionName\",\n * \t\tcalldata: [1, 2, 3]\n * \t},\n * \t{\n * \t\tcontractAddress: \"0x0987654321098765432109876543210987654321\",\n * \t\tentrypoint: \"anotherFunction\",\n * \t\tcalldata: [4, 5, 6]\n * \t}\n * ];\n * const result = transaction.fromCallsToExecuteCalldata_cairo1(calls);\n * // result = ['2', '103929005307130220006098923584552504982110632080',\n * //   '784552248838722632831848474045274978537388011177294206940059575485454596699',\n * //   '3', '1', '2', '3', '54400338722927882010739357306608455014511100705',\n * //   '836430224577382061379420368022192503799782058803937958828224424676927281484',\n * //   '3', '4', '5', '6']\n * ```\n */\nexport const fromCallsToExecuteCalldata_cairo1 = (calls: Call[]) => {\n  // ensure property order\n  const orderCalls = calls.map((call) => ({\n    contractAddress: call.contractAddress,\n    entrypoint: call.entrypoint,\n    calldata:\n      Array.isArray(call.calldata) && '__compiled__' in call.calldata\n        ? call.calldata // Calldata type\n        : CallData.compile(call.calldata as RawArgs), // RawArgsObject | RawArgsArray type\n  }));\n\n  return CallData.compile({ orderCalls });\n};\n\n/**\n * Create `__execute__` Calldata from Calls based on Cairo versions.\n * @param {Call[]} calls the list of calls to transform\n * @param {CairoVersion} cairoVersion the Cairo version\n * @returns {Calldata} the `__execute__` calldata.\n * @example\n * ```typescript\n * const calls: Call[] = [\n * \t{\n * \t\tcontractAddress: \"0x1234567890123456789012345678901234567890\",\n * \t\tentrypoint: \"functionName\",\n * \t\tcalldata: [1, 2, 3]\n * \t},\n * \t{\n * \t\tcontractAddress: \"0x0987654321098765432109876543210987654321\",\n * \t\tentrypoint: \"anotherFunction\",\n * \t\tcalldata: [4, 5, 6]\n * \t}\n * ];\n * const result = transaction.getExecuteCalldata(calls, '1');\n * // result = ['2', '103929005307130220006098923584552504982110632080',\n * //   '784552248838722632831848474045274978537388011177294206940059575485454596699',\n * //   '3', '1', '2', '3', '54400338722927882010739357306608455014511100705',\n * //   '836430224577382061379420368022192503799782058803937958828224424676927281484',\n * //   '3', '4', '5', '6']\n * ```\n */\nexport const getExecuteCalldata = (calls: Call[], cairoVersion: CairoVersion = '0') => {\n  if (cairoVersion === '1') {\n    return fromCallsToExecuteCalldata_cairo1(calls);\n  }\n  return fromCallsToExecuteCalldata(calls);\n};\n\n/**\n * Builds a UDCCall object.\n *\n * @param {UniversalDeployerContractPayload | UniversalDeployerContractPayload[]} payload the payload data for the UDCCall. Can be a single payload object or an array of payload objects.\n * @param {string} address the address to be used in the UDCCall\n * @returns { calls: Call[], addresses: string[] } the UDCCall object containing an array of calls and an array of addresses.\n * @example\n * ```typescript\n * const payload: UniversalDeployerContractPayload = {\n * classHash: \"0x1234567890123456789012345678901234567890\",\n * salt: \"0x0987654321098765432109876543210987654321\",\n * unique:true,\n * constructorCalldata: [1, 2, 3]\n * };\n * const address = \"0xABCDEF1234567890ABCDEF1234567890ABCDEF12\";\n * const result  = transaction.buildUDCCall(payload, address);\n * // result = {\n * // \tcalls: [\n * //\t\t\t{\n * //\t\t\tcontractAddress: \"0xABCDEF1234567890ABCDEF1234567890ABCDEF12\",\n * //\t\t\tentrypoint: \"functionName\",\n * //\t\t\tcalldata: [classHash, salt, true, 3, 1, 2, 3]\n * //\t\t}],\n * //\taddresses: [\"0x6fD084B56a7EDc5C06B3eB40f97Ae5A0C707A865\"]\n * // }\n * ```\n */\nexport function buildUDCCall(\n  payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n  address: string\n) {\n  const params = [].concat(payload as []).map((it) => {\n    const {\n      classHash,\n      salt,\n      unique = true,\n      constructorCalldata = [],\n    } = it as UniversalDeployerContractPayload;\n\n    const compiledConstructorCallData = CallData.compile(constructorCalldata);\n    const deploySalt = salt ?? randomAddress();\n\n    return {\n      call: {\n        contractAddress: UDC.ADDRESS,\n        entrypoint: UDC.ENTRYPOINT,\n        calldata: [\n          classHash,\n          deploySalt,\n          toCairoBool(unique),\n          compiledConstructorCallData.length,\n          ...compiledConstructorCallData,\n        ],\n      },\n      address: calculateContractAddressFromHash(\n        unique ? starkCurve.pedersen(address, deploySalt) : deploySalt,\n        classHash,\n        compiledConstructorCallData,\n        unique ? UDC.ADDRESS : 0\n      ),\n    };\n  });\n\n  return {\n    calls: params.map((it) => it.call),\n    addresses: params.map((it) => it.address),\n  };\n}\n\n/**\n * Return transaction versions based on version type, default version type is 'transaction'.\n * @param {'fee' | 'transaction'} [versionType] the type of version (\"fee\" or \"transaction\")\n * @returns {v1: ETransactionVersion, v2: ETransactionVersion, v3: ETransactionVersion} an object containing the transaction versions.\n * @example\n * ```typescript\n * const result = transaction.getVersionsByType('fee');\n * // result = {\n * //   v1: '0x100000000000000000000000000000001',\n * //   v2: '0x100000000000000000000000000000002',\n * //   v3: '0x100000000000000000000000000000003'\n * // }\n * ```\n */\nexport function getVersionsByType(versionType?: 'fee' | 'transaction') {\n  return versionType === 'fee'\n    ? {\n        v1: ETransactionVersion.F1,\n        v2: ETransactionVersion.F2,\n        v3: ETransactionVersion.F3,\n      }\n    : { v1: ETransactionVersion.V1, v2: ETransactionVersion.V2, v3: ETransactionVersion.V3 };\n}\n","import { NetworkName, StarknetChainId, SYSTEM_MESSAGES } from '../global/constants';\nimport { LibraryError, RpcError } from '../utils/errors';\nimport {\n  AccountInvocationItem,\n  AccountInvocations,\n  BigNumberish,\n  BlockIdentifier,\n  BlockTag,\n  Call,\n  DeclareContractTransaction,\n  DeployAccountContractTransaction,\n  Invocation,\n  InvocationsDetailsWithNonce,\n  RPC_ERROR,\n  RpcProviderOptions,\n  TransactionType,\n  getEstimateFeeBulkOptions,\n  getSimulateTransactionOptions,\n  waitForTransactionOptions,\n} from '../types';\nimport { JRPC, RPCSPEC07 as RPC } from '../types/api';\nimport { BatchClient } from '../utils/batch';\nimport { CallData } from '../utils/calldata';\nimport { isSierra } from '../utils/contract';\nimport { validateAndParseEthAddress } from '../utils/eth';\nimport fetch from '../utils/fetchPonyfill';\nimport { getSelector, getSelectorFromName } from '../utils/hash';\nimport { stringify } from '../utils/json';\nimport { getHexStringArray, toHex, toStorageKey } from '../utils/num';\nimport { Block, getDefaultNodeUrl, isV3Tx, isVersion, wait } from '../utils/provider';\nimport { decompressProgram, signatureToHexArray } from '../utils/stark';\nimport { getVersionsByType } from '../utils/transaction';\nimport { logger } from '../global/logger';\n\nconst defaultOptions = {\n  headers: { 'Content-Type': 'application/json' },\n  blockIdentifier: BlockTag.PENDING,\n  retries: 200,\n};\n\nexport class RpcChannel {\n  public nodeUrl: string;\n\n  public headers: object;\n\n  public requestId: number;\n\n  readonly blockIdentifier: BlockIdentifier;\n\n  readonly retries: number;\n\n  readonly waitMode: boolean; // behave like web2 rpc and return when tx is processed\n\n  private chainId?: StarknetChainId;\n\n  private specVersion?: string;\n\n  private transactionRetryIntervalFallback?: number;\n\n  private batchClient?: BatchClient;\n\n  private baseFetch: NonNullable<RpcProviderOptions['baseFetch']>;\n\n  constructor(optionsOrProvider?: RpcProviderOptions) {\n    const {\n      baseFetch,\n      batch,\n      blockIdentifier,\n      chainId,\n      headers,\n      nodeUrl,\n      retries,\n      specVersion,\n      transactionRetryIntervalFallback,\n      waitMode,\n    } = optionsOrProvider || {};\n    if (Object.values(NetworkName).includes(nodeUrl as NetworkName)) {\n      this.nodeUrl = getDefaultNodeUrl(nodeUrl as NetworkName, optionsOrProvider?.default);\n    } else if (nodeUrl) {\n      this.nodeUrl = nodeUrl;\n    } else {\n      this.nodeUrl = getDefaultNodeUrl(undefined, optionsOrProvider?.default);\n    }\n    this.baseFetch = baseFetch ?? fetch;\n    this.blockIdentifier = blockIdentifier ?? defaultOptions.blockIdentifier;\n    this.chainId = chainId;\n    this.headers = { ...defaultOptions.headers, ...headers };\n    this.retries = retries ?? defaultOptions.retries;\n    this.specVersion = specVersion;\n    this.transactionRetryIntervalFallback = transactionRetryIntervalFallback;\n    this.waitMode = waitMode ?? false;\n\n    this.requestId = 0;\n\n    if (typeof batch === 'number') {\n      this.batchClient = new BatchClient({\n        nodeUrl: this.nodeUrl,\n        headers: this.headers,\n        interval: batch,\n        baseFetch: this.baseFetch,\n      });\n    }\n  }\n\n  private get transactionRetryIntervalDefault() {\n    return this.transactionRetryIntervalFallback ?? 5000;\n  }\n\n  public setChainId(chainId: StarknetChainId) {\n    this.chainId = chainId;\n  }\n\n  public fetch(method: string, params?: object, id: string | number = 0) {\n    const rpcRequestBody: JRPC.RequestBody = {\n      id,\n      jsonrpc: '2.0',\n      method,\n      ...(params && { params }),\n    };\n    return this.baseFetch(this.nodeUrl, {\n      method: 'POST',\n      body: stringify(rpcRequestBody),\n      headers: this.headers as Record<string, string>,\n    });\n  }\n\n  protected errorHandler(method: string, params: any, rpcError?: JRPC.Error, otherError?: any) {\n    if (rpcError) {\n      throw new RpcError(rpcError as RPC_ERROR, method, params);\n    }\n    if (otherError instanceof LibraryError) {\n      throw otherError;\n    }\n    if (otherError) {\n      throw Error(otherError.message);\n    }\n  }\n\n  protected async fetchEndpoint<T extends keyof RPC.Methods>(\n    method: T,\n    params?: RPC.Methods[T]['params']\n  ): Promise<RPC.Methods[T]['result']> {\n    try {\n      if (this.batchClient) {\n        const { error, result } = await this.batchClient.fetch(\n          method,\n          params,\n          (this.requestId += 1)\n        );\n        this.errorHandler(method, params, error);\n        return result as RPC.Methods[T]['result'];\n      }\n\n      const rawResult = await this.fetch(method, params, (this.requestId += 1));\n      const { error, result } = await rawResult.json();\n      this.errorHandler(method, params, error);\n      return result as RPC.Methods[T]['result'];\n    } catch (error: any) {\n      this.errorHandler(method, params, error?.response?.data, error);\n      throw error;\n    }\n  }\n\n  public async getChainId() {\n    this.chainId ??= (await this.fetchEndpoint('starknet_chainId')) as StarknetChainId;\n    return this.chainId;\n  }\n\n  public async getSpecVersion() {\n    this.specVersion ??= (await this.fetchEndpoint('starknet_specVersion')) as StarknetChainId;\n    return this.specVersion;\n  }\n\n  public getNonceForAddress(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getNonce', {\n      contract_address,\n      block_id,\n    });\n  }\n\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  public getBlockLatestAccepted() {\n    return this.fetchEndpoint('starknet_blockHashAndNumber');\n  }\n\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  public getBlockNumber() {\n    return this.fetchEndpoint('starknet_blockNumber');\n  }\n\n  public getBlockWithTxHashes(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithTxHashes', { block_id });\n  }\n\n  public getBlockWithTxs(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithTxs', { block_id });\n  }\n\n  public getBlockWithReceipts(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithReceipts', { block_id });\n  }\n\n  public getBlockStateUpdate(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getStateUpdate', { block_id });\n  }\n\n  public getBlockTransactionsTraces(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_traceBlockTransactions', { block_id });\n  }\n\n  public getBlockTransactionCount(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockTransactionCount', { block_id });\n  }\n\n  public getTransactionByHash(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_getTransactionByHash', {\n      transaction_hash,\n    });\n  }\n\n  public getTransactionByBlockIdAndIndex(blockIdentifier: BlockIdentifier, index: number) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getTransactionByBlockIdAndIndex', { block_id, index });\n  }\n\n  public getTransactionReceipt(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_getTransactionReceipt', { transaction_hash });\n  }\n\n  public getTransactionTrace(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_traceTransaction', { transaction_hash });\n  }\n\n  /**\n   * Get the status of a transaction\n   */\n  public getTransactionStatus(transactionHash: BigNumberish) {\n    const transaction_hash = toHex(transactionHash);\n    return this.fetchEndpoint('starknet_getTransactionStatus', { transaction_hash });\n  }\n\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  public simulateTransaction(\n    invocations: AccountInvocations,\n    simulateTransactionOptions: getSimulateTransactionOptions = {}\n  ) {\n    const {\n      blockIdentifier = this.blockIdentifier,\n      skipValidate = true,\n      skipFeeCharge = true,\n    } = simulateTransactionOptions;\n    const block_id = new Block(blockIdentifier).identifier;\n    const simulationFlags: RPC.ESimulationFlag[] = [];\n    if (skipValidate) simulationFlags.push(RPC.ESimulationFlag.SKIP_VALIDATE);\n    if (skipFeeCharge) simulationFlags.push(RPC.ESimulationFlag.SKIP_FEE_CHARGE);\n\n    return this.fetchEndpoint('starknet_simulateTransactions', {\n      block_id,\n      transactions: invocations.map((it) => this.buildTransaction(it)),\n      simulation_flags: simulationFlags,\n    });\n  }\n\n  public async waitForTransaction(txHash: BigNumberish, options?: waitForTransactionOptions) {\n    const transactionHash = toHex(txHash);\n    let { retries } = this;\n    let onchain = false;\n    let isErrorState = false;\n    const retryInterval = options?.retryInterval ?? this.transactionRetryIntervalDefault;\n    const errorStates: any = options?.errorStates ?? [\n      RPC.ETransactionStatus.REJECTED,\n      // TODO: commented out to preserve the long-standing behavior of \"reverted\" not being treated as an error by default\n      // should decide which behavior to keep in the future\n      // RPC.ETransactionExecutionStatus.REVERTED,\n    ];\n    const successStates: any = options?.successStates ?? [\n      RPC.ETransactionExecutionStatus.SUCCEEDED,\n      RPC.ETransactionStatus.ACCEPTED_ON_L2,\n      RPC.ETransactionStatus.ACCEPTED_ON_L1,\n    ];\n\n    let txStatus: RPC.TransactionStatus;\n    while (!onchain) {\n      // eslint-disable-next-line no-await-in-loop\n      await wait(retryInterval);\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        txStatus = await this.getTransactionStatus(transactionHash);\n\n        const executionStatus = txStatus.execution_status;\n        const finalityStatus = txStatus.finality_status;\n\n        if (!finalityStatus) {\n          // Transaction is potentially NOT_RECEIVED or RPC not Synced yet\n          // so we will retry '{ retries }' times\n          const error = new Error('waiting for transaction status');\n          throw error;\n        }\n\n        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n          const message = `${executionStatus}: ${finalityStatus}`;\n          const error = new Error(message) as Error & { response: RPC.TransactionStatus };\n          error.response = txStatus;\n          isErrorState = true;\n          throw error;\n        } else if (\n          successStates.includes(executionStatus) ||\n          successStates.includes(finalityStatus)\n        ) {\n          onchain = true;\n        }\n      } catch (error) {\n        if (error instanceof Error && isErrorState) {\n          throw error;\n        }\n\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n\n      retries -= 1;\n    }\n\n    /**\n     * For some nodes even though the transaction has executionStatus SUCCEEDED finalityStatus ACCEPTED_ON_L2, getTransactionReceipt returns \"Transaction hash not found\"\n     * Retry until rpc is actually ready to work with txHash\n     */\n    let txReceipt = null;\n    while (txReceipt === null) {\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        txReceipt = await this.getTransactionReceipt(transactionHash);\n      } catch (error) {\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n      // eslint-disable-next-line no-await-in-loop\n      await wait(retryInterval);\n    }\n    return txReceipt as RPC.SPEC.TXN_RECEIPT;\n  }\n\n  public getStorageAt(\n    contractAddress: BigNumberish,\n    key: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const parsedKey = toStorageKey(key);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getStorageAt', {\n      contract_address,\n      key: parsedKey,\n      block_id,\n    });\n  }\n\n  public getClassHashAt(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClassHashAt', {\n      block_id,\n      contract_address,\n    });\n  }\n\n  public getClass(\n    classHash: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const class_hash = toHex(classHash);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClass', {\n      class_hash,\n      block_id,\n    });\n  }\n\n  public getClassAt(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClassAt', {\n      block_id,\n      contract_address,\n    });\n  }\n\n  public async getEstimateFee(\n    invocations: AccountInvocations,\n    { blockIdentifier = this.blockIdentifier, skipValidate = true }: getEstimateFeeBulkOptions\n  ) {\n    const block_id = new Block(blockIdentifier).identifier;\n    let flags = {};\n    if (!isVersion('0.5', await this.getSpecVersion())) {\n      flags = {\n        simulation_flags: skipValidate ? [RPC.ESimulationFlag.SKIP_VALIDATE] : [],\n      };\n    } // else v(0.5) no flags\n\n    return this.fetchEndpoint('starknet_estimateFee', {\n      request: invocations.map((it) => this.buildTransaction(it, 'fee')),\n      block_id,\n      ...flags,\n    });\n  }\n\n  public async invoke(functionInvocation: Invocation, details: InvocationsDetailsWithNonce) {\n    let promise;\n    if (!isV3Tx(details)) {\n      // V1\n      promise = this.fetchEndpoint('starknet_addInvokeTransaction', {\n        invoke_transaction: {\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          type: RPC.ETransactionType.INVOKE,\n          max_fee: toHex(details.maxFee || 0),\n          version: RPC.ETransactionVersion.V1,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n        },\n      });\n\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: RPC.ETransactionVersion.V1,\n        type: RPC.ETransactionType.INVOKE,\n      });\n    } else {\n      // V3\n      promise = this.fetchEndpoint('starknet_addInvokeTransaction', {\n        invoke_transaction: {\n          type: RPC.ETransactionType.INVOKE,\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          version: RPC.ETransactionVersion.V3,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode,\n        },\n      });\n    }\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public async declare(\n    { contract, signature, senderAddress, compiledClassHash }: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    let promise;\n    if (!isSierra(contract) && !isV3Tx(details)) {\n      // V1 Cairo 0\n      promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n        declare_transaction: {\n          type: RPC.ETransactionType.DECLARE,\n          contract_class: {\n            program: contract.program,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi,\n          },\n          version: RPC.ETransactionVersion.V1,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce),\n        },\n      });\n\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: RPC.ETransactionVersion.V1,\n        type: RPC.ETransactionType.DECLARE,\n      });\n    } else if (isSierra(contract) && !isV3Tx(details)) {\n      // V2 Cairo1\n      promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n        declare_transaction: {\n          type: RPC.ETransactionType.DECLARE,\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi,\n          },\n          compiled_class_hash: compiledClassHash || '',\n          version: RPC.ETransactionVersion.V2,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce),\n        },\n      });\n\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: RPC.ETransactionVersion.V2,\n        type: RPC.ETransactionType.DECLARE,\n      });\n    } else if (isSierra(contract) && isV3Tx(details)) {\n      // V3 Cairo1\n      promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n        declare_transaction: {\n          type: RPC.ETransactionType.DECLARE,\n          sender_address: senderAddress,\n          compiled_class_hash: compiledClassHash || '',\n          version: RPC.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi,\n          },\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode,\n        },\n      });\n    } else {\n      throw Error('declare unspotted parameters');\n    }\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public async deployAccount(\n    { classHash, constructorCalldata, addressSalt, signature }: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    let promise;\n    if (!isV3Tx(details)) {\n      // v1\n      promise = this.fetchEndpoint('starknet_addDeployAccountTransaction', {\n        deploy_account_transaction: {\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          contract_address_salt: toHex(addressSalt || 0),\n          type: RPC.ETransactionType.DEPLOY_ACCOUNT,\n          max_fee: toHex(details.maxFee || 0),\n          version: RPC.ETransactionVersion.V1,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n        },\n      });\n\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: RPC.ETransactionVersion.V1,\n        type: RPC.ETransactionType.DEPLOY_ACCOUNT,\n      });\n    } else {\n      // v3\n      promise = this.fetchEndpoint('starknet_addDeployAccountTransaction', {\n        deploy_account_transaction: {\n          type: RPC.ETransactionType.DEPLOY_ACCOUNT,\n          version: RPC.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_address_salt: toHex(addressSalt || 0),\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode,\n        },\n      });\n    }\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public callContract(call: Call, blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_call', {\n      request: {\n        contract_address: call.contractAddress,\n        entry_point_selector: getSelectorFromName(call.entrypoint),\n        calldata: CallData.toHex(call.calldata),\n      },\n      block_id,\n    });\n  }\n\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  public estimateMessageFee(\n    message: RPC.L1Message,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const { from_address, to_address, entry_point_selector, payload } = message;\n    const formattedMessage = {\n      from_address: validateAndParseEthAddress(from_address),\n      to_address: toHex(to_address),\n      entry_point_selector: getSelector(entry_point_selector),\n      payload: getHexStringArray(payload),\n    };\n\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_estimateMessageFee', {\n      message: formattedMessage,\n      block_id,\n    });\n  }\n\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  public getSyncingStats() {\n    return this.fetchEndpoint('starknet_syncing');\n  }\n\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  public getEvents(eventFilter: RPC.EventFilter) {\n    return this.fetchEndpoint('starknet_getEvents', { filter: eventFilter });\n  }\n\n  public buildTransaction(\n    invocation: AccountInvocationItem,\n    versionType?: 'fee' | 'transaction'\n  ): RPC.BaseTransaction {\n    const defaultVersions = getVersionsByType(versionType);\n    let details;\n\n    if (!isV3Tx(invocation)) {\n      // V0,V1,V2\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        max_fee: toHex(invocation.maxFee || 0),\n      };\n\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: invocation.version,\n        type: invocation.type,\n      });\n    } else {\n      // V3\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        resource_bounds: invocation.resourceBounds,\n        tip: toHex(invocation.tip),\n        paymaster_data: invocation.paymasterData.map((it) => toHex(it)),\n        nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n        fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n        account_deployment_data: invocation.accountDeploymentData.map((it) => toHex(it)),\n      };\n    }\n\n    if (invocation.type === TransactionType.INVOKE) {\n      return {\n        // v0 v1 v3\n        type: RPC.ETransactionType.INVOKE,\n        sender_address: invocation.contractAddress,\n        calldata: CallData.toHex(invocation.calldata),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details,\n      } as RPC.SPEC.BROADCASTED_INVOKE_TXN;\n    }\n    if (invocation.type === TransactionType.DECLARE) {\n      if (!isSierra(invocation.contract)) {\n        // Cairo 0 - v1\n        return {\n          type: invocation.type,\n          contract_class: invocation.contract,\n          sender_address: invocation.senderAddress,\n          version: toHex(invocation.version || defaultVersions.v1),\n          ...details,\n        } as RPC.SPEC.BROADCASTED_DECLARE_TXN_V1;\n      }\n      return {\n        // Cairo 1 - v2 v3\n        type: invocation.type,\n        contract_class: {\n          ...invocation.contract,\n          sierra_program: decompressProgram(invocation.contract.sierra_program),\n        },\n        compiled_class_hash: invocation.compiledClassHash || '',\n        sender_address: invocation.senderAddress,\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details,\n      } as RPC.SPEC.BROADCASTED_DECLARE_TXN;\n    }\n    if (invocation.type === TransactionType.DEPLOY_ACCOUNT) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { account_deployment_data, ...restDetails } = details;\n      // v1 v3\n      return {\n        type: invocation.type,\n        constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n        class_hash: toHex(invocation.classHash),\n        contract_address_salt: toHex(invocation.addressSalt || 0),\n        version: toHex(invocation.version || defaultVersions.v3) as RPC.SPEC.INVOKE_TXN['version'],\n        ...restDetails,\n      } as RPC.SPEC.BROADCASTED_DEPLOY_ACCOUNT_TXN;\n    }\n    throw Error('RPC buildTransaction received unknown TransactionType');\n  }\n}\n","/**\n * Map RPC Response to common interface response\n * Intersection (sequencer response  ( rpc responses))\n */\nimport type {\n  BlockWithTxHashes,\n  ContractClassPayload,\n  ContractClassResponse,\n  EstimateFeeResponse,\n  EstimateFeeResponseBulk,\n  FeeEstimate,\n  GetBlockResponse,\n  GetTxReceiptResponseWithoutHelper,\n  RpcProviderOptions,\n  SimulateTransactionResponse,\n  SimulatedTransaction,\n  TransactionReceipt,\n} from '../../types/provider';\nimport { toBigInt } from '../num';\nimport { isString } from '../typed';\nimport { estimateFeeToBounds, estimatedFeeToMaxFee } from '../stark';\nimport { ResponseParser } from './interface';\n\nexport class RPCResponseParser\n  implements\n    Omit<\n      ResponseParser,\n      | 'parseDeclareContractResponse'\n      | 'parseDeployContractResponse'\n      | 'parseInvokeFunctionResponse'\n      | 'parseGetTransactionReceiptResponse'\n      | 'parseGetTransactionResponse'\n      | 'parseCallContractResponse'\n    >\n{\n  private margin: RpcProviderOptions['feeMarginPercentage'];\n\n  constructor(margin?: RpcProviderOptions['feeMarginPercentage']) {\n    this.margin = margin;\n  }\n\n  private estimatedFeeToMaxFee(estimatedFee: Parameters<typeof estimatedFeeToMaxFee>[0]) {\n    return estimatedFeeToMaxFee(estimatedFee, this.margin?.maxFee);\n  }\n\n  private estimateFeeToBounds(estimate: Parameters<typeof estimateFeeToBounds>[0]) {\n    return estimateFeeToBounds(\n      estimate,\n      this.margin?.l1BoundMaxAmount,\n      this.margin?.l1BoundMaxPricePerUnit\n    );\n  }\n\n  public parseGetBlockResponse(res: BlockWithTxHashes): GetBlockResponse {\n    return { status: 'PENDING', ...res } as GetBlockResponse;\n  }\n\n  public parseTransactionReceipt(res: TransactionReceipt): GetTxReceiptResponseWithoutHelper {\n    // HOTFIX RPC 0.5 to align with RPC 0.6\n    // This case is RPC 0.5. It can be only v2 thx with FRI units\n    if ('actual_fee' in res && isString(res.actual_fee)) {\n      return {\n        ...(res as GetTxReceiptResponseWithoutHelper),\n        actual_fee: {\n          amount: res.actual_fee,\n          unit: 'FRI',\n        },\n      } as GetTxReceiptResponseWithoutHelper;\n    }\n\n    return res as GetTxReceiptResponseWithoutHelper;\n  }\n\n  public parseFeeEstimateResponse(res: FeeEstimate[]): EstimateFeeResponse {\n    const val = res[0];\n    return {\n      overall_fee: toBigInt(val.overall_fee),\n      gas_consumed: toBigInt(val.gas_consumed),\n      gas_price: toBigInt(val.gas_price),\n      unit: val.unit,\n      suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),\n      resourceBounds: this.estimateFeeToBounds(val),\n      data_gas_consumed: val.data_gas_consumed ? toBigInt(val.data_gas_consumed) : 0n,\n      data_gas_price: val.data_gas_price ? toBigInt(val.data_gas_price) : 0n,\n    };\n  }\n\n  public parseFeeEstimateBulkResponse(res: FeeEstimate[]): EstimateFeeResponseBulk {\n    return res.map((val) => ({\n      overall_fee: toBigInt(val.overall_fee),\n      gas_consumed: toBigInt(val.gas_consumed),\n      gas_price: toBigInt(val.gas_price),\n      unit: val.unit,\n      suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),\n      resourceBounds: this.estimateFeeToBounds(val),\n      data_gas_consumed: val.data_gas_consumed ? toBigInt(val.data_gas_consumed) : 0n,\n      data_gas_price: val.data_gas_price ? toBigInt(val.data_gas_price) : 0n,\n    }));\n  }\n\n  public parseSimulateTransactionResponse(\n    // TODO: revisit\n    // set as 'any' to avoid a mapped type circular recursion error stemming from\n    // merging src/types/api/rpcspec*/components/FUNCTION_INVOCATION.calls\n    //\n    // res: SimulateTransactionResponse\n    res: any\n  ): SimulateTransactionResponse {\n    return res.map((it: SimulatedTransaction) => {\n      return {\n        ...it,\n        suggestedMaxFee: this.estimatedFeeToMaxFee(it.fee_estimation.overall_fee),\n        resourceBounds: this.estimateFeeToBounds(it.fee_estimation),\n      };\n    });\n  }\n\n  public parseContractClassResponse(res: ContractClassPayload): ContractClassResponse {\n    return {\n      ...(res as ContractClassResponse),\n      abi: isString(res.abi) ? JSON.parse(res.abi) : res.abi,\n    };\n  }\n\n  public parseL1GasPriceResponse(res: BlockWithTxHashes): string {\n    return res.l1_gas_price.price_in_wei;\n  }\n}\n","/* eslint-disable no-nested-ternary */\nimport {\n  GetTxReceiptResponseWithoutHelper,\n  RejectedTransactionReceiptResponse,\n  RevertedTransactionReceiptResponse,\n  SuccessfulTransactionReceiptResponse,\n  TransactionExecutionStatus,\n} from '../types';\nimport type {\n  TransactionReceiptCallbacks,\n  TransactionReceiptCallbacksDefault,\n  TransactionReceiptStatus,\n  TransactionReceiptUtilityInterface,\n  TransactionReceiptValue,\n} from '../types/transactionReceipt';\n\n/**\n * Utility that analyses transaction receipt response and provides helpers to process it\n * @example\n * ```typescript\n * const responseTx = new ReceiptTx(receipt);\n * responseTx.match({\n *   success: (txR: SuccessfulTransactionReceiptResponse) => { },\n *   rejected: (txR: RejectedTransactionReceiptResponse) => { },\n *   reverted: (txR: RevertedTransactionReceiptResponse) => { },\n *   error: (err: Error) => { },\n * });\n * responseTx.match({\n *   success: (txR: SuccessfulTransactionReceiptResponse) => { },\n *   _: () => { },\n * }\n * ```\n */\nexport class ReceiptTx implements TransactionReceiptUtilityInterface {\n  public readonly statusReceipt: TransactionReceiptStatus;\n\n  public readonly value: TransactionReceiptValue;\n\n  constructor(receipt: GetTxReceiptResponseWithoutHelper) {\n    [this.statusReceipt, this.value] = ReceiptTx.isSuccess(receipt)\n      ? ['success', receipt]\n      : ReceiptTx.isReverted(receipt)\n        ? ['reverted', receipt]\n        : ReceiptTx.isRejected(receipt)\n          ? ['rejected', receipt]\n          : ['error', new Error('Unknown response type')];\n    // eslint-disable-next-line no-restricted-syntax\n    for (const [key] of Object.entries(this)) {\n      Object.defineProperty(this, key, {\n        enumerable: false,\n      });\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    for (const [key, value] of Object.entries(receipt)) {\n      Object.defineProperty(this, key, {\n        enumerable: true,\n        writable: false,\n        value,\n      });\n    }\n  }\n\n  match(callbacks: TransactionReceiptCallbacks) {\n    if (this.statusReceipt in callbacks) {\n      return callbacks[this.statusReceipt]!(this.value as any);\n    }\n    return (callbacks as TransactionReceiptCallbacksDefault)._();\n  }\n\n  isSuccess(): this is SuccessfulTransactionReceiptResponse {\n    return this.statusReceipt === 'success';\n  }\n\n  isReverted(): this is RevertedTransactionReceiptResponse {\n    return this.statusReceipt === 'reverted';\n  }\n\n  isRejected(): this is RejectedTransactionReceiptResponse {\n    return this.statusReceipt === 'rejected';\n  }\n\n  isError() {\n    return this.statusReceipt === 'error';\n  }\n\n  static isSuccess(\n    transactionReceipt: GetTxReceiptResponseWithoutHelper\n  ): transactionReceipt is SuccessfulTransactionReceiptResponse {\n    return (\n      (transactionReceipt as SuccessfulTransactionReceiptResponse).execution_status ===\n      TransactionExecutionStatus.SUCCEEDED\n    );\n  }\n\n  static isReverted(\n    transactionReceipt: GetTxReceiptResponseWithoutHelper\n  ): transactionReceipt is RevertedTransactionReceiptResponse {\n    return (\n      (transactionReceipt as RevertedTransactionReceiptResponse).execution_status ===\n      TransactionExecutionStatus.REVERTED\n    );\n  }\n\n  static isRejected(\n    transactionReceipt: GetTxReceiptResponseWithoutHelper\n  ): transactionReceipt is RejectedTransactionReceiptResponse {\n    return (\n      (transactionReceipt as RejectedTransactionReceiptResponse).status ===\n      TransactionExecutionStatus.REJECTED\n    );\n  }\n}\n\nexport type GetTransactionReceiptResponse = GetTxReceiptResponseWithoutHelper & ReceiptTx;\n","/* eslint-disable no-param-reassign */\nimport { PRIME, RANGE_FELT, RANGE_I128, RANGE_U128 } from '../global/constants';\nimport {\n  BigNumberish,\n  TypedDataRevision as Revision,\n  StarknetEnumType,\n  StarknetMerkleType,\n  StarknetType,\n  TypedData,\n  type Signature,\n} from '../types';\nimport assert from './assert';\nimport { byteArrayFromString } from './calldata/byteArray';\nimport { starkCurve } from './ec';\nimport {\n  computePedersenHash,\n  computePedersenHashOnElements,\n  computePoseidonHash,\n  computePoseidonHashOnElements,\n  getSelectorFromName,\n} from './hash';\nimport { MerkleTree } from './merkle';\nimport { isBigNumberish, isHex, toHex } from './num';\nimport { encodeShortString } from './shortString';\nimport { isBoolean, isString } from './typed';\n\n/** @deprecated prefer importing from 'types' over 'typedData' */\nexport * from '../types/typedData';\n\ninterface Context {\n  parent?: string;\n  key?: string;\n}\n\ninterface Configuration {\n  domain: string;\n  hashMethod: (data: BigNumberish[]) => string;\n  hashMerkleMethod: (a: BigNumberish, b: BigNumberish) => string;\n  escapeTypeString: (s: string) => string;\n  presetTypes: TypedData['types'];\n}\n\nconst presetTypes: TypedData['types'] = {\n  u256: JSON.parse('[{ \"name\": \"low\", \"type\": \"u128\" }, { \"name\": \"high\", \"type\": \"u128\" }]'),\n  TokenAmount: JSON.parse(\n    '[{ \"name\": \"token_address\", \"type\": \"ContractAddress\" }, { \"name\": \"amount\", \"type\": \"u256\" }]'\n  ),\n  NftId: JSON.parse(\n    '[{ \"name\": \"collection_address\", \"type\": \"ContractAddress\" }, { \"name\": \"token_id\", \"type\": \"u256\" }]'\n  ),\n};\n\nconst revisionConfiguration: Record<Revision, Configuration> = {\n  [Revision.ACTIVE]: {\n    domain: 'StarknetDomain',\n    hashMethod: computePoseidonHashOnElements,\n    hashMerkleMethod: computePoseidonHash,\n    escapeTypeString: (s) => `\"${s}\"`,\n    presetTypes,\n  },\n  [Revision.LEGACY]: {\n    domain: 'StarkNetDomain',\n    hashMethod: computePedersenHashOnElements,\n    hashMerkleMethod: computePedersenHash,\n    escapeTypeString: (s) => s,\n    presetTypes: {},\n  },\n};\n\nfunction assertRange(data: unknown, type: string, { min, max }: { min: bigint; max: bigint }) {\n  const value = BigInt(data as string);\n  assert(value >= min && value <= max, `${value} (${type}) is out of bounds [${min}, ${max}]`);\n}\n\nfunction identifyRevision({ types, domain }: TypedData) {\n  if (revisionConfiguration[Revision.ACTIVE].domain in types && domain.revision === Revision.ACTIVE)\n    return Revision.ACTIVE;\n\n  if (\n    revisionConfiguration[Revision.LEGACY].domain in types &&\n    (domain.revision ?? Revision.LEGACY) === Revision.LEGACY\n  )\n    return Revision.LEGACY;\n\n  return undefined;\n}\n\nfunction getHex(value: BigNumberish): string {\n  try {\n    return toHex(value);\n  } catch (e) {\n    if (isString(value)) {\n      return toHex(encodeShortString(value));\n    }\n    throw new Error(`Invalid BigNumberish: ${value}`);\n  }\n}\n\n/**\n * Validates that `data` matches the EIP-712 JSON schema.\n */\nexport function validateTypedData(data: unknown): data is TypedData {\n  const typedData = data as TypedData;\n  return Boolean(\n    typedData.message && typedData.primaryType && typedData.types && identifyRevision(typedData)\n  );\n}\n\n/**\n * Prepares the selector for later use, if it's not already in correct format.\n * The selector in correct format is the starknet_keccak hash of the function name, encoded in ASCII.\n *\n * @param {string} selector - The selector to be prepared.\n * @returns {string} The prepared selector.\n *\n * @example\n * ```typescript\n * const result1 = prepareSelector('0xc14cfe23f3fa7ce7b1f8db7d7682305b1692293f71a61cc06637f0d8d8b6c8');\n * // result1 = '0xc14cfe23f3fa7ce7b1f8db7d7682305b1692293f71a61cc06637f0d8d8b6c8'\n *\n * const result2 =  prepareSelector('myFunction');\n * // result2 = '0xc14cfe23f3fa7ce7b1f8db7d7682305b1692293f71a61cc06637f0d8d8b6c8'\n * ```\n */\nexport function prepareSelector(selector: string): string {\n  return isHex(selector) ? selector : getSelectorFromName(selector);\n}\n\n/**\n * Checks if the given Starknet type is a Merkle tree type.\n *\n * @param {StarknetType} type - The StarkNet type to check.\n *\n * @returns {boolean} - True if the type is a Merkle tree type, false otherwise.\n *\n * @example\n * ```typescript\n * const type = { name: 'test', type: 'merkletree',};\n * const result1 = isMerkleTreeType(type);\n * // result1 = true\n *\n * const type2 = {name: 'test', type: 'non-merkletree',};\n * const result2 =  isMerkleTreeType(type2);\n * // result2 = false\n * ```\n */\nexport function isMerkleTreeType(type: StarknetType): type is StarknetMerkleType {\n  return type.type === 'merkletree';\n}\n\n/**\n * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once\n * in the resulting array.\n *\n * @param {TypedData['types']} types - The types object containing all defined types.\n * @param {string} type - The name of the type to get dependencies for.\n * @param {string[]} [dependencies=[]] - The array to store dependencies.\n * @param {string} [contains=''] - The type contained within the struct.\n * @param {Revision} [revision=Revision.Legacy] - The revision of the TypedData.\n *\n * @returns {string[]} The array of dependencies.\n */\nexport function getDependencies(\n  types: TypedData['types'],\n  type: string,\n  dependencies: string[] = [],\n  contains: string = '',\n  revision: Revision = Revision.LEGACY\n): string[] {\n  let dependencyTypes: string[] = [type];\n\n  // Include pointers (struct arrays)\n  if (type[type.length - 1] === '*') {\n    dependencyTypes = [type.slice(0, -1)];\n  } else if (revision === Revision.ACTIVE) {\n    // enum base\n    if (type === 'enum') {\n      dependencyTypes = [contains];\n    }\n    // enum element types\n    else if (type.match(/^\\(.*\\)$/)) {\n      dependencyTypes = type\n        .slice(1, -1)\n        .split(',')\n        .map((depType) => (depType[depType.length - 1] === '*' ? depType.slice(0, -1) : depType));\n    }\n  }\n\n  return dependencyTypes\n    .filter((t) => !dependencies.includes(t) && types[t])\n    .reduce<string[]>(\n      // This comment prevents prettier from rolling everything here into a single line.\n      (p, depType) => [\n        ...p,\n        ...[\n          depType,\n          ...(types[depType] as StarknetEnumType[]).reduce<string[]>(\n            (previous, t) => [\n              ...previous,\n              ...getDependencies(types, t.type, previous, t.contains, revision).filter(\n                (dependency) => !previous.includes(dependency)\n              ),\n            ],\n            []\n          ),\n        ].filter((dependency) => !p.includes(dependency)),\n      ],\n      []\n    );\n}\n\nfunction getMerkleTreeType(types: TypedData['types'], ctx: Context) {\n  if (ctx.parent && ctx.key) {\n    const parentType = types[ctx.parent];\n    const merkleType = parentType.find((t) => t.name === ctx.key)!;\n    const isMerkleTree = isMerkleTreeType(merkleType);\n    if (!isMerkleTree) {\n      throw new Error(`${ctx.key} is not a merkle tree`);\n    }\n    if (merkleType.contains.endsWith('*')) {\n      throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);\n    }\n    return merkleType.contains;\n  }\n  return 'raw';\n}\n\n/**\n * Encode a type to a string. All dependent types are alphabetically sorted.\n *\n * @param {TypedData['types']} types - The types object containing all defined types.\n * @param {string} type - The name of the type to encode.\n * @param {Revision} [revision=Revision.Legacy] - The revision of the TypedData.\n *\n * @returns {string} The encoded string.\n *\n * @example\n * ```typescript\n * import typedDataExample from '../../__mocks__/typedData/baseExample.json';\n *\n * const result = encodeType(typedDataExample.types, 'Mail');\n * // result = \"Mail(from:Person,to:Person,contents:felt)Person(name:felt,wallet:felt)\";\n * ```\n */\nexport function encodeType(\n  types: TypedData['types'],\n  type: string,\n  revision: Revision = Revision.LEGACY\n): string {\n  const allTypes =\n    revision === Revision.ACTIVE\n      ? { ...types, ...revisionConfiguration[revision].presetTypes }\n      : types;\n  const [primary, ...dependencies] = getDependencies(\n    allTypes,\n    type,\n    undefined,\n    undefined,\n    revision\n  );\n  const newTypes = !primary ? [] : [primary, ...dependencies.sort()];\n\n  const esc = revisionConfiguration[revision].escapeTypeString;\n\n  return newTypes\n    .map((dependency) => {\n      const dependencyElements = allTypes[dependency].map((t) => {\n        const targetType =\n          t.type === 'enum' && revision === Revision.ACTIVE\n            ? (t as StarknetEnumType).contains\n            : t.type;\n        // parentheses handling for enum variant types\n        const typeString = targetType.match(/^\\(.*\\)$/)\n          ? `(${targetType\n              .slice(1, -1)\n              .split(',')\n              .map((e) => (e ? esc(e) : e))\n              .join(',')})`\n          : esc(targetType);\n        return `${esc(t.name)}:${typeString}`;\n      });\n      return `${esc(dependency)}(${dependencyElements})`;\n    })\n    .join('');\n}\n\n/**\n * Get a type string as hash.\n *\n * @param {TypedData['types']} types - The types object containing all defined types.\n * @param {string} type - The name of the type to hash.\n * @param {Revision} [revision=Revision.Legacy] - The revision of the TypedData.\n *\n * @returns {string} The hash.\n *\n * @example\n * ```typescript\n * import typedDataExample from '../../__mocks__/typedData/baseExample.json';\n *\n * const result = getTypeHash(typedDataExample.types, 'StarkNetDomain');\n * // result = \"0x1bfc207425a47a5dfa1a50a4f5241203f50624ca5fdf5e18755765416b8e288\";\n * ```\n */\nexport function getTypeHash(\n  types: TypedData['types'],\n  type: string,\n  revision: Revision = Revision.LEGACY\n): string {\n  return getSelectorFromName(encodeType(types, type, revision));\n}\n\n/**\n * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as a tuple, which consists of\n * an array of ABI compatible types, and an array of corresponding values.\n *\n * @param {TypedData['types']} types - The types object containing all defined types.\n * @param {string} type - The name of the type to encode.\n * @param {unknown} data - The data to encode.\n * @param {Context} [ctx={}] - The context of the encoding process.\n * @param {Revision} [revision=Revision.Legacy] - The revision of the TypedData.\n *\n * @returns {[string, string]} The ABI compatible type and corresponding value.\n *\n * @example\n * ```typescript\n * import { getSelectorFromName } from '../../src/utils/hash';\n *\n * const selector = 'transfer';\n * const selectorHash = getSelectorFromName(selector);\n * const result1 = encodeValue({}, 'felt', selectorHash);\n *\n * // result1 = ['felt', '0x83afd3f4caedc6eebf44246fe54e38c95e3179a5ec9ea81740eca5b482d12e']\n * ```\n */\nexport function encodeValue(\n  types: TypedData['types'],\n  type: string,\n  data: unknown,\n  ctx: Context = {},\n  revision: Revision = Revision.LEGACY\n): [string, string] {\n  if (types[type]) {\n    return [type, getStructHash(types, type, data as TypedData['message'], revision)];\n  }\n\n  if (revisionConfiguration[revision].presetTypes[type]) {\n    return [\n      type,\n      getStructHash(\n        revisionConfiguration[revision].presetTypes,\n        type,\n        data as TypedData['message'],\n        revision\n      ),\n    ];\n  }\n\n  if (type.endsWith('*')) {\n    const hashes: string[] = (data as Array<TypedData['message']>).map(\n      (entry) => encodeValue(types, type.slice(0, -1), entry, undefined, revision)[1]\n    );\n    return [type, revisionConfiguration[revision].hashMethod(hashes)];\n  }\n\n  switch (type) {\n    case 'enum': {\n      if (revision === Revision.ACTIVE) {\n        const [variantKey, variantData] = Object.entries(data as TypedData['message'])[0];\n\n        const parentType = types[ctx.parent as string].find((t) => t.name === ctx.key);\n        const enumType = types[(parentType as StarknetEnumType).contains];\n        const variantType = enumType.find((t) => t.name === variantKey) as StarknetType;\n        const variantIndex = enumType.indexOf(variantType);\n\n        const encodedSubtypes = variantType.type\n          .slice(1, -1)\n          .split(',')\n          .map((subtype, index) => {\n            if (!subtype) return subtype;\n            const subtypeData = (variantData as unknown[])[index];\n            return encodeValue(types, subtype, subtypeData, undefined, revision)[1];\n          });\n        return [\n          type,\n          revisionConfiguration[revision].hashMethod([variantIndex, ...encodedSubtypes]),\n        ];\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'merkletree': {\n      const merkleTreeType = getMerkleTreeType(types, ctx);\n      const structHashes: string[] = (data as Array<TypedData['message']>).map((struct) => {\n        return encodeValue(types, merkleTreeType, struct, undefined, revision)[1];\n      });\n      const { root } = new MerkleTree(\n        structHashes as string[],\n        revisionConfiguration[revision].hashMerkleMethod\n      );\n      return ['felt', root];\n    }\n    case 'selector': {\n      return ['felt', prepareSelector(data as string)];\n    }\n    case 'string': {\n      if (revision === Revision.ACTIVE) {\n        const byteArray = byteArrayFromString(data as string);\n        const elements = [\n          byteArray.data.length,\n          ...byteArray.data,\n          byteArray.pending_word,\n          byteArray.pending_word_len,\n        ];\n        return [type, revisionConfiguration[revision].hashMethod(elements)];\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'i128': {\n      if (revision === Revision.ACTIVE) {\n        const value = BigInt(data as string);\n        assertRange(value, type, RANGE_I128);\n        return [type, getHex(value < 0n ? PRIME + value : value)];\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'timestamp':\n    case 'u128': {\n      if (revision === Revision.ACTIVE) {\n        assertRange(data, type, RANGE_U128);\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'felt':\n    case 'shortstring': {\n      // TODO: should 'shortstring' diverge into directly using encodeShortString()?\n      if (revision === Revision.ACTIVE) {\n        assertRange(getHex(data as string), type, RANGE_FELT);\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'ClassHash':\n    case 'ContractAddress': {\n      if (revision === Revision.ACTIVE) {\n        assertRange(data, type, RANGE_FELT);\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'bool': {\n      if (revision === Revision.ACTIVE) {\n        assert(isBoolean(data), `Type mismatch for ${type} ${data}`);\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    default: {\n      if (revision === Revision.ACTIVE) {\n        throw new Error(`Unsupported type: ${type}`);\n      }\n      return [type, getHex(data as string)];\n    }\n  }\n}\n\n/**\n * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values.\n * All dependent types are automatically encoded.\n *\n * @param {TypedData['types']} types - The types object containing all defined types.\n * @param {string} type - The name of the type to encode.\n * @param {TypedData['message']} data - The data to encode.\n * @param {Revision} [revision=Revision.Legacy] - The revision of the TypedData.\n *\n * @returns {[string[], string[]]} The ABI compatible types and corresponding values.\n */\nexport function encodeData<T extends TypedData>(\n  types: T['types'],\n  type: string,\n  data: T['message'],\n  revision: Revision = Revision.LEGACY\n): [string[], string[]] {\n  const targetType = types[type] ?? revisionConfiguration[revision].presetTypes[type];\n  const [returnTypes, values] = targetType.reduce<[string[], string[]]>(\n    ([ts, vs], field) => {\n      if (\n        data[field.name as keyof T['message']] === undefined ||\n        (data[field.name as keyof T['message']] === null && field.type !== 'enum')\n      ) {\n        throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n      }\n\n      const value = data[field.name as keyof T['message']];\n      const ctx = { parent: type, key: field.name };\n      const [t, encodedValue] = encodeValue(types, field.type, value, ctx, revision);\n\n      return [\n        [...ts, t],\n        [...vs, encodedValue],\n      ];\n    },\n    [['felt'], [getTypeHash(types, type, revision)]]\n  );\n\n  return [returnTypes, values];\n}\n\n/**\n * Get encoded data as a hash. The data should be a key -> value object with all the required values.\n * All dependent types are automatically encoded.\n *\n * @param {TypedData['types']} types - The types object containing all defined types.\n * @param {string} type - The name of the type to hash.\n * @param {TypedData['message']} data - The data to hash.\n * @param {Revision} [revision=Revision.Legacy] - The revision of the TypedData.\n *\n * @returns {string} The hash of the encoded data.\n *\n * @example\n * ```typescript\n * import exampleBaseTypes from '../../__mocks__/typedData/example_baseTypes.json';\n *\n * const result = getStructHash(\n *    exampleBaseTypes.types,\n *    'StarknetDomain',\n *    exampleBaseTypes.domain as StarknetDomain,\n *    TypedDataRevision.ACTIVE\n *  );\n *  // result = \"0x555f72e550b308e50c1a4f8611483a174026c982a9893a05c185eeb85399657\";\n * ```\n */\nexport function getStructHash<T extends TypedData>(\n  types: T['types'],\n  type: string,\n  data: T['message'],\n  revision: Revision = Revision.LEGACY\n): string {\n  return revisionConfiguration[revision].hashMethod(encodeData(types, type, data, revision)[1]);\n}\n\n/**\n * Get the SNIP-12 encoded message to sign, from the typedData object.\n *\n * @param {TypedData} typedData - The TypedData object.\n * @param {BigNumberish} account - The account to sign the message.\n *\n * @returns {string} The hash of the message to sign.\n * @throws Will throw an error if the typedData does not match the JSON schema.\n *\n * @example\n * ```typescript\n * const exampleAddress = \"0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826\";\n * const typedDataStringExample = {\n *  types: {\n *    StarkNetDomain: [\n *      { name: 'name', type: 'felt' },\n *      { name: 'version', type: 'felt' },\n *      { name: 'chainId', type: 'felt' },\n *    ],\n *    Person: [\n *      { name: 'name', type: 'felt' },\n *      { name: 'wallet', type: 'felt' },\n *    ],\n *    String: [\n *      { name: 'len', type: 'felt' },\n *      { name: 'data', type: 'felt*' },\n *    ],\n *    Mail: [\n *      { name: 'from', type: 'Person' },\n *      { name: 'to', type: 'Person' },\n *      { name: 'contents', type: 'String' },\n *    ],\n *  },\n *  primaryType: 'Mail',\n *  domain: {\n *    name: 'StarkNet Mail',\n *    version: '1',\n *    chainId: 1,\n *  },\n *  message: {\n *    from: {\n *      name: 'Cow',\n *      wallet: exampleAddress,\n *    },\n *    to: {\n *      name: 'Bob',\n *      wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *    },\n *    contents: stringToStringStruct(\n *      'this is way longer than just 32 characters, to test if that is possible within a typedData struct.'\n *    ),\n *  },\n * };\n *\n * const result = getMessageHash(typedDataStringExample, exampleAddress);\n * // result = \"0x70338fb11b8f70b68b261de8a322bcb004bd85e88ac47d9147982c7f5ac66fd\"\n * ```\n */\nexport function getMessageHash(typedData: TypedData, account: BigNumberish): string {\n  if (!validateTypedData(typedData)) {\n    throw new Error('Typed data does not match JSON schema');\n  }\n\n  const revision = identifyRevision(typedData) as Revision;\n  const { domain, hashMethod } = revisionConfiguration[revision];\n\n  const message = [\n    encodeShortString('StarkNet Message'),\n    getStructHash(typedData.types, domain, typedData.domain, revision),\n    account,\n    getStructHash(typedData.types, typedData.primaryType, typedData.message, revision),\n  ];\n\n  return hashMethod(message);\n}\n\n/**\n * Checks if a signed EIP712 message is related to an account.\n * Valid for a standard Starknet signature.\n * @param {BigNumberish | TypedData} message a TypedMessage message, or the hash of an EIP712 message (SNIP-12).\n * @param {Signature} signature a WeierstrassSignatureType signature, or an array of 2 strings.\n * @param {BigNumberish} fullPublicKey a number coded on 520 bits (from ec.getFullPublicKey()).\n * @param {BigNumberish} [accountAddress] address of the account that has signed the message. Not needed with a message hash is provided in `message`\n * @returns {boolean} true if the message is verified.\n * @example\n * ```typescript\n * const myTypedMessage: TypedMessage = .... ;\n * const sign: Signature = [\"0x123...abc\", \"0x345...def\"];\n * const fullPubK = \"0x0400b730bd22358612b5a67f8ad52ce80f9e8e893639ade263537e6ef35852e5d3057795f6b090f7c6985ee143f798608a53b3659222c06693c630857a10a92acf\";\n * const accountAddress = \"0x43b7240d227aa2fb8434350b3321c40ac1b88c7067982549e7609870621b535\";\n * const result1 = typedData.verifyMessage(myTypedMessage, sign, fullPubK, accountAddress);\n * const result2 = typedData.verifyMessage(messageHash, sign, fullPubK);\n * // result1 = result2 = true\n * ```\n */\nexport function verifyMessage(\n  message: TypedData,\n  signature: Signature,\n  fullPublicKey: BigNumberish,\n  accountAddress: BigNumberish\n): boolean;\nexport function verifyMessage(\n  message: BigNumberish,\n  signature: Signature,\n  fullPublicKey: BigNumberish\n): boolean;\nexport function verifyMessage(\n  message: BigNumberish | TypedData,\n  signature: Signature,\n  fullPublicKey: BigNumberish,\n  accountAddress?: BigNumberish\n): boolean {\n  const isTypedData = validateTypedData(message);\n  if (!isBigNumberish(message) && !isTypedData) {\n    throw new Error('message has a wrong format.');\n  }\n  if (isTypedData && accountAddress === undefined) {\n    throw new Error(\n      'When providing a TypedData in message parameter, the accountAddress parameter has to be provided.'\n    );\n  }\n  if (isTypedData && !isBigNumberish(accountAddress)) {\n    throw new Error('accountAddress shall be a BigNumberish');\n  }\n  const messageHash = isTypedData\n    ? getMessageHash(message, accountAddress as BigNumberish)\n    : toHex(message);\n  const sign = Array.isArray(signature)\n    ? new starkCurve.Signature(BigInt(signature[0]), BigInt(signature[1]))\n    : signature;\n  const fullPubKey = toHex(fullPublicKey);\n  const isValid = starkCurve.verify(sign, messageHash, fullPubKey);\n  return isValid;\n}\n","import { BigNumberish } from '../types';\nimport { computePedersenHash } from './hash';\n\nexport class MerkleTree {\n  public leaves: string[];\n\n  public branches: string[][] = [];\n\n  public root: string;\n\n  public hashMethod: (a: BigNumberish, b: BigNumberish) => string;\n\n  /**\n   * Create a Merkle tree\n   *\n   * @param leafHashes hex-string array\n   * @param hashMethod hash method to use, default: Pedersen\n   * @returns created Merkle tree\n   * @example\n   * ```typescript\n   * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];\n   * const tree = new MerkleTree(leaves);\n   * // tree = {\n   * //   branches: [['0x5bb9440e2...', '0x262697b88...', ...], ['0x38118a340...', ...], ...],\n   * //   leaves: ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'],\n   * //   root: '0x7f748c75e5bdb7ae28013f076b8ab650c4e01d3530c6e5ab665f9f1accbe7d4',\n   * //   hashMethod: [Function computePedersenHash],\n   * // }\n   * ```\n   */\n  constructor(\n    leafHashes: string[],\n    hashMethod: (a: BigNumberish, b: BigNumberish) => string = computePedersenHash\n  ) {\n    this.hashMethod = hashMethod;\n    this.leaves = leafHashes;\n    this.root = this.build(leafHashes);\n  }\n\n  /** @ignore */\n  private build(leaves: string[]): string {\n    if (leaves.length === 1) {\n      return leaves[0];\n    }\n    if (leaves.length !== this.leaves.length) {\n      this.branches.push(leaves);\n    }\n    const newLeaves: string[] = [];\n    for (let i = 0; i < leaves.length; i += 2) {\n      if (i + 1 === leaves.length) {\n        newLeaves.push(MerkleTree.hash(leaves[i], '0x0', this.hashMethod));\n      } else {\n        newLeaves.push(MerkleTree.hash(leaves[i], leaves[i + 1], this.hashMethod));\n      }\n    }\n    return this.build(newLeaves);\n  }\n\n  /**\n   * Calculate hash from ordered a and b, Pedersen hash default\n   *\n   * @param a first value\n   * @param b second value\n   * @param hashMethod hash method to use, default: Pedersen\n   * @returns result of the hash function\n   * @example\n   * ```typescript\n   * const result1 = MerkleTree.hash('0xabc', '0xdef');\n   * // result1 = '0x484f029da7914ada038b1adf67fc83632364a3ebc2cd9349b41ab61626d9e82'\n   *\n   * const customHashMethod = (a, b) => `custom_${a}_${b}`;\n   * const result2 = MerkleTree.hash('0xabc', '0xdef', customHashMethod);\n   * // result2 = 'custom_2748_3567'\n   * ```\n   */\n  static hash(\n    a: BigNumberish,\n    b: BigNumberish,\n    hashMethod: (a: BigNumberish, b: BigNumberish) => string = computePedersenHash\n  ) {\n    const [aSorted, bSorted] = [BigInt(a), BigInt(b)].sort((x, y) => (x >= y ? 1 : -1));\n    return hashMethod(aSorted, bSorted);\n  }\n\n  /**\n   * Calculates the merkle membership proof path\n   *\n   * @param leaf hex-string\n   * @param branch hex-string array\n   * @param hashPath hex-string array\n   * @returns collection of merkle proof hex-string hashes\n   * @example\n   * ```typescript\n   * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];\n   * const tree = new MerkleTree(leaves);\n   * const result = tree.getProof('0x3');\n   * // result = [\n   * //   '0x4',\n   * //   '0x5bb9440e27889a364bcb678b1f679ecd1347acdedcbf36e83494f857cc58026',\n   * //   '0x8c0e46dd2df9aaf3a8ebfbc25408a582ad7fa7171f0698ddbbc5130b4b4e60',\n   * // ]\n   * ```\n   */\n  public getProof(leaf: string, branch = this.leaves, hashPath: string[] = []): string[] {\n    const index = branch.indexOf(leaf);\n    if (index === -1) {\n      throw new Error('leaf not found');\n    }\n    if (branch.length === 1) {\n      return hashPath;\n    }\n    const isLeft = index % 2 === 0;\n    const neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? '0x0';\n    const newHashPath = [...hashPath, neededBranch];\n    const currentBranchLevelIndex =\n      this.leaves.length === branch.length\n        ? -1\n        : this.branches.findIndex((b) => b.length === branch.length);\n    const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [this.root];\n    return this.getProof(\n      MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf, this.hashMethod),\n      nextBranch,\n      newHashPath\n    );\n  }\n}\n\n/**\n * Tests a Merkle tree path\n *\n * @param root hex-string\n * @param leaf hex-string\n * @param path hex-string array\n * @param hashMethod hash method to use, default: Pedersen\n * @returns true if the path is valid, false otherwise\n * @example\n * ```typescript\n * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];\n * const tree = new MerkleTree(leaves);\n * const result = proofMerklePath(tree.root, '0x3', [\n *   '0x4',\n *   '0x5bb9440e27889a364bcb678b1f679ecd1347acdedcbf36e83494f857cc58026',\n *   '0x8c0e46dd2df9aaf3a8ebfbc25408a582ad7fa7171f0698ddbbc5130b4b4e60',\n * ]);\n * // result = true\n * ```\n */\nexport function proofMerklePath(\n  root: string,\n  leaf: string,\n  path: string[],\n  hashMethod: (a: BigNumberish, b: BigNumberish) => string = computePedersenHash\n): boolean {\n  if (path.length === 0) {\n    return root === leaf;\n  }\n  const [next, ...rest] = path;\n  return proofMerklePath(root, MerkleTree.hash(leaf, next, hashMethod), rest, hashMethod);\n}\n","import type { SPEC } from 'starknet-types-07';\n\nimport { RPC06, RPC07, RpcChannel } from '../channel';\nimport {\n  AccountInvocations,\n  BigNumberish,\n  Block,\n  BlockIdentifier,\n  BlockTag,\n  Call,\n  ContractClassResponse,\n  ContractClassIdentifier,\n  ContractVersion,\n  DeclareContractTransaction,\n  DeployAccountContractTransaction,\n  GetBlockResponse,\n  GetTxReceiptResponseWithoutHelper,\n  Invocation,\n  Invocations,\n  InvocationsDetailsWithNonce,\n  PendingBlock,\n  PendingStateUpdate,\n  RPC,\n  RpcProviderOptions,\n  StateUpdate,\n  StateUpdateResponse,\n  TransactionType,\n  getContractVersionOptions,\n  getEstimateFeeBulkOptions,\n  getSimulateTransactionOptions,\n  type Signature,\n  type TypedData,\n  waitForTransactionOptions,\n} from '../types';\nimport type { TransactionWithHash } from '../types/provider/spec';\nimport assert from '../utils/assert';\nimport { CallData } from '../utils/calldata';\nimport { getAbiContractVersion } from '../utils/calldata/cairo';\nimport { extractContractHashes, isSierra } from '../utils/contract';\nimport { solidityUint256PackedKeccak256 } from '../utils/hash';\nimport { isBigNumberish, toBigInt, toHex } from '../utils/num';\nimport { wait } from '../utils/provider';\nimport { RPCResponseParser } from '../utils/responseParser/rpc';\nimport { formatSignature } from '../utils/stark';\nimport { GetTransactionReceiptResponse, ReceiptTx } from '../utils/transactionReceipt';\nimport { getMessageHash, validateTypedData } from '../utils/typedData';\nimport { LibraryError } from '../utils/errors';\nimport { ProviderInterface } from './interface';\n\nexport class RpcProvider implements ProviderInterface {\n  public responseParser: RPCResponseParser;\n\n  public channel: RPC07.RpcChannel | RPC06.RpcChannel;\n\n  constructor(optionsOrProvider?: RpcProviderOptions | ProviderInterface | RpcProvider) {\n    if (optionsOrProvider && 'channel' in optionsOrProvider) {\n      this.channel = optionsOrProvider.channel;\n      this.responseParser =\n        'responseParser' in optionsOrProvider\n          ? optionsOrProvider.responseParser\n          : new RPCResponseParser();\n    } else {\n      this.channel = new RpcChannel({ ...optionsOrProvider, waitMode: false });\n      this.responseParser = new RPCResponseParser(optionsOrProvider?.feeMarginPercentage);\n    }\n  }\n\n  public fetch(method: string, params?: object, id: string | number = 0) {\n    return this.channel.fetch(method, params, id);\n  }\n\n  public async getChainId() {\n    return this.channel.getChainId();\n  }\n\n  public async getSpecVersion() {\n    return this.channel.getSpecVersion();\n  }\n\n  public async getNonceForAddress(\n    contractAddress: BigNumberish,\n    blockIdentifier?: BlockIdentifier\n  ) {\n    return this.channel.getNonceForAddress(contractAddress, blockIdentifier);\n  }\n\n  public async getBlock(): Promise<PendingBlock>;\n  public async getBlock(blockIdentifier: 'pending'): Promise<PendingBlock>;\n  public async getBlock(blockIdentifier: 'latest'): Promise<Block>;\n  public async getBlock(blockIdentifier?: BlockIdentifier): Promise<GetBlockResponse>;\n  public async getBlock(blockIdentifier?: BlockIdentifier) {\n    return this.channel\n      .getBlockWithTxHashes(blockIdentifier)\n      .then(this.responseParser.parseGetBlockResponse);\n  }\n\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  public async getBlockLatestAccepted() {\n    return this.channel.getBlockLatestAccepted();\n  }\n\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  public async getBlockNumber() {\n    return this.channel.getBlockNumber();\n  }\n\n  public async getBlockWithTxHashes(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockWithTxHashes(blockIdentifier);\n  }\n\n  public async getBlockWithTxs(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockWithTxs(blockIdentifier);\n  }\n\n  /**\n   * Pause the execution of the script until a specified block is created.\n   * @param {BlockIdentifier} blockIdentifier bloc number (BigNumberish) or 'pending' or 'latest'.\n   * Use of 'latest\" or of a block already created will generate no pause.\n   * @param {number} [retryInterval] number of milliseconds between 2 requests to the node\n   * @example\n   * ```typescript\n   * await myProvider.waitForBlock();\n   * // wait the creation of the pending block\n   * ```\n   */\n  public async waitForBlock(\n    blockIdentifier: BlockIdentifier = 'pending',\n    retryInterval: number = 5000\n  ) {\n    if (blockIdentifier === BlockTag.LATEST) return;\n    const currentBlock = await this.getBlockNumber();\n    const targetBlock =\n      blockIdentifier === BlockTag.PENDING\n        ? currentBlock + 1\n        : Number(toHex(blockIdentifier as BigNumberish));\n    if (targetBlock <= currentBlock) return;\n    const { retries } = this.channel;\n    let retriesCount = retries;\n    let isTargetBlock: boolean = false;\n    while (!isTargetBlock) {\n      // eslint-disable-next-line no-await-in-loop\n      const currBlock = await this.getBlockNumber();\n      if (currBlock === targetBlock) {\n        isTargetBlock = true;\n      } else {\n        // eslint-disable-next-line no-await-in-loop\n        await wait(retryInterval);\n      }\n      retriesCount -= 1;\n      if (retriesCount <= 0) {\n        throw new Error(`waitForBlock() timed-out after ${retries} tries.`);\n      }\n    }\n  }\n\n  public async getL1GasPrice(blockIdentifier?: BlockIdentifier) {\n    return this.channel\n      .getBlockWithTxHashes(blockIdentifier)\n      .then(this.responseParser.parseL1GasPriceResponse);\n  }\n\n  public async getL1MessageHash(l2TxHash: BigNumberish): Promise<string> {\n    const transaction = (await this.channel.getTransactionByHash(l2TxHash)) as TransactionWithHash;\n    assert(transaction.type === 'L1_HANDLER', 'This L2 transaction is not a L1 message.');\n    const { calldata, contract_address, entry_point_selector, nonce } =\n      transaction as SPEC.L1_HANDLER_TXN;\n    const params = [\n      calldata[0],\n      contract_address,\n      nonce,\n      entry_point_selector,\n      calldata.length - 1,\n      ...calldata.slice(1),\n    ];\n    return solidityUint256PackedKeccak256(params);\n  }\n\n  public async getBlockWithReceipts(blockIdentifier?: BlockIdentifier) {\n    if (this.channel instanceof RPC06.RpcChannel)\n      throw new LibraryError('Unsupported method for RPC version');\n\n    return this.channel.getBlockWithReceipts(blockIdentifier);\n  }\n\n  public getStateUpdate = this.getBlockStateUpdate;\n\n  public async getBlockStateUpdate(): Promise<PendingStateUpdate>;\n  public async getBlockStateUpdate(blockIdentifier: 'pending'): Promise<PendingStateUpdate>;\n  public async getBlockStateUpdate(blockIdentifier: 'latest'): Promise<StateUpdate>;\n  public async getBlockStateUpdate(blockIdentifier?: BlockIdentifier): Promise<StateUpdateResponse>;\n  public async getBlockStateUpdate(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockStateUpdate(blockIdentifier);\n  }\n\n  public async getBlockTransactionsTraces(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockTransactionsTraces(blockIdentifier);\n  }\n\n  public async getBlockTransactionCount(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockTransactionCount(blockIdentifier);\n  }\n\n  /**\n   * Return transactions from pending block\n   * @deprecated Instead use getBlock(BlockTag.PENDING); (will be removed in next minor version)\n   * Utility method, same result can be achieved using getBlockWithTxHashes(BlockTag.pending);\n   */\n  public async getPendingTransactions() {\n    const { transactions } = await this.getBlockWithTxHashes(BlockTag.PENDING).then(\n      this.responseParser.parseGetBlockResponse\n    );\n    return Promise.all(transactions.map((it: any) => this.getTransactionByHash(it)));\n  }\n\n  public async getTransaction(txHash: BigNumberish) {\n    return this.channel.getTransactionByHash(txHash);\n  }\n\n  public async getTransactionByHash(txHash: BigNumberish) {\n    return this.channel.getTransactionByHash(txHash);\n  }\n\n  public async getTransactionByBlockIdAndIndex(blockIdentifier: BlockIdentifier, index: number) {\n    return this.channel.getTransactionByBlockIdAndIndex(blockIdentifier, index);\n  }\n\n  public async getTransactionReceipt(txHash: BigNumberish): Promise<GetTransactionReceiptResponse> {\n    const txReceiptWoHelper = await this.channel.getTransactionReceipt(txHash);\n    const txReceiptWoHelperModified: GetTxReceiptResponseWithoutHelper =\n      this.responseParser.parseTransactionReceipt(txReceiptWoHelper);\n    return new ReceiptTx(txReceiptWoHelperModified) as GetTransactionReceiptResponse;\n  }\n\n  public async getTransactionTrace(txHash: BigNumberish) {\n    return this.channel.getTransactionTrace(txHash);\n  }\n\n  /**\n   * Get the status of a transaction\n   */\n  public async getTransactionStatus(transactionHash: BigNumberish) {\n    return this.channel.getTransactionStatus(transactionHash);\n  }\n\n  /**\n   * @param invocations AccountInvocations\n   * @param options blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  public async getSimulateTransaction(\n    invocations: AccountInvocations,\n    options?: getSimulateTransactionOptions\n  ) {\n    // can't be named simulateTransaction because of argument conflict with account\n    return this.channel\n      .simulateTransaction(invocations, options)\n      .then((r) => this.responseParser.parseSimulateTransactionResponse(r));\n  }\n\n  public async waitForTransaction(\n    txHash: BigNumberish,\n    options?: waitForTransactionOptions\n  ): Promise<GetTransactionReceiptResponse> {\n    const receiptWoHelper = (await this.channel.waitForTransaction(\n      txHash,\n      options\n    )) as GetTxReceiptResponseWithoutHelper;\n\n    return new ReceiptTx(receiptWoHelper) as GetTransactionReceiptResponse;\n  }\n\n  public async getStorageAt(\n    contractAddress: BigNumberish,\n    key: BigNumberish,\n    blockIdentifier?: BlockIdentifier\n  ) {\n    return this.channel.getStorageAt(contractAddress, key, blockIdentifier);\n  }\n\n  public async getClassHashAt(contractAddress: BigNumberish, blockIdentifier?: BlockIdentifier) {\n    return this.channel.getClassHashAt(contractAddress, blockIdentifier);\n  }\n\n  public async getClassByHash(classHash: BigNumberish) {\n    return this.getClass(classHash);\n  }\n\n  public async getClass(classHash: BigNumberish, blockIdentifier?: BlockIdentifier) {\n    return this.channel\n      .getClass(classHash, blockIdentifier)\n      .then(this.responseParser.parseContractClassResponse);\n  }\n\n  public async getClassAt(contractAddress: BigNumberish, blockIdentifier?: BlockIdentifier) {\n    return this.channel\n      .getClassAt(contractAddress, blockIdentifier)\n      .then(this.responseParser.parseContractClassResponse);\n  }\n\n  public async getContractVersion(\n    contractAddress: BigNumberish,\n    classHash?: undefined,\n    options?: getContractVersionOptions\n  ): Promise<ContractVersion>;\n  public async getContractVersion(\n    contractAddress: undefined,\n    classHash: BigNumberish,\n    options?: getContractVersionOptions\n  ): Promise<ContractVersion>;\n\n  public async getContractVersion(\n    contractAddress?: BigNumberish,\n    classHash?: BigNumberish,\n    {\n      blockIdentifier = this.channel.blockIdentifier,\n      compiler = true,\n    }: getContractVersionOptions = {}\n  ): Promise<ContractVersion> {\n    let contractClass: ContractClassResponse;\n    if (contractAddress) {\n      contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n    } else if (classHash) {\n      contractClass = await this.getClass(classHash, blockIdentifier);\n    } else {\n      throw Error('getContractVersion require contractAddress or classHash');\n    }\n\n    if (isSierra(contractClass)) {\n      if (compiler) {\n        const abiTest = getAbiContractVersion(contractClass.abi);\n        return { cairo: '1', compiler: abiTest.compiler };\n      }\n      return { cairo: '1', compiler: undefined };\n    }\n    return { cairo: '0', compiler: '0' };\n  }\n\n  /**\n   * @deprecated use get*type*EstimateFee (will be refactored based on type after sequencer deprecation)\n   */\n  public async getEstimateFee(\n    invocation: Invocation,\n    invocationDetails: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ) {\n    return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate);\n  }\n\n  public async getInvokeEstimateFee(\n    invocation: Invocation,\n    invocationDetails: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ) {\n    return this.channel\n      .getEstimateFee(\n        [\n          {\n            type: TransactionType.INVOKE,\n            ...invocation,\n            ...invocationDetails,\n          },\n        ],\n        { blockIdentifier, skipValidate }\n      )\n      .then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n\n  public async getDeclareEstimateFee(\n    invocation: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ) {\n    return this.channel\n      .getEstimateFee(\n        [\n          {\n            type: TransactionType.DECLARE,\n            ...invocation,\n            ...details,\n          },\n        ],\n        { blockIdentifier, skipValidate }\n      )\n      .then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n\n  public async getDeployAccountEstimateFee(\n    invocation: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ) {\n    return this.channel\n      .getEstimateFee(\n        [\n          {\n            type: TransactionType.DEPLOY_ACCOUNT,\n            ...invocation,\n            ...details,\n          },\n        ],\n        { blockIdentifier, skipValidate }\n      )\n      .then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n\n  public async getEstimateFeeBulk(\n    invocations: AccountInvocations,\n    options: getEstimateFeeBulkOptions\n  ) {\n    return this.channel\n      .getEstimateFee(invocations, options)\n      .then((r) => this.responseParser.parseFeeEstimateBulkResponse(r));\n  }\n\n  public async invokeFunction(\n    functionInvocation: Invocation,\n    details: InvocationsDetailsWithNonce\n  ) {\n    return this.channel.invoke(functionInvocation, details) as Promise<RPC.InvokedTransaction>;\n  }\n\n  public async declareContract(\n    transaction: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    return this.channel.declare(transaction, details) as Promise<RPC.DeclaredTransaction>;\n  }\n\n  public async deployAccountContract(\n    transaction: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    return this.channel.deployAccount(\n      transaction,\n      details\n    ) as Promise<RPC.DeployedAccountTransaction>;\n  }\n\n  public async callContract(call: Call, blockIdentifier?: BlockIdentifier) {\n    return this.channel.callContract(call, blockIdentifier);\n  }\n\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  public async estimateMessageFee(message: RPC.L1Message, blockIdentifier?: BlockIdentifier) {\n    return this.channel.estimateMessageFee(message, blockIdentifier);\n  }\n\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  public async getSyncingStats() {\n    return this.channel.getSyncingStats();\n  }\n\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  public async getEvents(eventFilter: RPC.EventFilter) {\n    return this.channel.getEvents(eventFilter);\n  }\n\n  /**\n   * Verify in Starknet a signature of a TypedData object or of a given hash.\n   * @param {BigNumberish | TypedData} message TypedData object to be verified, or message hash to be verified.\n   * @param {Signature} signature signature of the message.\n   * @param {BigNumberish} accountAddress address of the account that has signed the message.\n   * @param {string} [signatureVerificationFunctionName] if account contract with non standard account verification function name.\n   * @param { okResponse: string[]; nokResponse: string[]; error: string[] } [signatureVerificationResponse] if account contract with non standard response of verification function.\n   * @returns\n   * ```typescript\n   * const myTypedMessage: TypedMessage = .... ;\n   * const messageHash = typedData.getMessageHash(myTypedMessage,accountAddress);\n   * const sign: WeierstrassSignatureType = ec.starkCurve.sign(messageHash, privateKey);\n   * const accountAddress = \"0x43b7240d227aa2fb8434350b3321c40ac1b88c7067982549e7609870621b535\";\n   * const result1 = myRpcProvider.verifyMessageInStarknet(myTypedMessage, sign, accountAddress);\n   * const result2 = myRpcProvider.verifyMessageInStarknet(messageHash, sign, accountAddress);\n   * // result1 = result2 = true\n   * ```\n   */\n  public async verifyMessageInStarknet(\n    message: BigNumberish | TypedData,\n    signature: Signature,\n    accountAddress: BigNumberish,\n    signatureVerificationFunctionName?: string,\n    signatureVerificationResponse?: { okResponse: string[]; nokResponse: string[]; error: string[] }\n  ): Promise<boolean> {\n    const isTypedData = validateTypedData(message);\n    if (!isBigNumberish(message) && !isTypedData) {\n      throw new Error('message has a wrong format.');\n    }\n    if (!isBigNumberish(accountAddress)) {\n      throw new Error('accountAddress shall be a BigNumberish');\n    }\n    const messageHash = isTypedData ? getMessageHash(message, accountAddress) : toHex(message);\n    // HOTFIX: Accounts should conform to SNIP-6\n    // (https://github.com/starknet-io/SNIPs/blob/f6998f779ee2157d5e1dea36042b08062093b3c5/SNIPS/snip-6.md?plain=1#L61),\n    // but they don't always conform. Also, the SNIP doesn't standardize the response if the signature isn't valid.\n    const knownSigVerificationFName = signatureVerificationFunctionName\n      ? [signatureVerificationFunctionName]\n      : ['isValidSignature', 'is_valid_signature'];\n    const knownSignatureResponse = signatureVerificationResponse || {\n      okResponse: [\n        // any non-nok response is true\n      ],\n      nokResponse: [\n        '0x0', // Devnet\n        '0x00', // OpenZeppelin 0.7.0 to 0.9.0 invalid signature\n      ],\n      error: [\n        'argent/invalid-signature', // ArgentX 0.3.0 to 0.3.1\n        'is invalid, with respect to the public key', // OpenZeppelin until 0.6.1, Braavos 0.0.11\n        'INVALID_SIG', // Braavos 1.0.0\n      ],\n    };\n    let error: any;\n\n    // eslint-disable-next-line no-restricted-syntax\n    for (const SigVerificationFName of knownSigVerificationFName) {\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        const resp = await this.callContract({\n          contractAddress: toHex(accountAddress),\n          entrypoint: SigVerificationFName,\n          calldata: CallData.compile({\n            hash: toBigInt(messageHash).toString(),\n            signature: formatSignature(signature),\n          }),\n        });\n        // Response NOK Signature\n        if (knownSignatureResponse.nokResponse.includes(resp[0].toString())) {\n          return false;\n        }\n        // Response OK Signature\n        // Empty okResponse assume all non-nok responses are valid signatures\n        // OpenZeppelin 0.7.0 to 0.9.0, ArgentX 0.3.0 to 0.3.1 & Braavos Cairo 0.0.11 to 1.0.0 valid signature\n        if (\n          knownSignatureResponse.okResponse.length === 0 ||\n          knownSignatureResponse.okResponse.includes(resp[0].toString())\n        ) {\n          return true;\n        }\n        throw Error('signatureVerificationResponse Error: response is not part of known responses');\n      } catch (err) {\n        // Known NOK Errors\n        if (\n          knownSignatureResponse.error.some((errMessage) =>\n            (err as Error).message.includes(errMessage)\n          )\n        ) {\n          return false;\n        }\n        // Unknown Error\n        error = err;\n      }\n    }\n\n    throw Error(`Signature verification Error: ${error}`);\n  }\n\n  /**\n   * Test if class is already declared from ContractClassIdentifier\n   * Helper method using getClass\n   * @param ContractClassIdentifier\n   * @param blockIdentifier\n   */\n  public async isClassDeclared(\n    contractClassIdentifier: ContractClassIdentifier,\n    blockIdentifier?: BlockIdentifier\n  ) {\n    let classHash: string;\n    if (!contractClassIdentifier.classHash && 'contract' in contractClassIdentifier) {\n      const hashes = extractContractHashes(contractClassIdentifier);\n      classHash = hashes.classHash;\n    } else if (contractClassIdentifier.classHash) {\n      classHash = contractClassIdentifier.classHash;\n    } else {\n      throw Error('contractClassIdentifier type not satisfied');\n    }\n\n    try {\n      const result = await this.getClass(classHash, blockIdentifier);\n      return result instanceof Object;\n    } catch (error) {\n      if (error instanceof LibraryError) {\n        return false;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Build bulk invocations with auto-detect declared class\n   * 1. Test if class is declared if not declare it preventing already declared class error and not declared class errors\n   * 2. Order declarations first\n   * @param invocations\n   */\n  public async prepareInvocations(invocations: Invocations) {\n    const bulk: Invocations = [];\n    // Build new ordered array\n    // eslint-disable-next-line no-restricted-syntax\n    for (const invocation of invocations) {\n      if (invocation.type === TransactionType.DECLARE) {\n        // Test if already declared\n        // eslint-disable-next-line no-await-in-loop\n        const isDeclared = await this.isClassDeclared(\n          'payload' in invocation ? invocation.payload : invocation\n        );\n        if (!isDeclared) {\n          bulk.unshift(invocation);\n        }\n      } else {\n        bulk.push(invocation);\n      }\n    }\n    return bulk;\n  }\n}\n","/* eslint-disable max-classes-per-file */\nimport { Mixin } from 'ts-mixer';\n\nimport { RpcProvider as BaseRpcProvider } from '../rpc';\nimport { StarknetId } from './starknetId';\n\nexport class RpcProvider extends Mixin(BaseRpcProvider, StarknetId) {}\n","import { StarknetChainId, ZERO } from '../global/constants';\nimport { BigNumberish } from '../types';\nimport { tuple } from './calldata/cairo';\nimport { CairoCustomEnum } from './calldata/enum/CairoCustomEnum';\n/* eslint-disable no-param-reassign */\n\nconst basicAlphabet = 'abcdefghijklmnopqrstuvwxyz0123456789-';\nconst basicSizePlusOne = BigInt(basicAlphabet.length + 1);\nconst bigAlphabet = '';\nconst basicAlphabetSize = BigInt(basicAlphabet.length);\nconst bigAlphabetSize = BigInt(bigAlphabet.length);\nconst bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);\n\nfunction extractStars(str: string): [string, number] {\n  let k = 0;\n  while (str.endsWith(bigAlphabet[bigAlphabet.length - 1])) {\n    str = str.substring(0, str.length - 1);\n    k += 1;\n  }\n  return [str, k];\n}\n\n/**\n * Decodes an array of BigInts into a string using the given algorithm.\n * @param {bigint[]} encoded The encoded array of BigInts.\n * @return {string} The decoded string.\n * @example\n * ```typescript\n * const result = starknetId.useDecoded([3015206943634620n]);\n * // result = \"starknetjs.stark\"\n * ```\n */\nexport function useDecoded(encoded: bigint[]): string {\n  let decoded = '';\n\n  encoded.forEach((subdomain) => {\n    while (subdomain !== ZERO) {\n      const code = subdomain % basicSizePlusOne;\n      subdomain /= basicSizePlusOne;\n      if (code === BigInt(basicAlphabet.length)) {\n        const nextSubdomain = subdomain / bigAlphabetSizePlusOne;\n        if (nextSubdomain === ZERO) {\n          const code2 = subdomain % bigAlphabetSizePlusOne;\n          subdomain = nextSubdomain;\n          if (code2 === ZERO) decoded += basicAlphabet[0];\n          else decoded += bigAlphabet[Number(code2) - 1];\n        } else {\n          const code2 = subdomain % bigAlphabetSize;\n          decoded += bigAlphabet[Number(code2)];\n          subdomain /= bigAlphabetSize;\n        }\n      } else decoded += basicAlphabet[Number(code)];\n    }\n\n    const [str, k] = extractStars(decoded);\n    if (k)\n      decoded =\n        str +\n        (k % 2 === 0\n          ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) +\n            bigAlphabet[0] +\n            basicAlphabet[1]\n          : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));\n    decoded += '.';\n  });\n\n  if (!decoded) {\n    return decoded;\n  }\n\n  return decoded.concat('stark');\n}\n\n/**\n * Encodes a string into a bigint value.\n *\n * @param {string} decoded The string to be encoded.\n * @returns {bigint} The encoded bigint value.\n * @example\n * ```typescript\n * const result = starknetId.useEncoded(\"starknet.js\");\n * // result = 3015206943634620n\n * ```\n */\nexport function useEncoded(decoded: string): bigint {\n  let encoded = BigInt(0);\n  let multiplier = BigInt(1);\n\n  if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {\n    const [str, k] = extractStars(decoded.substring(0, decoded.length - 2));\n    decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));\n  } else {\n    const [str, k] = extractStars(decoded);\n    if (k) decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));\n  }\n\n  for (let i = 0; i < decoded.length; i += 1) {\n    const char = decoded[i];\n    const index = basicAlphabet.indexOf(char);\n    const bnIndex = BigInt(basicAlphabet.indexOf(char));\n\n    if (index !== -1) {\n      // add encoded + multiplier * index\n      if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {\n        encoded += multiplier * basicAlphabetSize;\n        multiplier *= basicSizePlusOne;\n        // add 0\n        multiplier *= basicSizePlusOne;\n      } else {\n        encoded += multiplier * bnIndex;\n        multiplier *= basicSizePlusOne;\n      }\n    } else if (bigAlphabet.indexOf(char) !== -1) {\n      // add encoded + multiplier * (basicAlphabetSize)\n      encoded += multiplier * basicAlphabetSize;\n      multiplier *= basicSizePlusOne;\n      // add encoded + multiplier * index\n      const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);\n      encoded += multiplier * BigInt(newid);\n      multiplier *= bigAlphabetSize;\n    }\n  }\n\n  return encoded;\n}\n\nexport const StarknetIdContract = {\n  MAINNET: '0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678',\n  TESTNET_SEPOLIA: '0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474',\n} as const;\n\n/**\n * Returns the Starknet ID contract address based on the provided chain ID.\n *\n * @param {StarknetChainId} chainId The chain ID of the Starknet network.\n * @return {string} The Starknet ID contract address.\n * @throws {Error} Throws an error if the Starknet ID contract is not deployed on the network.\n * @example\n * ```typescript\n * const result = starknetId.getStarknetIdContract(constants.StarknetChainId.SN_SEPOLIA);\n * // result = \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\"\n * ```\n */\nexport function getStarknetIdContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdContract.MAINNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error('Starknet.id is not yet deployed on this network');\n  }\n}\n\nexport const StarknetIdIdentityContract = {\n  MAINNET: '0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af',\n  TESTNET_SEPOLIA: '0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda',\n} as const;\n\n/**\n * Returns the Starknet ID identity contract address for the given chain ID.\n *\n * @param {StarknetChainId} chainId The chain ID for the specified network.\n *\n * @return {string} The Starknet ID identity contract address for the specified network.\n *\n * @throws {Error} If the Starknet ID verifier contract is not deployed on the network.\n * @example\n * ```typescript\n * const result = starknetId.getStarknetIdIdentityContract(constants.StarknetChainId.SN_SEPOLIA);\n * // result = \"0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda\"\n * ```\n */\nexport function getStarknetIdIdentityContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdIdentityContract.MAINNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdIdentityContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error('Starknet.id verifier contract is not yet deployed on this network');\n  }\n}\n\nexport const StarknetIdMulticallContract =\n  '0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970';\n\n/**\n * Returns the Starknet.id multicall contract address based on the provided chainId.\n *\n * @param {StarknetChainId} chainId - The chainId of the network.\n * @return {string} - The address of the Starknet.id multicall contract.\n * @throws {Error} - If the Starknet.id multicall contract is not deployed on the network.\n * @example\n * ```typescript\n * const result = starknetId.getStarknetIdMulticallContract(constants.StarknetChainId.SN_SEPOLIA);\n * // result = \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\"\n * ```\n */\nexport function getStarknetIdMulticallContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdMulticallContract;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdMulticallContract;\n\n    default:\n      throw new Error('Starknet.id multicall contract is not yet deployed on this network');\n  }\n}\n\nexport const StarknetIdVerifierContract = {\n  MAINNET: '0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf',\n  TESTNET_SEPOLIA: '0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566',\n} as const;\n\n/**\n * Returns the address of the Starknet ID Verifier contract based on the specified chain ID.\n *\n * @param {StarknetChainId} chainId - The ID of the Starknet chain.\n * @return {string} - The address of the Starknet ID Verifier contract.\n * @throws {Error} - If the Starknet ID Verifier contract is not deployed on the specified network.\n * @example\n * ```typescript\n * const result = starknetId.getStarknetIdVerifierContract(constants.StarknetChainId.SN_SEPOLIA);\n * // result = \"0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566\"\n * ```\n */\nexport function getStarknetIdVerifierContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdVerifierContract.MAINNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdVerifierContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error('Starknet.id verifier contract is not yet deployed on this network');\n  }\n}\n\nexport const StarknetIdPfpContract = {\n  MAINNET: '0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7',\n  TESTNET_SEPOLIA: '0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02',\n} as const;\n\n/**\n * Retrieves the contract address of the Starknet.id profile picture verifier contract based on the given chain ID.\n *\n * @param {StarknetChainId} chainId - The chain ID of the network.\n * @returns {string} - The contract address of the Starknet.id profile picture verifier contract.\n * @throws {Error} - Throws an error if the Starknet.id profile picture verifier contract is not yet deployed on the network.\n * @example\n * ```typescript\n * const result = starknetId.getStarknetIdPfpContract(constants.StarknetChainId.SN_SEPOLIA);\n * // result = \"0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02\"\n * ```\n */\nexport function getStarknetIdPfpContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdPfpContract.MAINNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdPfpContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error(\n        'Starknet.id profile picture verifier contract is not yet deployed on this network'\n      );\n  }\n}\n\nexport const StarknetIdPopContract = {\n  MAINNET: '0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4',\n  TESTNET_SEPOLIA: '0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a',\n} as const;\n\n/**\n * Retrieves the Starknet ID Proof of Personhood (IdPop) verifier contract address for the given chain ID.\n *\n * @param {StarknetChainId} chainId - The chain ID of the Starknet network.\n * @return {string} - The Starknet ID Pop contract address.\n * @throws {Error} - If the Starknet ID Pop contract is not deployed on the specified network.\n * @example\n * ```typescript\n * const result = starknetId.getStarknetIdPopContract(constants.StarknetChainId.SN_SEPOLIA);\n * // result = \"0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a\"\n * ```\n */\nexport function getStarknetIdPopContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdPopContract.MAINNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdPopContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error(\n        'Starknet.id proof of personhood verifier contract is not yet deployed on this network'\n      );\n  }\n}\n\n/**\n * Returns a CairoCustomEnum object.\n *\n * Functions to build CairoCustomEnum for multiCall contracts\n * @param {Object} [staticEx] An optional object defining the \"Static\" value of the CairoCustomEnum.\n * @param {number[]} [ifEqual] An optional array defining the \"IfEqual\" value of the CairoCustomEnum.\n * @param {number[]} [ifNotEqual] An optional array defining the \"IfNotEqual\" value of the CairoCustomEnum.\n * @return {CairoCustomEnum} - The created CairoCustomEnum object.\n * @example\n * ```typescript\n * const result: CairoCustomEnum = starknetId.execution(undefined, [1, 2, 3], undefined);\n * // result = CairoCustomEnum {\n * //   variant: {\n * //     Static: undefined,\n * //     IfEqual: { '0': 1, '1': 2, '2': 3 },\n * //     IfNotEqual: undefined\n * //   }\n * // }\n * ```\n */\nexport function execution(\n  staticEx: {} | undefined,\n  ifEqual: number[] | undefined = undefined,\n  ifNotEqual: number[] | undefined = undefined\n): CairoCustomEnum {\n  return new CairoCustomEnum({\n    Static: staticEx,\n    IfEqual: ifEqual ? tuple(ifEqual[0], ifEqual[1], ifEqual[2]) : undefined,\n    IfNotEqual: ifNotEqual ? tuple(ifNotEqual[0], ifNotEqual[1], ifNotEqual[2]) : undefined,\n  });\n}\n\n/**\n * Creates a new instance of CairoCustomEnum.\n *\n * @param {BigNumberish} [hardcoded] The hardcoded value for the CairoCustomEnum.\n * @param {number[]} [reference] The reference array for the CairoCustomEnum.\n * @returns {CairoCustomEnum} The new instance of CairoCustomEnum.\n * @example\n * ```typescript\n * const result: CairoCustomEnum = starknetId.dynamicFelt(undefined, [1, 2]);\n * // result = CairoCustomEnum {\n * //  variant: { Hardcoded: undefined, Reference: { '0': 1, '1': 2 } }\n * // }\n * ```\n */\nexport function dynamicFelt(\n  hardcoded: BigNumberish | undefined,\n  reference: number[] | undefined = undefined\n): CairoCustomEnum {\n  return new CairoCustomEnum({\n    Hardcoded: hardcoded,\n    Reference: reference ? tuple(reference[0], reference[1]) : undefined,\n  });\n}\n\n/**\n * Creates a new instance of CairoCustomEnum with the given parameters.\n * @param {BigNumberish} [hardcoded] The hardcoded value.\n * @param {BigNumberish[]} [reference] The reference value (optional).\n * @param {BigNumberish[]} [arrayReference] The array reference value (optional).\n * @return {CairoCustomEnum} The new instance of CairoCustomEnum.\n * @example\n * ```typescript\n * const result: CairoCustomEnum = starknetId.dynamicCallData(undefined, [1, 2], undefined);\n * // result = CairoCustomEnum {\n * //   variant: {\n * //     Hardcoded: undefined,\n * //     Reference: { '0': 1, '1': 2 },\n * //     ArrayReference: undefined\n * //   }\n * // }\n * ```\n */\nexport function dynamicCallData(\n  hardcoded: BigNumberish | undefined,\n  reference: BigNumberish[] | undefined = undefined,\n  arrayReference: BigNumberish[] | undefined = undefined\n): CairoCustomEnum {\n  return new CairoCustomEnum({\n    Hardcoded: hardcoded,\n    Reference: reference ? tuple(reference[0], reference[1]) : undefined,\n    ArrayReference: arrayReference ? tuple(arrayReference[0], arrayReference[1]) : undefined,\n  });\n}\n\n/**\n * Check if a given string is a valid Starknet.id domain.\n *\n * @param {string} domain - The domain string to validate.\n * @returns {boolean} - True if the domain is a valid Starknet.id domain, false otherwise.\n * @example\n * ```typescript\n * const result = starknetId.isStarkDomain(\"example.stark\");\n * // result = true\n *\n * const result2 = starknetId.isStarkDomain(\"invalid-domain\");\n * // result2 = false\n * ```\n */\nexport function isStarkDomain(domain: string): boolean {\n  return /^(?:[a-z0-9-]{1,48}(?:[a-z0-9-]{1,48}[a-z0-9-])?\\.)*[a-z0-9-]{1,48}\\.stark$/.test(domain);\n}\n","import { BigNumberish, RawArgsArray, StarkProfile } from '../../types';\nimport { CallData } from '../../utils/calldata';\nimport { getSelectorFromName } from '../../utils/hash';\nimport { decodeShortString, encodeShortString } from '../../utils/shortString';\nimport {\n  dynamicCallData,\n  dynamicFelt,\n  execution,\n  getStarknetIdContract,\n  getStarknetIdIdentityContract,\n  getStarknetIdMulticallContract,\n  getStarknetIdPfpContract,\n  getStarknetIdPopContract,\n  getStarknetIdVerifierContract,\n  isStarkDomain,\n  useDecoded,\n  useEncoded,\n} from '../../utils/starknetId';\nimport type { ProviderInterface } from '..';\n\nexport class StarknetId {\n  async getStarkName(address: BigNumberish, StarknetIdContract?: string) {\n    return StarknetId.getStarkName(\n      // After Mixin, this is ProviderInterface\n      (<unknown>this) as ProviderInterface,\n      address,\n      StarknetIdContract\n    );\n  }\n\n  public async getAddressFromStarkName(name: string, StarknetIdContract?: string): Promise<string> {\n    return StarknetId.getAddressFromStarkName(\n      // After Mixin, this is ProviderInterface\n      (<unknown>this) as ProviderInterface,\n      name,\n      StarknetIdContract\n    );\n  }\n\n  async getStarkProfile(\n    address: BigNumberish,\n    StarknetIdContract?: string,\n    StarknetIdIdentityContract?: string,\n    StarknetIdVerifierContract?: string,\n    StarknetIdPfpContract?: string,\n    StarknetIdPopContract?: string,\n    StarknetIdMulticallContract?: string\n  ) {\n    return StarknetId.getStarkProfile(\n      // After Mixin, this is ProviderInterface\n      (<unknown>this) as ProviderInterface,\n      address,\n      StarknetIdContract,\n      StarknetIdIdentityContract,\n      StarknetIdVerifierContract,\n      StarknetIdPfpContract,\n      StarknetIdPopContract,\n      StarknetIdMulticallContract\n    );\n  }\n\n  static async getStarkName(\n    provider: ProviderInterface,\n    address: BigNumberish,\n    StarknetIdContract?: string\n  ): Promise<string> {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract ?? getStarknetIdContract(chainId);\n\n    try {\n      const hexDomain = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: 'address_to_domain',\n        calldata: CallData.compile({\n          address,\n          hint: [],\n        }),\n      });\n      const decimalDomain = hexDomain.map((element) => BigInt(element)).slice(1);\n\n      const stringDomain = useDecoded(decimalDomain);\n\n      if (!stringDomain) {\n        throw Error('Starkname not found');\n      }\n\n      return stringDomain;\n    } catch (e) {\n      if (e instanceof Error && e.message === 'Starkname not found') {\n        throw e;\n      }\n      throw Error('Could not get stark name');\n    }\n  }\n\n  static async getAddressFromStarkName(\n    provider: ProviderInterface,\n    name: string,\n    StarknetIdContract?: string\n  ): Promise<string> {\n    const starkName = name.endsWith('.stark') ? name : `${name}.stark`;\n\n    if (!isStarkDomain(starkName)) {\n      throw new Error('Invalid domain, must be a valid .stark domain');\n    }\n\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract ?? getStarknetIdContract(chainId);\n\n    try {\n      const encodedDomain = starkName\n        .replace('.stark', '')\n        .split('.')\n        .map((part) => useEncoded(part).toString(10));\n\n      const addressData = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: 'domain_to_address',\n        calldata: CallData.compile({ domain: encodedDomain, hint: [] }),\n      });\n\n      return addressData[0];\n    } catch {\n      throw Error('Could not get address from stark name');\n    }\n  }\n\n  static async getStarkProfile(\n    provider: ProviderInterface,\n    address: BigNumberish,\n    StarknetIdContract?: string,\n    StarknetIdIdentityContract?: string,\n    StarknetIdVerifierContract?: string,\n    StarknetIdPfpContract?: string,\n    StarknetIdPopContract?: string,\n    StarknetIdMulticallContract?: string\n  ): Promise<StarkProfile> {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract ?? getStarknetIdContract(chainId);\n    const identityContract = StarknetIdIdentityContract ?? getStarknetIdIdentityContract(chainId);\n    const verifierContract = StarknetIdVerifierContract ?? getStarknetIdVerifierContract(chainId);\n    const pfpContract = StarknetIdPfpContract ?? getStarknetIdPfpContract(chainId);\n    const popContract = StarknetIdPopContract ?? getStarknetIdPopContract(chainId);\n    const multicallAddress = StarknetIdMulticallContract ?? getStarknetIdMulticallContract(chainId);\n\n    try {\n      const calls: RawArgsArray = [\n        {\n          execution: execution({}),\n          to: dynamicCallData(contract),\n          selector: dynamicCallData(getSelectorFromName('address_to_domain')),\n          calldata: [dynamicCallData(address), dynamicCallData('0')],\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(contract),\n          selector: dynamicFelt(getSelectorFromName('domain_to_id')),\n          calldata: [dynamicCallData(undefined, undefined, [0, 0])],\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n          calldata: [\n            dynamicCallData(undefined, [1, 0]),\n            dynamicCallData(encodeShortString('twitter')),\n            dynamicCallData(verifierContract),\n            dynamicCallData('0'),\n          ],\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n          calldata: [\n            dynamicCallData(undefined, [1, 0]),\n            dynamicCallData(encodeShortString('github')),\n            dynamicCallData(verifierContract),\n            dynamicCallData('0'),\n          ],\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n          calldata: [\n            dynamicCallData(undefined, [1, 0]),\n            dynamicCallData(encodeShortString('discord')),\n            dynamicCallData(verifierContract),\n            dynamicCallData('0'),\n          ],\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n          calldata: [\n            dynamicCallData(undefined, [1, 0]),\n            dynamicCallData(encodeShortString('proof_of_personhood')),\n            dynamicCallData(popContract),\n            dynamicCallData('0'),\n          ],\n        },\n        // PFP\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n          calldata: [\n            dynamicCallData(undefined, [1, 0]),\n            dynamicCallData(encodeShortString('nft_pp_contract')),\n            dynamicCallData(pfpContract),\n            dynamicCallData('0'),\n          ],\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName('get_extended_verifier_data')),\n          calldata: [\n            dynamicCallData(undefined, [1, 0]),\n            dynamicCallData(encodeShortString('nft_pp_id')),\n            dynamicCallData('2'),\n            dynamicCallData(pfpContract),\n            dynamicCallData('0'),\n          ],\n        },\n        {\n          execution: execution(undefined, undefined, [6, 0, 0]),\n          to: dynamicFelt(undefined, [6, 0]),\n          selector: dynamicFelt(getSelectorFromName('tokenURI')),\n          calldata: [dynamicCallData(undefined, [7, 1]), dynamicCallData(undefined, [7, 2])],\n        },\n      ];\n\n      const data = await provider.callContract({\n        contractAddress: multicallAddress,\n        entrypoint: 'aggregate',\n        calldata: CallData.compile({\n          calls,\n        }),\n      });\n\n      if (Array.isArray(data)) {\n        // Format data\n        const size = parseInt(data[0], 16);\n        const finalArray: string[][] = [];\n        let index = 1;\n        for (let i = 0; i < size; i += 1) {\n          if (index < data.length) {\n            const subArraySize = parseInt(data[index], 16);\n            index += 1;\n\n            const subArray = data.slice(index, index + subArraySize);\n            finalArray.push(subArray);\n\n            index += subArraySize;\n          } else {\n            break;\n          }\n        }\n\n        const name = useDecoded(finalArray[0].slice(1).map((hexString) => BigInt(hexString)));\n\n        const twitter =\n          finalArray[2][0] !== '0x0' ? BigInt(finalArray[2][0]).toString() : undefined;\n        const github = finalArray[3][0] !== '0x0' ? BigInt(finalArray[3][0]).toString() : undefined;\n        const discord =\n          finalArray[4][0] !== '0x0' ? BigInt(finalArray[4][0]).toString() : undefined;\n        const proofOfPersonhood = finalArray[5][0] === '0x1'; // 10\n\n        const profilePictureMetadata =\n          data[0] === '0x9'\n            ? finalArray[8]\n                .slice(1)\n                .map((val: string) => decodeShortString(val))\n                .join('')\n            : undefined;\n\n        const profilePicture =\n          profilePictureMetadata ||\n          `https://starknet.id/api/identicons/${BigInt(finalArray[1][0]).toString()}`;\n\n        return {\n          name,\n          twitter,\n          github,\n          discord,\n          proofOfPersonhood,\n          profilePicture,\n        };\n      }\n      throw Error('Error while calling aggregate function');\n    } catch (e) {\n      if (e instanceof Error) {\n        throw e;\n      }\n      throw Error('Could not get user stark profile data from address');\n    }\n  }\n}\n","import { RPC06, RPC07 } from '../channel';\nimport { StarknetChainId } from '../global/constants';\nimport type {\n  AccountInvocations,\n  BigNumberish,\n  Block,\n  BlockIdentifier,\n  Call,\n  CallContractResponse,\n  ContractClassResponse,\n  ContractVersion,\n  DeclareContractResponse,\n  DeclareContractTransaction,\n  DeployAccountContractPayload,\n  DeployAccountContractTransaction,\n  DeployContractResponse,\n  EstimateFeeResponse,\n  EstimateFeeResponseBulk,\n  GetBlockResponse,\n  GetTransactionResponse,\n  Invocation,\n  InvocationsDetailsWithNonce,\n  InvokeFunctionResponse,\n  Nonce,\n  PendingBlock,\n  SimulateTransactionResponse,\n  StateUpdateResponse,\n  Storage,\n  getContractVersionOptions,\n  getEstimateFeeBulkOptions,\n  getSimulateTransactionOptions,\n  waitForTransactionOptions,\n} from '../types';\nimport type { GetTransactionReceiptResponse } from '../utils/transactionReceipt';\n\nexport abstract class ProviderInterface {\n  public abstract channel: RPC07.RpcChannel | RPC06.RpcChannel;\n\n  /**\n   * Gets the Starknet chain Id\n   *\n   * @returns the chain Id\n   */\n  public abstract getChainId(): Promise<StarknetChainId>;\n\n  /**\n   * Calls a function on the Starknet contract.\n   *\n   * @param call transaction to be called\n   * @param blockIdentifier block identifier\n   * @returns the result of the function on the smart contract.\n   */\n  public abstract callContract(\n    call: Call,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<CallContractResponse>;\n\n  /**\n   * Gets the block information\n   *\n   * @param blockIdentifier block identifier\n   * @returns the block object\n   */\n  public abstract getBlock(blockIdentifier?: 'pending'): Promise<PendingBlock>;\n  public abstract getBlock(blockIdentifier: 'latest'): Promise<Block>;\n  public abstract getBlock(blockIdentifier: BlockIdentifier): Promise<GetBlockResponse>;\n\n  /**\n   * Gets the contract class of the deployed contract.\n   *\n   * @param contractAddress - contract address\n   * @param blockIdentifier - block identifier\n   * @returns Contract class of compiled contract\n   */\n  public abstract getClassAt(\n    contractAddress: string,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<ContractClassResponse>;\n\n  /**\n   * Gets the price of l1 gas in the block\n   *\n   * @param blockIdentifier block identifier\n   * @returns gas price of the block\n   */\n  public abstract getL1GasPrice(blockIdentifier: BlockIdentifier): Promise<string>;\n\n  /**\n   * Get L1 message hash from L2 transaction hash\n   * @param {BigNumberish} l2TxHash L2 transaction hash\n   * @returns {string} Hex string of L1 message hash\n   * @example\n   * In Sepolia Testnet :\n   * ```typescript\n   * const result = provider.getL1MessageHash('0x28dfc05eb4f261b37ddad451ff22f1d08d4e3c24dc646af0ec69fa20e096819');\n   * // result = '0x55b3f8b6e607fffd9b4d843dfe8f9b5c05822cd94fcad8797deb01d77805532a'\n   * ```\n   */\n  public abstract getL1MessageHash(l2TxHash: BigNumberish): Promise<string>;\n\n  /**\n   * Returns the contract class hash in the given block for the contract deployed at the given address\n   *\n   * @param contractAddress - contract address\n   * @param blockIdentifier - block identifier\n   * @returns Class hash\n   */\n  public abstract getClassHashAt(\n    contractAddress: string,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<string>;\n\n  /**\n   * Returns the contract class deployed under the given class hash.\n   *\n   * @param classHash - class hash\n   * @returns Contract class of compiled contract\n   */\n  public abstract getClassByHash(classHash: string): Promise<ContractClassResponse>;\n\n  /**\n   * Returns the nonce associated with the given address in the given block\n   *\n   * @param contractAddress - contract address\n   * @returns the hex nonce\n   */\n  public abstract getNonceForAddress(\n    contractAddress: string,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<Nonce>;\n\n  /**\n   * Get the value of the storage (contract's variable) at the given address and key\n   *\n   * @param contractAddress\n   * @param key - from getStorageVarAddress('<STORAGE_VARIABLE_NAME>') (WIP)\n   * @param blockIdentifier - block identifier\n   * @returns the value of the storage variable\n   */\n  public abstract getStorageAt(\n    contractAddress: string,\n    key: BigNumberish,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<Storage>;\n\n  /**\n   * Gets the transaction information from a tx id.\n   *\n   * @param transactionHash\n   * @returns the transaction object \\{ transaction_id, status, transaction, block_number?, block_number?, transaction_index?, transaction_failure_reason? \\}\n   */\n  public abstract getTransaction(transactionHash: BigNumberish): Promise<GetTransactionResponse>;\n\n  /**\n   * Gets the transaction receipt from a tx hash.\n   *\n   * @param transactionHash\n   * @returns the transaction receipt object\n   */\n  public abstract getTransactionReceipt(\n    transactionHash: BigNumberish\n  ): Promise<GetTransactionReceiptResponse>;\n\n  /**\n   * Deploys a given compiled Account contract (json) to starknet\n   *\n   * @param payload payload to be deployed containing:\n   * - compiled contract code\n   * - constructor calldata\n   * - address salt\n   * @returns a confirmation of sending a transaction on the starknet contract\n   */\n  public abstract deployAccountContract(\n    payload: DeployAccountContractPayload,\n    details: InvocationsDetailsWithNonce\n  ): Promise<DeployContractResponse>;\n\n  /**\n   * Invokes a function on starknet\n   * @deprecated This method won't be supported as soon as fees are mandatory. Should not be used outside of Account class\n   *\n   * @param invocation the invocation object containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata - (defaults to []) the calldata\n   * - signature - (defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce - optional nonce\n   * - version - optional version\n   * - maxFee - optional maxFee\n   * @returns response from addTransaction\n   */\n  public abstract invokeFunction(\n    invocation: Invocation,\n    details: InvocationsDetailsWithNonce\n  ): Promise<InvokeFunctionResponse>;\n\n  /**\n   * Declares a given compiled contract (json) to starknet\n   * @param transaction transaction payload to be deployed containing:\n   * - compiled contract code\n   * - sender address\n   * - signature\n   * @param details Invocation Details containing:\n   * - nonce\n   * - optional version\n   * - optional maxFee\n   * @returns a confirmation of sending a transaction on the starknet contract\n   */\n  public abstract declareContract(\n    transaction: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ): Promise<DeclareContractResponse>;\n\n  /**\n   * Estimates the fee for a given INVOKE transaction\n   * @deprecated Please use getInvokeEstimateFee or getDeclareEstimateFee instead. Should not be used outside of Account class\n   *\n   * @param invocation the invocation object containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata - (defaults to []) the calldata\n   * - signature - (defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce - optional nonce\n   * - version - optional version\n   * @param blockIdentifier - (optional) block identifier\n   * @param skipValidate - (optional) skip cairo __validate__ method\n   * @returns the estimated fee\n   */\n  public abstract getEstimateFee(\n    invocation: Invocation,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimates the fee for a given INVOKE transaction\n   *\n   * @param invocation the invocation object containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata - (defaults to []) the calldata\n   * - signature - (defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce - optional nonce\n   * - version - optional version\n   * @param blockIdentifier - (optional) block identifier\n   * @param skipValidate - (optional) skip cairo __validate__ method\n   * @returns the estimated fee\n   */\n  public abstract getInvokeEstimateFee(\n    invocation: Invocation,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimates the fee for a given DECLARE transaction\n   *\n   * @param transaction transaction payload to be declared containing:\n   * - compiled contract code\n   * - sender address\n   * - signature - (defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce\n   * - version - optional version\n   * - optional maxFee\n   * @param blockIdentifier - (optional) block identifier\n   * @param skipValidate - (optional) skip cairo __validate__ method\n   * @returns the estimated fee\n   */\n  public abstract getDeclareEstimateFee(\n    transaction: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimates the fee for a given DEPLOY_ACCOUNT transaction\n   *\n   * @param transaction transaction payload to be deployed containing:\n   * - classHash\n   * - constructorCalldata\n   * - addressSalt\n   * - signature - (defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce\n   * - version - optional version\n   * - optional maxFee\n   * @param blockIdentifier - (optional) block identifier\n   * @param skipValidate - (optional) skip cairo __validate__ method\n   * @returns the estimated fee\n   */\n  public abstract getDeployAccountEstimateFee(\n    transaction: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimates the fee for a list of INVOKE transaction\n   *\n   * @param invocations AccountInvocations - Complete invocations array with account details\n   * @param options getEstimateFeeBulkOptions\n   * - (optional) blockIdentifier - BlockIdentifier\n   * @returns the estimated fee\n   */\n  public abstract getEstimateFeeBulk(\n    invocations: AccountInvocations,\n    options?: getEstimateFeeBulkOptions\n  ): Promise<EstimateFeeResponseBulk>;\n\n  /**\n   * Wait for the transaction to be accepted\n   * @param txHash - transaction hash\n   * @param options waitForTransactionOptions\n   * - (optional) retryInterval: number | undefined;\n   * - (optional) successStates: TransactionStatus[] | undefined;\n   * @return GetTransactionReceiptResponse\n   */\n  public abstract waitForTransaction(\n    txHash: BigNumberish,\n    options?: waitForTransactionOptions\n  ): Promise<GetTransactionReceiptResponse>;\n\n  /**\n   * Simulates the transaction and returns the transaction trace and estimated fee.\n   *\n   * @param invocations AccountInvocations - Complete invocations array with account details\n   * @param options - getSimulateTransactionOptions\n   *  - (optional) blockIdentifier - block identifier\n   *  - (optional) skipValidate - skip cairo __validate__ method\n   *  - (optional) skipExecute - skip cairo __execute__ method\n   * @returns an array of transaction trace and estimated fee\n   */\n  public abstract getSimulateTransaction(\n    invocations: AccountInvocations,\n    options?: getSimulateTransactionOptions\n  ): Promise<SimulateTransactionResponse>;\n\n  /**\n   * Gets the state changes in a specific block (result of executing the requested block)\n   *\n   * @param blockIdentifier - block identifier\n   * @returns StateUpdateResponse\n   */\n  public abstract getStateUpdate(blockIdentifier?: BlockIdentifier): Promise<StateUpdateResponse>;\n\n  /**\n   * Gets the contract version from the provided address\n   * @param contractAddress string\n   * @param classHash undefined\n   * @param options - getContractVersionOptions\n   *   - (optional) compiler - (default true) extract compiler version using type tactic from abi\n   *   - (optional) blockIdentifier - block identifier\n   */\n  public abstract getContractVersion(\n    contractAddress: string,\n    classHash?: undefined,\n    options?: getContractVersionOptions\n  ): Promise<ContractVersion>;\n\n  /**\n   * Gets the contract version from the provided address\n   * @param contractAddress undefined\n   * @param classHash\n   * @param options - getContractVersionOptions\n   *   - (optional) compiler - (default true) extract compiler version using type tactic from abi\n   *   - (optional) blockIdentifier - block identifier\n   */\n  public abstract getContractVersion(\n    contractAddress: undefined,\n    classHash: string,\n    options?: getContractVersionOptions\n  ): Promise<ContractVersion>;\n}\n","import { RpcProvider } from './rpc';\n\nexport { RpcProvider as Provider } from './extensions/default'; // backward-compatibility\nexport * from '../utils/errors';\nexport * from './interface';\nexport * from './extensions/default';\n\nexport const defaultProvider = new RpcProvider({ default: true });\n","import {\n  Call,\n  DeclareSignerDetails,\n  DeployAccountSignerDetails,\n  InvocationsSignerDetails,\n  Signature,\n  TypedData,\n} from '../types';\n\nexport abstract class SignerInterface {\n  /**\n   * Method to get the public key of the signer\n   *\n   * @returns {string} hex-string\n   * @example\n   * ```typescript\n   * const mySigner = new Signer(\"0x123\");\n   * const result = await mySigner.getPubKey();\n   * // result = \"0x566d69d8c99f62bc71118399bab25c1f03719463eab8d6a444cd11ece131616\"\n   * ```\n   */\n  public abstract getPubKey(): Promise<string>;\n\n  /**\n   * Signs a JSON object for off-chain usage with the private key and returns the signature.\n   * This adds a message prefix so it can't be interchanged with transactions\n   *\n   * @param {TypedData} typedData JSON object to be signed\n   * @param {string} accountAddress Hex string of the account's address\n   * @returns {Promise<Signature>} the signature of the message\n   * @example\n   * ```typescript\n   * const mySigner = new Signer(\"0x123\");\n   *     const myTypedData: TypedData = {\n   *         domain: {name: \"Example DApp\",\n   *           chainId: constants.StarknetChainId.SN_SEPOLIA,\n   *           version: \"0.0.3\"},\n   *         types: {StarkNetDomain: [\n   *             { name: \"name\", type: \"string\" },\n   *             { name: \"chainId\", type: \"felt\" },\n   *             { name: \"version\", type: \"string\" }],\n   *           Message: [{ name: \"message\", type: \"felt\" }]},\n   *         primaryType: \"Message\", message: {message: \"1234\"}};\n   *     const result = await mySigner.signMessage(myTypedData,\"0x5d08a4e9188429da4e993c9bf25aafe5cd491ee2b501505d4d059f0c938f82d\");\n   * // result = Signature {r: 684915484701699003335398790608214855489903651271362390249153620883122231253n,\n   * // s: 1399150959912500412309102776989465580949387575375484933432871778355496929189n, recovery: 1}\n   * ```\n\n   */\n  public abstract signMessage(typedData: TypedData, accountAddress: string): Promise<Signature>;\n\n  /**\n   * Signs transactions with the private key and returns the signature\n   *\n   * @param {Call[]} transactions array of Call objects\n   * @param {InvocationsSignerDetails} transactionsDetail InvocationsSignerDetails object\n   * @returns {Promise<Signature>} the signature of the transaction\n   * @example\n   * ```typescript\n   * const mySigner = new Signer(\"0x123\");\n   * const calls: Call[] = [{\n   *     contractAddress: \"0x1234567890123456789012345678901234567890\",\n   *     entrypoint: \"functionName\",\n   *     calldata: [1, 2, 3]\n   * }];\n   * const transactionsDetail: InvocationsSignerDetails = {\n   *     walletAddress: '0x742d35Cc6634C0532925a3b844Bc454e4438f44e',\n   *     chainId: constants.StarknetChainId.SN_MAIN,\n   *     cairoVersion: \"1\",\n   *     maxFee: '0x1234567890abcdef',\n   *     version: \"0x0\", nonce: 1};\n   * const result = await mySigner.signTransaction(calls, transactionsDetail);\n   * // result = Signature {r: 304910226421970384958146916800275294114105560641204815169249090836676768876n,\n   * //   s: 1072798866000813654190523783606274062837012608648308896325315895472901074693n, recovery: 0}\n   * ```\n   */\n  public abstract signTransaction(\n    transactions: Call[],\n    transactionsDetail: InvocationsSignerDetails\n  ): Promise<Signature>;\n\n  /**\n   * Signs a DEPLOY_ACCOUNT transaction with the private key and returns the signature\n   *\n   * @param {DeployAccountSignerDetails} transaction to deploy an account contract\n   * @returns {Promise<Signature>} the signature of the transaction to deploy an account\n   * @example\n   * ```typescript\n   * const mySigner = new Signer(\"0x123\");\n   * const myDeployAcc: DeployAccountSignerDetails = {\n   *   contractAddress: \"0x65a822fbee1ae79e898688b5a4282dc79e0042cbed12f6169937fddb4c26641\",\n   *   version: \"0x2\", chainId: constants.StarknetChainId.SN_SEPOLIA,\n   *   classHash: \"0x5f3614e8671257aff9ac38e929c74d65b02d460ae966cd826c9f04a7fa8e0d4\",\n   *   constructorCalldata: [1, 2],addressSalt: 1234,\n   *   nonce: 45, maxFee: 10 ** 15, tip: 0, paymasterData: [],accountDeploymentData: [],\n   *   nonceDataAvailabilityMode: RPC.EDataAvailabilityMode.L1,\n   *   feeDataAvailabilityMode: RPC.EDataAvailabilityMode.L1,\n   *   resourceBounds: stark.estimateFeeToBounds(constants.ZERO),\n   * }\n   * const result = await mySigner.signDeployAccountTransaction(myDeployAcc);\n   * // result = Signature {r: 2871311234341436528393212130310036951068553852419934781736214693308640202748n,\n   * //  s: 1746271646048888422437132495446973163454853863041370993384284773665861377605n, recovery: 1}\n   * ```\n   */\n  public abstract signDeployAccountTransaction(\n    transaction: DeployAccountSignerDetails\n  ): Promise<Signature>;\n\n  /**\n   * Signs a DECLARE transaction with the private key and returns the signature\n   *\n   * @param {DeclareSignerDetails} transaction to declare a class\n   * @returns {Promise<Signature>} the signature of the transaction to declare a class\n   * @example\n   * ```typescript\n   * const mySigner = new Signer(\"0x123\");\n   * const myDeclare: DeclareSignerDetails = {\n   *   version: \"0x2\", chainId: constants.StarknetChainId.SN_SEPOLIA,\n   *   senderAddress: \"0x65a822fbee1ae79e898688b5a4282dc79e0042cbed12f6169937fddb4c26641\",\n   *   classHash: \"0x5f3614e8671257aff9ac38e929c74d65b02d460ae966cd826c9f04a7fa8e0d4\",\n   *   nonce: 45, maxFee: 10 ** 15, tip: 0, paymasterData: [], accountDeploymentData: [],\n   *   nonceDataAvailabilityMode: RPC.EDataAvailabilityMode.L1,\n   *   feeDataAvailabilityMode: RPC.EDataAvailabilityMode.L1,\n   *   resourceBounds: stark.estimateFeeToBounds(constants.ZERO),\n}\n   * const result = await mySigner.signDeclareTransaction(myDeclare);\n   * // result = Signature {r: 2432056944313955951711774394836075930010416436707488863728289188289211995670n,\n   * //  s: 3407649393310177489888603098175002856596469926897298636282244411990343146307n, recovery: 1}\n   * ```\n   */\n  public abstract signDeclareTransaction(transaction: DeclareSignerDetails): Promise<Signature>;\n}\n","import {\n  Call,\n  DeclareSignerDetails,\n  DeployAccountSignerDetails,\n  InvocationsSignerDetails,\n  Signature,\n  TypedData,\n  V2DeclareSignerDetails,\n  V2DeployAccountSignerDetails,\n  V2InvocationsSignerDetails,\n  V3DeclareSignerDetails,\n  V3DeployAccountSignerDetails,\n  V3InvocationsSignerDetails,\n} from '../types';\nimport { ETransactionVersion2, ETransactionVersion3 } from '../types/api';\nimport { CallData } from '../utils/calldata';\nimport { starkCurve } from '../utils/ec';\nimport { buf2hex } from '../utils/encode';\nimport {\n  calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash,\n  calculateInvokeTransactionHash,\n} from '../utils/hash';\nimport { toHex } from '../utils/num';\nimport { intDAM } from '../utils/stark';\nimport { getExecuteCalldata } from '../utils/transaction';\nimport { getMessageHash } from '../utils/typedData';\nimport { SignerInterface } from './interface';\n\nexport class Signer implements SignerInterface {\n  protected pk: Uint8Array | string;\n\n  constructor(pk: Uint8Array | string = starkCurve.utils.randomPrivateKey()) {\n    this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex(pk);\n  }\n\n  public async getPubKey(): Promise<string> {\n    return starkCurve.getStarkKey(this.pk);\n  }\n\n  public async signMessage(typedData: TypedData, accountAddress: string): Promise<Signature> {\n    const msgHash = getMessageHash(typedData, accountAddress);\n    return this.signRaw(msgHash);\n  }\n\n  public async signTransaction(\n    transactions: Call[],\n    details: InvocationsSignerDetails\n  ): Promise<Signature> {\n    const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n    let msgHash;\n\n    // TODO: How to do generic union discriminator for all like this\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2InvocationsSignerDetails;\n      msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3InvocationsSignerDetails;\n      msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signTransaction version');\n    }\n\n    return this.signRaw(msgHash as string);\n  }\n\n  public async signDeployAccountTransaction(\n    details: DeployAccountSignerDetails\n  ): Promise<Signature> {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    /*     const version = BigInt(details.version).toString(); */\n    let msgHash;\n\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeployAccountTransaction version');\n    }\n\n    return this.signRaw(msgHash as string);\n  }\n\n  public async signDeclareTransaction(\n    // contractClass: ContractClass,  // Should be used once class hash is present in ContractClass\n    details: DeclareSignerDetails\n  ): Promise<Signature> {\n    let msgHash;\n\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2DeclareSignerDetails;\n      msgHash = calculateDeclareTransactionHash({\n        ...det,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeclareSignerDetails;\n      msgHash = calculateDeclareTransactionHash({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeclareTransaction version');\n    }\n\n    return this.signRaw(msgHash as string);\n  }\n\n  protected async signRaw(msgHash: string): Promise<Signature> {\n    return starkCurve.sign(msgHash, this.pk);\n  }\n}\n","import type { RecoveredSignatureType } from '@noble/curves/abstract/weierstrass';\nimport { secp256k1 } from '@noble/curves/secp256k1';\n\nimport {\n  ArraySignatureType,\n  Call,\n  DeclareSignerDetails,\n  DeployAccountSignerDetails,\n  InvocationsSignerDetails,\n  Signature,\n  TypedData,\n  Uint256,\n  V2DeclareSignerDetails,\n  V2DeployAccountSignerDetails,\n  V2InvocationsSignerDetails,\n  V3DeclareSignerDetails,\n  V3DeployAccountSignerDetails,\n  V3InvocationsSignerDetails,\n} from '../types';\nimport { ETransactionVersion2, ETransactionVersion3 } from '../types/api';\nimport { CallData } from '../utils/calldata';\nimport { addHexPrefix, buf2hex, removeHexPrefix, sanitizeHex } from '../utils/encode';\nimport { ethRandomPrivateKey } from '../utils/eth';\nimport {\n  calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash,\n  calculateInvokeTransactionHash,\n} from '../utils/hash';\nimport { toHex } from '../utils/num';\nimport { intDAM } from '../utils/stark';\nimport { getExecuteCalldata } from '../utils/transaction';\nimport { getMessageHash } from '../utils/typedData';\nimport { bnToUint256 } from '../utils/uint256';\nimport { SignerInterface } from './interface';\n\n/**\n * Signer for accounts using Ethereum signature\n */\nexport class EthSigner implements SignerInterface {\n  protected pk: string; // hex string without 0x and with an odd number of characters\n\n  constructor(pk: Uint8Array | string = ethRandomPrivateKey()) {\n    this.pk =\n      pk instanceof Uint8Array\n        ? buf2hex(pk).padStart(64, '0')\n        : removeHexPrefix(toHex(pk)).padStart(64, '0');\n  }\n\n  /**\n   * provides the Ethereum full public key (without parity prefix)\n   * @returns an hex string : 64 first characters are Point X coordinate. 64 last characters are Point Y coordinate.\n   */\n  public async getPubKey(): Promise<string> {\n    return addHexPrefix(\n      buf2hex(secp256k1.getPublicKey(this.pk, false)).padStart(130, '0').slice(2)\n    );\n  }\n\n  public async signMessage(typedData: TypedData, accountAddress: string): Promise<Signature> {\n    const msgHash = getMessageHash(typedData, accountAddress);\n    const signature: RecoveredSignatureType = secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n\n  public async signTransaction(\n    transactions: Call[],\n    details: InvocationsSignerDetails\n  ): Promise<Signature> {\n    const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n    let msgHash;\n\n    // TODO: How to do generic union discriminator for all like this\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2InvocationsSignerDetails;\n      msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3InvocationsSignerDetails;\n      msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signTransaction version');\n    }\n    const signature: RecoveredSignatureType = secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n\n  public async signDeployAccountTransaction(\n    details: DeployAccountSignerDetails\n  ): Promise<Signature> {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    /*     const version = BigInt(details.version).toString(); */\n    let msgHash;\n\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeployAccountTransaction version');\n    }\n    const signature: RecoveredSignatureType = secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n\n  public async signDeclareTransaction(\n    // contractClass: ContractClass,  // Should be used once class hash is present in ContractClass\n    details: DeclareSignerDetails\n  ): Promise<Signature> {\n    let msgHash;\n\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2DeclareSignerDetails;\n      msgHash = calculateDeclareTransactionHash({\n        ...det,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeclareSignerDetails;\n      msgHash = calculateDeclareTransactionHash({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeclareTransaction version');\n    }\n\n    const signature: RecoveredSignatureType = secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n\n  /**\n   * Serialize the signature in conformity with starknet::eth_signature::Signature\n   * @param ethSignature secp256k1 signature from Noble curves library\n   * @return an array of felts, representing a Cairo Eth Signature.\n   */\n  protected formatEthSignature(ethSignature: RecoveredSignatureType): ArraySignatureType {\n    const r: Uint256 = bnToUint256(ethSignature.r);\n    const s: Uint256 = bnToUint256(ethSignature.s);\n    return [\n      toHex(r.low),\n      toHex(r.high),\n      toHex(s.low),\n      toHex(s.high),\n      toHex(ethSignature.recovery),\n    ] as ArraySignatureType;\n  }\n}\n","/* eslint-disable no-bitwise */\nimport { BigNumberish, Uint256 } from '../types';\nimport { CairoUint256, UINT_128_MAX, UINT_256_MAX } from './cairoDataTypes/uint256';\n\n/**\n * @deprecated Legacy support Export\n */\nexport { UINT_128_MAX, UINT_256_MAX };\n\n/**\n * Convert Uint256 to bigint\n * Legacy support Export\n * @param {Uint256} uint256 Uint256 value to convert to bigint\n * @returns {bigint} BigInt representation of the input Uint256\n * @example\n * ```typescript\n * const uint256Value: Uint256 = {low: 1234567890, high: 1};\n * const result = uint256.uint256ToBN(uint256Value);\n * // result = 340282366920938463463374607433002779346n\n * ```\n */\nexport function uint256ToBN(uint256: Uint256): bigint {\n  return new CairoUint256(uint256).toBigInt();\n}\n\n/**\n * Test BigNumberish is in the range[0, 2**256-1]\n * Legacy support Export\n * @param {BigNumberish} bn value to test\n * @returns {boolean} True if the input value is in the range[0, 2**256-1], false otherwise\n * @example\n * ```typescript\n * const result = uint256.isUint256(12345n);\n * // result = true\n * const result1 = uint256.isUint256(-1);\n * // result1 = false\n * ```\n */\nexport function isUint256(bn: BigNumberish): boolean {\n  return CairoUint256.is(bn);\n}\n\n/**\n * Convert BigNumberish (string | number | bigint) to Uint256\n * Legacy support Export\n * @param {BigNumberish} bn value to convert to Uint256\n * @returns {Uint256} Uint256 object representing the BigNumberish value\n * @example\n * ```typescript\n * const result = uint256.bnToUint256(1000000000n);\n * // result = {\"low\": \"0x3b9aca00\", \"high\": \"0x0\"}\n * ```\n */\nexport function bnToUint256(bn: BigNumberish): Uint256 {\n  return new CairoUint256(bn).toUint256HexString();\n}\n","/* eslint no-underscore-dangle: [\"error\", { \"allowAfterThis\": true }] */\nimport type {\n  InvocationsSignerDetails,\n  V2InvocationsSignerDetails,\n  V3InvocationsSignerDetails,\n  DeployAccountSignerDetails,\n  V2DeployAccountSignerDetails,\n  V3DeployAccountSignerDetails,\n  DeclareSignerDetails,\n  V2DeclareSignerDetails,\n  V3DeclareSignerDetails,\n  TypedData,\n  Call,\n  Signature,\n  LedgerPathCalculation,\n} from '../types';\nimport assert from '../utils/assert';\nimport { CallData } from '../utils/calldata';\nimport type { SignerInterface } from './interface';\nimport { MASK_31 } from '../global/constants';\nimport { ETransactionVersion2 } from '../types/api/rpcspec_0_6';\nimport { getMessageHash } from '../utils/typedData';\nimport { getExecuteCalldata } from '../utils/transaction';\nimport {\n  calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash,\n  calculateInvokeTransactionHash,\n} from '../utils/hash';\nimport { intDAM } from '../utils/stark';\nimport { addHexPrefix, buf2hex, concatenateArrayBuffer, removeHexPrefix } from '../utils/encode';\nimport { hexToBytes, stringToSha256ToArrayBuff4, toHex } from '../utils/num';\nimport { starkCurve } from '../utils/ec';\nimport { ETransactionVersion3 } from '../types/api';\n\n// import type _Transport from '@ledgerhq/hw-transport';\n// NOTE: the preceding line was substituted because of the '@ledgerhq/hw-transport' module bug listed in\n// the following issue https://github.com/LedgerHQ/ledger-live/issues/7448\n// if required for development, the line can be uncommented and '@ledgerhq/hw-transport' temporarily added as a dev dependency\ntype _Transport = any;\n\n/**\n * Signer for accounts using a Ledger Nano S+/X signature (Starknet Ledger APP version 1.1.1)\n *\n * The Ledger has to be connected, unlocked and the Starknet APP has to be selected prior of use of this class.\n */\nexport class LedgerSigner111<Transport extends Record<any, any> = any> implements SignerInterface {\n  readonly transporter: Transport;\n\n  // this is a hack to allow the '@ledgerhq/hw-transport' type to be used as a dev dependency but not exposed in the production build\n  protected _transporter: _Transport;\n\n  readonly accountID: number;\n\n  readonly eip2645applicationName: string;\n\n  readonly pathBuffer: Uint8Array;\n\n  protected appVersion: string;\n\n  protected pubKey: string;\n\n  protected fullPubKey: string;\n\n  /**\n   * constructor of the LedgerSigner class.\n   * @param {Transport} transport 5 transports are available to handle USB, bluetooth, Node, Web, Mobile.\n   * See Guides for more details.\n   * @param {number} accountID ID of Ledger Nano (can handle 2**31 accounts).\n   * @param {string} [eip2645application='LedgerW'] A wallet is defined by an ERC2645 derivation path (6 items),\n   * and one item is the `application` and can be customized.\n   * Default value is `LedgerW`.\n   * @param {LedgerPathCalculation} [pathFunction=getLedgerPathBuffer111]\n   * defines the function that will calculate the path. By default `getLedgerPathBuffer111` is selected.\n   * @example\n   * ```typescript\n   * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid\";\n   * const myNodeTransport = await TransportNodeHid.create();\n   * const myLedgerSigner = new LedgerSigner111(myNodeTransport, 0);\n   * ```\n   */\n  constructor(\n    transport: Transport,\n    accountID: number,\n    eip2645application: string = 'LedgerW',\n    pathFunction: LedgerPathCalculation = getLedgerPathBuffer111\n  ) {\n    assert(accountID >= 0, 'Ledger account ID shall not be a negative number.');\n    assert(accountID <= MASK_31, 'Ledger account ID shall be < 2**31.');\n    assert(!!eip2645application, 'Ledger application name shall not be empty.');\n    this.transporter = transport;\n    this._transporter = this.transporter as any;\n    this.accountID = accountID;\n    this.pubKey = '';\n    this.fullPubKey = '';\n    this.eip2645applicationName = eip2645application;\n    this.appVersion = '';\n    this.pathBuffer = pathFunction(this.accountID, this.eip2645applicationName);\n  }\n\n  /**\n   * provides the Starknet public key\n   * @returns an hex string : 64 characters are Point X coordinate.\n   * @example\n   * ```typescript\n   * const result = await myLedgerSigner.getPubKey();\n   * // result= \"0x03681417ba3e1f050dd3ccdceb8d22b5e44fa70ee7844d472c6a768bded5174e\"\n   * ```\n   */\n  public async getPubKey(): Promise<string> {\n    if (!this.pubKey) await this.getPublicKeys();\n    return this.pubKey;\n  }\n\n  /**\n   * provides the full public key (with parity prefix)\n   * @returns an hex string : 2 first characters are the parity, the 64 following characters are Point X coordinate. 64 last characters are Point Y coordinate.\n   * @example\n   * ```typescript\n   * const result = await myLedgerSigner.getFullPubKey();\n   * // result= \"0x0403681417ba3e1f050dd3ccdceb8d22b5e44fa70ee7844d472c6a768bded5174e03cbc86f805dcfcb0c1922dd4daf181afa289d86223a18bc856276615bcc7787\"\n   * ```\n   */\n  public async getFullPubKey(): Promise<string> {\n    if (!this.fullPubKey) await this.getPublicKeys();\n    return this.fullPubKey;\n  }\n\n  /**\n   * Returns the version of the Starknet APP implemented in the Ledger.\n   * @returns {string} version.\n   * @example\n   * ```typescript\n   * const result = await myLedgerSigner.getAppVersion();\n   * // result= \"1.1.1\"\n   * ```\n   */\n  public async getAppVersion(): Promise<string> {\n    if (!this.appVersion) {\n      const resp = await this._transporter.send(Number('0x5a'), 0, 0, 0);\n      this.appVersion = `${resp[0]}.${resp[1]}.${resp[2]}`;\n    }\n    return this.appVersion;\n  }\n\n  /**\n   * Sign a TypedData message (SNIP-12) in a Ledger.\n   * @param {typedDataToHash} typedDataToHash A TypedData message compatible with SNIP-12.\n   * @param {string} accountAddress Signer account address (Hex or num string)\n   * @returns {Signature} The signed message.\n   * @example\n   * ```typescript\n   * const result = myLedgerSigner.signMessage(snip12Message, account0.address);\n   * // result = Signature { r: 611475243393396148729326917410546146405234155928298353899191529090923298688n,\n   * // s: 798839819213540985856952481651392652149797817551686626114697493101433761982n,\n   * // recovery: 0}\n   * ```\n   */\n  public async signMessage(typedDataToHash: TypedData, accountAddress: string): Promise<Signature> {\n    const msgHash = getMessageHash(typedDataToHash, accountAddress);\n    return this.signRaw(msgHash);\n  }\n\n  /**\n   * Sign in a Ledger a V1 or a V3 transaction. This is a blind sign on the Ledger screen.\n   * @param {Call1[]} transactions An array of `Call` transactions (generated for example by `myContract.populate()`).\n   * @param {InvocationsSignerDetails} transactionsDetail An object that includes all the necessary inputs to hash the transaction. Can be `V2InvocationsSignerDetails` or `V3InvocationsSignerDetails` type.\n   * @returns {Signature} The signed transaction.\n   * @example\n   * ```typescript\n   * const txDetailsV3: V3InvocationsSignerDetails = {\n   * chainId: constants.StarknetChainId.SN_MAIN,\n   * nonce: \"28\",\n   * accountDeploymentData: [],\n   * paymasterData: [],\n   * cairoVersion: \"1\",\n   * feeDataAvailabilityMode: \"L1\",\n   * nonceDataAvailabilityMode: \"L1\",\n   * resourceBounds: {\n   *   l1_gas: {\n   *     max_amount: \"0x2a00\",\n   *     max_price_per_unit: \"0x5c00000\"\n   *   },\n   *   l2_gas: {\n   *     max_amount: \"0x00\",\n   *     max_price_per_unit: \"0x00\"\n   *   },\n   * },\n   * tip: 0,\n   * version: \"0x3\",\n   * walletAddress: account0.address\n   * }\n   * const result = myLedgerSigner.signTransaction([call0, call1], txDetailsV3);\n   * // result = Signature { r: 611475243393396148729326917410546146405234155928298353899191529090923298688n,\n   * // s: 798839819213540985856952481651392652149797817551686626114697493101433761982n,\n   * // recovery: 0}\n   * ```\n   */\n  public async signTransaction(\n    transactions: Call[],\n    transactionsDetail: InvocationsSignerDetails\n  ): Promise<Signature> {\n    const compiledCalldata = getExecuteCalldata(transactions, transactionsDetail.cairoVersion);\n    let msgHash;\n\n    // TODO: How to do generic union discriminator for all like this\n    if (Object.values(ETransactionVersion2).includes(transactionsDetail.version as any)) {\n      const det = transactionsDetail as V2InvocationsSignerDetails;\n      msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(transactionsDetail.version as any)) {\n      const det = transactionsDetail as V3InvocationsSignerDetails;\n      msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signTransaction version');\n    }\n\n    return this.signRaw(msgHash as string);\n  }\n\n  /**\n   * Sign in a Ledger the deployment of a new account. This is a blind sign on the Ledger screen.\n   * @param {DeployAccountSignerDetails} details An object that includes all necessary data to calculate the Hash. It can be `V2DeployAccountSignerDetails` or `V3DeployAccountSignerDetails` types.\n   * @returns {Signature} The deploy account signature.\n   * @example\n   * ```typescript\n   * const result = myLedgerSigner.signDeployAccountTransaction(details);\n   * // result = Signature { r: 611475243393396148729326917410546146405234155928298353899191529090923298688n,\n   * // s: 798839819213540985856952481651392652149797817551686626114697493101433761982n,\n   * // recovery: 0}\n   * ```\n   */\n  public async signDeployAccountTransaction(\n    details: DeployAccountSignerDetails\n  ): Promise<Signature> {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    /*     const version = BigInt(details.version).toString(); */\n    let msgHash;\n\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeployAccountTransaction version');\n    }\n\n    return this.signRaw(msgHash as string);\n  }\n\n  /**\n   * Sign in a Ledger the declaration of a new class. This is a blind sign on the Ledger screen.\n   * @param {DeclareSignerDetails} details An object that includes all necessary data to calculate the Hash. It can be `V3DeclareSignerDetails` or `V2DeclareSignerDetails` types.\n   * @returns {Signature} The declare Signature.\n   * @example\n   * ```typescript\n   * const result = myLedgerSigner.signDeclareTransaction(details);\n   * // result = Signature { r: 611475243393396148729326917410546146405234155928298353899191529090923298688n,\n   * // s: 798839819213540985856952481651392652149797817551686626114697493101433761982n,\n   * // recovery: 0}\n   * ```\n   */\n  public async signDeclareTransaction(\n    // contractClass: ContractClass,  // Should be used once class hash is present in ContractClass\n    details: DeclareSignerDetails\n  ): Promise<Signature> {\n    let msgHash;\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2DeclareSignerDetails;\n      msgHash = calculateDeclareTransactionHash({\n        ...det,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeclareSignerDetails;\n      msgHash = calculateDeclareTransactionHash({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeclareTransaction version');\n    }\n    return this.signRaw(msgHash as string);\n  }\n\n  /**\n   * Internal function to sign a hash in a Ledger Nano.\n   * This is a blind sign in the Ledger ; no display of what you are signing.\n   */\n  protected async signRaw(msgHash: string): Promise<Signature> {\n    addHexPrefix(\n      buf2hex(await this._transporter.send(Number('0x5a'), 2, 0, 0, Buffer.from(this.pathBuffer)))\n    );\n    // eslint-disable-next-line no-bitwise\n    const shiftedHash = toHex(BigInt(msgHash) << 4n);\n    const buff2 = hexToBytes(shiftedHash);\n    const respSign2 = Uint8Array.from(\n      await this._transporter.send(Number('0x5a'), 2, 1, 0, Buffer.from(buff2))\n    );\n    const r = BigInt(addHexPrefix(buf2hex(respSign2.subarray(1, 33))));\n    const s = BigInt(addHexPrefix(buf2hex(respSign2.subarray(33, 65))));\n    const v = respSign2[65];\n    const sign0 = new starkCurve.Signature(r, s);\n    const sign1 = sign0.addRecoveryBit(v);\n    return sign1;\n  }\n\n  /** internal function to get both the Starknet public key and the full public key */\n  protected async getPublicKeys() {\n    const pathBuff = this.pathBuffer;\n    const respGetPublic = Uint8Array.from(\n      await this._transporter.send(Number('0x5a'), 1, 0, 0, Buffer.from(pathBuff))\n    );\n    this.pubKey = addHexPrefix(buf2hex(respGetPublic.subarray(1, 33)));\n    this.fullPubKey = addHexPrefix(buf2hex(respGetPublic.subarray(0, 65)));\n  }\n}\n\n/**\n * Format the Ledger wallet path to an Uint8Array\n * for a Ledger Starknet DAPP v1.1.1.\n *\n * EIP2645 path = 2645'/starknet/application/0/accountId/0\n * @param {number} accountId Id of account. < 2**31.\n * @param {string} [applicationName='LedgerW'] utf8 string of application name.\n * @returns an Uint8array of 24 bytes.\n * @example\n * ```typescript\n * const result = getLedgerPathBuffer111(0);\n * // result = Uint8Array(24) [\n *   128,   0,  10,  85,  71, 65, 233, 201,\n *    43, 206, 231, 219,   0,  0,   0,   0,\n *     0,   0,   0,   0,   0,  0,   0,   0\n * ]\n * ```\n */\nexport function getLedgerPathBuffer111(\n  accountId: number,\n  applicationName: string = 'LedgerW'\n): Uint8Array {\n  const path0buff = new Uint8Array([128, 0, 10, 85]); // \"0x80000A55\" EIP2645;\n  const path1buff = new Uint8Array([71, 65, 233, 201]); // \"starknet\"\n  const path2buff =\n    applicationName === 'LedgerW'\n      ? new Uint8Array([43, 206, 231, 219])\n      : stringToSha256ToArrayBuff4(applicationName);\n  const path3buff = new Uint8Array([0, 0, 0, 0]);\n  const hex = toHex(accountId);\n  const padded = addHexPrefix(removeHexPrefix(hex).padStart(8, '0'));\n  const path4buff = hexToBytes(padded);\n  const path5buff = new Uint8Array([0, 0, 0, 0]);\n  const pathBuff = concatenateArrayBuffer([\n    path0buff,\n    path1buff,\n    path2buff,\n    path3buff,\n    path4buff,\n    path5buff,\n  ]);\n  return pathBuff;\n}\n","/* eslint-disable no-bitwise */\nimport { hexToBytes } from '@noble/curves/abstract/utils';\n\nimport { ADDR_BOUND, ZERO } from '../global/constants';\nimport { BigNumberish } from '../types';\nimport { addHexPrefix, removeHexPrefix } from './encode';\nimport { keccakBn } from './hash';\nimport { assertInRange, toHex } from './num';\n\n/**\n * Format a hex number to '0x' and 64 characters, adding leading zeros if necessary.\n *\n * @param {BigNumberish} address\n * @returns {string} Hex string : 0x followed by 64 characters. No upper case characters in the response.\n * @example\n * ```typescript\n * const address = \"0x90591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf\";\n * const result = addAddressPadding(address);\n * // result = \"0x0000090591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf\"\n * ```\n */\nexport function addAddressPadding(address: BigNumberish): string {\n  const hex = toHex(addHexPrefix(address.toString()));\n  const padded = removeHexPrefix(hex).padStart(64, '0');\n  return addHexPrefix(padded);\n}\n\n/**\n * Check the validity of a Starknet address, and format it as a hex number : '0x' and 64 characters, adding leading zeros if necessary.\n *\n * @param {BigNumberish} address\n * @returns {string} Hex string : 0x followed by 64 characters. No upper case characters in the response.\n * @throws address argument must be a valid address inside the address range bound\n * @example\n * ```typescript\n * const address = \"0x90591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf\";\n * const result = validateAndParseAddress(address);\n * // result = \"0x0000090591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf\"\n * ```\n */\nexport function validateAndParseAddress(address: BigNumberish): string {\n  const result = addAddressPadding(address);\n\n  if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n    throw new Error('Invalid Address Format');\n  }\n\n  assertInRange(result, ZERO, ADDR_BOUND - 1n, 'Starknet Address');\n\n  return result;\n}\n\n/**\n * Convert an address to her checksum representation which uses a specific pattern of uppercase and lowercase letters within\n * a given address to reduce the risk of errors introduced from typing an address or cut and paste issues.\n * @param {BigNumberish} address\n * @returns {string} Hex string : 0x followed by 64 characters. Mix of uppercase and lowercase\n * @example\n * ```typescript\n * const address = \"0x90591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf\";\n * const result = getChecksumAddress(address);\n * // result = \"0x0000090591D9fA3EfC87067d95a643f8455E0b8190eb8Cb7bFd39e4fb7571fDF\"\n * ```\n */\n// from https://github.com/ethers-io/ethers.js/blob/fc1e006575d59792fa97b4efb9ea2f8cca1944cf/packages/address/src.ts/index.ts#L12\nexport function getChecksumAddress(address: BigNumberish): string {\n  const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split('');\n  const hex = removeHexPrefix(keccakBn(address));\n  const hashed = hexToBytes(hex.padStart(64, '0'));\n\n  for (let i = 0; i < chars.length; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase();\n    }\n    if ((hashed[i >> 1] & 0x0f) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase();\n    }\n  }\n\n  return addHexPrefix(chars.join(''));\n}\n\n/**\n * If the casing of an address is mixed, it is a Checksum Address, which uses a specific pattern of uppercase and lowercase letters within\n * a given address to reduce the risk of errors introduced from typing an address or cut and paste issues.\n *\n * @param address string\n * @returns true if the ChecksumAddress is valid\n * @example\n * ```typescript\n * const address = \"0x0000090591D9fA3EfC87067d95a643f8455E0b8190eb8Cb7bFd39e4fb7571fDF\";\n * const result = validateChecksumAddress(address);\n * // result = true\n * ```\n */\nexport function validateChecksumAddress(address: string): boolean {\n  return getChecksumAddress(address) === address;\n}\n","/* eslint-disable no-await-in-loop */\n/* eslint-disable no-bitwise */\n/* eslint no-underscore-dangle: [\"error\", { \"allowAfterThis\": true }] */\nimport type {\n  InvocationsSignerDetails,\n  V2InvocationsSignerDetails,\n  Call,\n  Signature,\n  Calldata,\n  BigNumberish,\n  V3InvocationsSignerDetails,\n  LedgerPathCalculation,\n  DeployAccountSignerDetails,\n  V2DeployAccountSignerDetails,\n  V3DeployAccountSignerDetails,\n} from '../types';\nimport assert from '../utils/assert';\nimport { CallData } from '../utils/calldata';\nimport type { SignerInterface } from './interface';\nimport { HARDENING_4BYTES, HARDENING_BYTE } from '../global/constants';\nimport { ETransactionVersion2 } from '../types/api/rpcspec_0_6';\nimport { getExecuteCalldata } from '../utils/transaction';\nimport {\n  calculateDeployAccountTransactionHash,\n  calculateInvokeTransactionHash,\n  getSelector,\n} from '../utils/hash';\nimport { intDAM } from '../utils/stark';\nimport { addHexPrefix, buf2hex, concatenateArrayBuffer, removeHexPrefix } from '../utils/encode';\nimport { hexToBytes, stringToSha256ToArrayBuff4, toBigInt, toHex } from '../utils/num';\nimport { starkCurve } from '../utils/ec';\nimport { EDAMode, EDataAvailabilityMode, ETransactionVersion3 } from '../types/api';\nimport { addAddressPadding } from '../utils/address';\nimport {\n  encodeResourceBoundsL1,\n  encodeResourceBoundsL2,\n  hashDAMode,\n} from '../utils/hash/transactionHash/v3';\nimport { LedgerSigner111 } from './ledgerSigner111';\n\n/**\n * Signer for accounts using a Ledger Nano S+/X signature (Starknet Ledger APP version 2.2.1).\n *\n * The Ledger has to be connected, unlocked and the Starknet APP has to be selected prior of use of this class.\n */\nexport class LedgerSigner221<Transport extends Record<any, any> = any>\n  extends LedgerSigner111\n  implements SignerInterface\n{\n  /**\n   * constructor of the LedgerSigner class.\n   * @param {Transport} transport 5 transports are available to handle USB, bluetooth, Node, Web, Mobile.\n   * See Guides for more details.\n   * @param {number} accountID ID of Ledger Nano (can handle 2**31 accounts).\n   * @param {string} [eip2645application='LedgerW'] A wallet is defined by an ERC2645 derivation path (6 items).\n   * One item is called `application` and can be customized.\n   * Default value is `LedgerW`.\n   * @param {LedgerPathCalculation} [pathFunction=getLedgerPathBuffer221]\n   * defines the function that will calculate the path. By default `getLedgerPathBuffer221` is selected.\n   *\n   * If you are using APP v2.2.1 with an account created with the v1.1.1, you need to use :\n   * ```typescript\n   * const myLedgerSigner = new LedgerSigner211(myNodeTransport, 0, undefined, getLedgerPathBuffer111);\n   * ```\n   * @example\n   * ```typescript\n   * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid\";\n   * const myNodeTransport = await TransportNodeHid.create();\n   * const myLedgerSigner = new LedgerSigner211(myNodeTransport, 0);\n   * ```\n   */\n  constructor(\n    transport: Transport,\n    accountID: number,\n    eip2645application: string = 'LedgerW',\n    pathFunction: LedgerPathCalculation = getLedgerPathBuffer221\n  ) {\n    super(transport, accountID, eip2645application, pathFunction);\n  }\n\n  /**\n   * Sign in a Ledger a V1 or a V3 transaction. The details are displayed on the Ledger screen.\n   * @param {Call[]} transactions An array of `Call` transactions (generated for example by `myContract.populate()`).\n   * @param {InvocationsSignerDetails} transactionsDetail An object that includes all the necessary inputs to hash the transaction. Can be `V2InvocationsSignerDetails` or `V3InvocationsSignerDetails` type.\n   * @returns {Signature} The signed transaction.\n   * @example\n   * ```typescript\n   * const txDetailsV3: V3InvocationsSignerDetails = {\n   * chainId: constants.StarknetChainId.SN_MAIN,\n   * nonce: \"28\",\n   * accountDeploymentData: [],\n   * paymasterData: [],\n   * cairoVersion: \"1\",\n   * feeDataAvailabilityMode: \"L1\",\n   * nonceDataAvailabilityMode: \"L1\",\n   * resourceBounds: {\n   *   l1_gas: {\n   *     max_amount: \"0x2a00\",\n   *     max_price_per_unit: \"0x5c00000\"\n   *   },\n   *   l2_gas: {\n   *     max_amount: \"0x00\",\n   *     max_price_per_unit: \"0x00\"\n   *   },\n   * },\n   * tip: 0,\n   * version: \"0x3\",\n   * walletAddress: account0.address\n   * }\n   * const result = myLedgerSigner.signTransaction([call0, call1], txDetailsV3);\n   * // result = Signature { r: 611475243393396148729326917410546146405234155928298353899191529090923298688n,\n   * // s: 798839819213540985856952481651392652149797817551686626114697493101433761982n,\n   * // recovery: 0}\n   * ```\n   */\n  public async signTransaction(\n    transactions: Call[],\n    transactionsDetail: InvocationsSignerDetails\n  ): Promise<Signature> {\n    const compiledCalldata = getExecuteCalldata(transactions, transactionsDetail.cairoVersion);\n    // TODO: How to do generic union discriminator for all like this\n    if (Object.values(ETransactionVersion2).includes(transactionsDetail.version as any)) {\n      const det = transactionsDetail as V2InvocationsSignerDetails;\n      const msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n      });\n      const ledgerResponse = await this.signTxV1(det, transactions);\n      assert(\n        toBigInt(msgHash) === ledgerResponse.hash,\n        'The transaction hash calculated by Starknet.js is different from the one calculated by the Ledger.'\n      ); // probably non compatibility with Cairo 0\n      return ledgerResponse.signature;\n    }\n    if (Object.values(ETransactionVersion3).includes(transactionsDetail.version as any)) {\n      const det = transactionsDetail as V3InvocationsSignerDetails;\n      const msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n      const ledgerResponse = await this.signTxV3(det, transactions);\n      assert(\n        toBigInt(msgHash) === ledgerResponse.hash,\n        'The transaction hash calculated by Starknet.js is different from the one calculated by the Ledger.'\n      ); // probably non compatibility with Cairo 0\n      return ledgerResponse.signature;\n    }\n    throw Error('unsupported signTransaction version');\n  }\n\n  /**\n   * Sign in a Ledger the deployment of a new account. The details are displayed on the Ledger screen.\n   * @param {DeployAccountSignerDetails} details An object that includes all necessary data to calculate the Hash. It can be `V2DeployAccountSignerDetails` or `V3DeployAccountSignerDetails` types.\n   * @returns {Signature} The deploy account signature.\n   * @example\n   * ```typescript\n   * const result = myLedgerSigner.signDeployAccountTransaction(details);\n   * // result = Signature { r: 611475243393396148729326917410546146405234155928298353899191529090923298688n,\n   * // s: 798839819213540985856952481651392652149797817551686626114697493101433761982n,\n   * // recovery: 0}\n   * ```\n   */\n  public async signDeployAccountTransaction(\n    details: DeployAccountSignerDetails\n  ): Promise<Signature> {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    let msgHash;\n\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version,\n      });\n      const ledgerResponse = await this.signDeployAccountV1(det);\n      assert(\n        toBigInt(msgHash) === ledgerResponse.hash,\n        'The transaction hash calculated by Starknet.js is different from the one calculated by the Ledger.'\n      ); // probably non compatibility with Cairo 0\n      return ledgerResponse.signature;\n    }\n    if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n      const ledgerResponse = await this.signDeployAccountV3(det);\n      assert(\n        toBigInt(msgHash) === ledgerResponse.hash,\n        'The transaction hash calculated by Starknet.js is different from the one calculated by the Ledger.'\n      ); // probably non compatibility with Cairo 0\n      return ledgerResponse.signature;\n    }\n    throw Error('unsupported signDeployAccountTransaction version');\n  }\n\n  /**\n   * Internal function to convert a bigNumberish to an Uint8array of 256 bits\n   * @param {BigNumberish} input input value\n   * @returns {Uint8Array} a Uint8Array containing 32 bytes.\n   */\n  protected convertBnToLedger(input: BigNumberish): Uint8Array {\n    return hexToBytes(addAddressPadding(toHex(input)));\n  }\n\n  /**\n   * Internal function to decode the response of the Ledger signature\n   * @param {Uint8Array} respSign the Buffer response of the Ledger\n   * @returns { hash: bigint; signature: Signature } transaction hash & signature\n   */\n  protected decodeSignatureLedger(respSign: Uint8Array): { hash: bigint; signature: Signature } {\n    const h = BigInt(addHexPrefix(buf2hex(respSign.subarray(0, 32))));\n    const r = BigInt(addHexPrefix(buf2hex(respSign.subarray(33, 65))));\n    const s = BigInt(addHexPrefix(buf2hex(respSign.subarray(65, 97))));\n    const v = respSign[97];\n    const sign0 = new starkCurve.Signature(r, s);\n    const sign1 = sign0.addRecoveryBit(v);\n    return { hash: h, signature: sign1 };\n  }\n\n  /** Internal function to convert a Call to an array of Uint8Array.\n   * @param {Call} call A Call to convert.\n   * @return {Uint8Array[]} Call encoded in an array of Uint8Array (each containing 7 u256).\n   */\n  protected encodeCall(call: Call): Uint8Array[] {\n    const toBuf: Uint8Array = this.convertBnToLedger(call.contractAddress);\n    const selectorBuf: Uint8Array = hexToBytes(addAddressPadding(getSelector(call.entrypoint)));\n    let calldataBuf: Uint8Array = new Uint8Array([]);\n    if (call.calldata) {\n      const compiledCalldata: Calldata = CallData.compile(call.calldata);\n\n      calldataBuf = concatenateArrayBuffer(\n        compiledCalldata.map((parameter: string): Uint8Array => {\n          const a = this.convertBnToLedger(parameter);\n          return a;\n        })\n      );\n    }\n    const callBuf: Uint8Array = concatenateArrayBuffer([toBuf, selectorBuf, calldataBuf]);\n    // slice data into chunks of 7 * 32 bytes\n    const calldatas: Uint8Array[] = [];\n    const chunkSize = 7 * 32; // 224 bytes\n    for (let i = 0; i < callBuf.length; i += chunkSize)\n      calldatas.push(callBuf.subarray(i, i + chunkSize));\n    return calldatas;\n  }\n\n  /**\n   * Ask the Ledger Nano to display and sign a Starknet V1 transaction.\n   * @param {V2InvocationsSignerDetails} txDetails All the details needed for a txV1.\n   * @param {Call[]} calls array of Starknet invocations\n   * @returns an object including the transaction Hash and the signature\n   * @example\n   * ```typescript\n   * const calls: Call[] = [{contractAddress: \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n   *      entrypoint: \"transfer\",\n   *      calldata:[\"0x11f5fc2a92ac03434a7937fe982f5e5293b65ad438a989c5b78fb8f04a12016\",\n   *        \"0x9184e72a000\", \"0x0\"]}];\n   * const txDet: V2InvocationsSignerDetails = {\n   *    walletAddress: txDetails.accountAddress,\n   *    chainId: constants.StarknetChainId.SN_MAIN,\n   *    cairoVersion: \"1\", maxFee: txDetails.max_fee,\n   *    nonce: txDetails.nonce, version: \"0x1\"\n   *  };\n   * const res = await myLedgerSigner.signTxV1(txDet, calls);\n   * // res = {hash:\n   * //   signature:\n   * // }\n   * ```\n   */\n  public async signTxV1(\n    txDetails: V2InvocationsSignerDetails,\n    calls: Call[]\n  ): Promise<{ hash: bigint; signature: Signature }> {\n    // APDU 0 for path\n    await this._transporter.send(Number('0x5a'), 4, 0, 0, Buffer.from(this.pathBuffer));\n    /* APDU 1 =\n      accountAddress (32 bytes) +\n      max_fee (32 bytes) +\n      chain_id (32 bytes) +\n      nonce (32 bytes) \n    */\n    const accountAddressBuf: Uint8Array = this.convertBnToLedger(txDetails.walletAddress);\n    const maxFeeBuf: Uint8Array = this.convertBnToLedger(txDetails.maxFee);\n    const chainIdBuf: Uint8Array = this.convertBnToLedger(txDetails.chainId);\n    const nonceBuf: Uint8Array = this.convertBnToLedger(txDetails.nonce);\n    const dataBuf: Uint8Array = concatenateArrayBuffer([\n      accountAddressBuf,\n      maxFeeBuf,\n      chainIdBuf,\n      nonceBuf,\n    ]);\n    await this._transporter.send(Number('0x5a'), 4, 1, 0, Buffer.from(dataBuf));\n    // APDU 2 = Nb of calls\n    const nbCallsBuf: Uint8Array = this.convertBnToLedger(calls.length);\n    await this._transporter.send(Number('0x5a'), 4, 2, 0, Buffer.from(nbCallsBuf));\n    // APDU 3 = Calls\n    let respSign: Uint8Array = new Uint8Array(0);\n    // eslint-disable-next-line no-restricted-syntax\n    for (const call of calls) {\n      const calldatas: Uint8Array[] = this.encodeCall(call);\n      await this._transporter.send(Number('0x5a'), 4, 3, 0, Buffer.from(calldatas[0]));\n      if (calldatas.length > 1) {\n        calldatas.slice(1).forEach(async (part: Uint8Array) => {\n          await this._transporter.send(Number('0x5a'), 4, 3, 1, Buffer.from(part));\n        });\n      }\n      respSign = await this._transporter.send(Number('0x5a'), 4, 3, 2);\n    }\n    return this.decodeSignatureLedger(respSign);\n  }\n\n  /**\n   * Ask to the Ledger Nano to display and sign a Starknet V3 transaction.\n   * @param {V3InvocationsSignerDetails} txDetails All the details needed for a txV3.\n   * @param {Call[]} calls array of Starknet invocations\n   * @returns an object including the transaction Hash and the signature\n   * @example\n   * ```typescript\n   * const calls: Call[] = [{contractAddress: \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n   *      entrypoint: \"transfer\",\n   *      calldata:[\"0x11f5fc2a92ac03434a7937fe982f5e5293b65ad438a989c5b78fb8f04a12016\",\n   *        \"0x9184e72a000\", \"0x0\"]}];\n   * const txDetailsV3: V3InvocationsSignerDetails = {\n   *   chainId: constants.StarknetChainId.SN_MAIN,\n   *   nonce: \"28\", accountDeploymentData: [],\n   *   paymasterData: [], cairoVersion: \"1\",\n   *   feeDataAvailabilityMode: \"L1\", nonceDataAvailabilityMode: \"L1\",\n   *   resourceBounds: {\n   *     l1_gas: { max_amount: \"0x2a00\", max_price_per_unit: \"0x5c00000\"\n   *     },\n   *     l2_gas: { max_amount: \"0x00\", max_price_per_unit: \"0x00\"},\n   *   }, tip: 0, version: \"0x3\", walletAddress: account0.address\n   *  };\n   * const res = await myLedgerSigner.signTxV3(txDetailsV3, calls);\n   * // res = {hash:\n   * //   signature:\n   * // }\n   * ```\n   */\n  public async signTxV3(\n    txDetails: V3InvocationsSignerDetails,\n    calls: Call[]\n  ): Promise<{ hash: bigint; signature: Signature }> {\n    assert(txDetails.paymasterData.length <= 7, 'Paymaster data includes more than 7 items.');\n    assert(\n      txDetails.accountDeploymentData.length <= 7,\n      'accountDeploymentData includes more than 7 items'\n    );\n    // APDU 0 for path\n    await this._transporter.send(Number('0x5a'), 3, 0, 0, Buffer.from(this.pathBuffer));\n    /* APDU 1 =\n      accountAddress (32 bytes) +\n      tip (32 bytes) +\n      l1_gas_bounds (32 bytes) +\n      l2_gas_bounds (32 bytes) +\n      chain_id (32 bytes) +\n      nonce (32 bytes) +\n      data_availability_mode (32 bytes)\n    */\n    const accountAddressBuf = this.convertBnToLedger(txDetails.walletAddress);\n    const tipBuf = this.convertBnToLedger(txDetails.tip);\n    const chainIdBuf = this.convertBnToLedger(txDetails.chainId);\n    const nonceBuf = this.convertBnToLedger(txDetails.nonce);\n    const dAModeHashBuf = this.convertBnToLedger(\n      hashDAMode(\n        txDetails.nonceDataAvailabilityMode === EDataAvailabilityMode.L1 ? EDAMode.L1 : EDAMode.L2,\n        txDetails.feeDataAvailabilityMode === EDataAvailabilityMode.L1 ? EDAMode.L1 : EDAMode.L2\n      )\n    );\n    const l1_gasBuf = this.convertBnToLedger(encodeResourceBoundsL1(txDetails.resourceBounds));\n    const l2_gasBuf = this.convertBnToLedger(encodeResourceBoundsL2(txDetails.resourceBounds));\n    const dataBuf: Uint8Array = concatenateArrayBuffer([\n      accountAddressBuf,\n      tipBuf,\n      l1_gasBuf,\n      l2_gasBuf,\n      chainIdBuf,\n      nonceBuf,\n      dAModeHashBuf,\n    ]);\n    await this._transporter.send(Number('0x5a'), 3, 1, 0, Buffer.from(dataBuf));\n    // APDU 2 = paymaster data\n    const paymasterBuf = concatenateArrayBuffer(\n      txDetails.paymasterData.map((value: BigNumberish): Uint8Array => {\n        const a = this.convertBnToLedger(value);\n        return a;\n      })\n    );\n    await this._transporter.send(Number('0x5a'), 3, 2, 0, Buffer.from(paymasterBuf));\n    //  APDU 3 = account deployment data\n    const accountDeployDataBuf = concatenateArrayBuffer(\n      txDetails.paymasterData.map((value: BigNumberish): Uint8Array => {\n        const a = this.convertBnToLedger(value);\n        return a;\n      })\n    );\n    await this._transporter.send(Number('0x5a'), 3, 3, 0, Buffer.from(accountDeployDataBuf));\n    // APDU 4 = Nb of calls\n    const nbCallsBuf: Uint8Array = this.convertBnToLedger(calls.length);\n    await this._transporter.send(Number('0x5a'), 3, 4, 0, Buffer.from(nbCallsBuf));\n    // APDU 5 = Calls\n    let respSign: Uint8Array = new Uint8Array(0);\n    // eslint-disable-next-line no-restricted-syntax\n    for (const call of calls) {\n      const calldatas: Uint8Array[] = this.encodeCall(call);\n      await this._transporter.send(Number('0x5a'), 3, 5, 0, Buffer.from(calldatas[0]));\n      if (calldatas.length > 1) {\n        calldatas.slice(1).forEach(async (part: Uint8Array) => {\n          await this._transporter.send(Number('0x5a'), 3, 5, 1, Buffer.from(part));\n        });\n      }\n      respSign = await this._transporter.send(Number('0x5a'), 3, 5, 2);\n    }\n    return this.decodeSignatureLedger(respSign);\n  }\n\n  /**\n   * Ask the Ledger Nano to display and sign a Starknet V1 account deployment.\n   * @param {V2DeployAccountSignerDetails} deployAccountDetail All the details needed for a V1 deploy account.\n   * @returns an object including the transaction Hash and the signature\n   * @example\n   * ```typescript\n   * const deployData: V2DeployAccountSignerDetails =\n   * {\n   *  tip: 0, paymasterData: [], accountDeploymentData: [],\n   *  nonceDataAvailabilityMode: 'L1', feeDataAvailabilityMode: 'L1',\n   *  resourceBounds: {\n   *    l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n   *    l1_gas: { max_amount: '0x0', max_price_per_unit: '0x0' }\n   *   },\n   *  classHash: '0x540d7f5ec7ecf317e68d48564934cb99259781b1ee3cedbbc37ec5337f8e688',\n   *  constructorCalldata: [\n   *    '89832696000889662999767022750851886674077821293893187900664573372145410755'\n   *  ],\n   *  contractAddress: '0x32c60fba64eb96831d064bbb2319375b7b7381543abe66da872e4344bcd72a0',\n   *  addressSalt: '0x0032d7efe2a9232f9b463e7206c68fdea4aeb13fec0cb308c6ba1d197d5922c3',\n   *  chainId: '0x534e5f5345504f4c4941', maxFee: 55050000000000n,\n   *  version: '0x1', nonce: 0n\n   *}\n   * const res = await myLedgerSigner.signDeployAccountV1(deployData);\n   * // res = {hash:\n   * //   signature:\n   * // }\n   * ```\n   */\n  public async signDeployAccountV1(\n    deployAccountDetail: V2DeployAccountSignerDetails\n  ): Promise<{ hash: bigint; signature: Signature }> {\n    // APDU 0 for path\n    await this._transporter.send(Number('0x5a'), 6, 0, 0, Buffer.from(this.pathBuffer));\n    /* APDU 1 =\n      contract_address (32 bytes) +\n      class_hash (32 bytes) +\n      contract_address_salt (32 bytes) +\n      chain_id (32 bytes) +\n      nonce (32 bytes)\n    */\n    const accountAddressBuf: Uint8Array = this.convertBnToLedger(\n      deployAccountDetail.contractAddress\n    );\n    const classHashBuf: Uint8Array = this.convertBnToLedger(deployAccountDetail.classHash);\n    const saltBuf: Uint8Array = this.convertBnToLedger(deployAccountDetail.addressSalt);\n    const chainIdBuf: Uint8Array = this.convertBnToLedger(deployAccountDetail.chainId);\n    const nonceBuf: Uint8Array = this.convertBnToLedger(deployAccountDetail.nonce);\n    const dataBuf: Uint8Array = concatenateArrayBuffer([\n      accountAddressBuf,\n      classHashBuf,\n      saltBuf,\n      chainIdBuf,\n      nonceBuf,\n    ]);\n    await this._transporter.send(Number('0x5a'), 6, 1, 0, Buffer.from(dataBuf));\n    // APDU 2 = Nb of calls\n    const maxFreeBuf: Uint8Array = this.convertBnToLedger(deployAccountDetail.maxFee);\n    await this._transporter.send(Number('0x5a'), 6, 2, 0, Buffer.from(maxFreeBuf));\n    // APDU 3 = constructor length\n    const compiledConstructor = CallData.compile(deployAccountDetail.constructorCalldata);\n    const constructorLengthBuf: Uint8Array = this.convertBnToLedger(compiledConstructor.length);\n    await this._transporter.send(Number('0x5a'), 6, 3, 0, Buffer.from(constructorLengthBuf));\n    // APDU 4 = constructor\n    const constructorBuf = concatenateArrayBuffer(\n      compiledConstructor.map((parameter: string): Uint8Array => {\n        const a = this.convertBnToLedger(parameter);\n        return a;\n      })\n    );\n    const constructorChunks: Uint8Array[] = [];\n    const chunkSize = 7 * 32; // 224 bytes\n    for (let i = 0; i < constructorBuf.length; i += chunkSize)\n      constructorChunks.push(constructorBuf.subarray(i, i + chunkSize));\n    let respSign: Uint8Array = new Uint8Array(0);\n    // eslint-disable-next-line no-restricted-syntax\n    for (const chunk of constructorChunks) {\n      respSign = await this._transporter.send(Number('0x5a'), 6, 4, 0, Buffer.from(chunk));\n    }\n    return this.decodeSignatureLedger(respSign);\n  }\n\n  /**\n   *Ask the Ledger Nano to display and sign a Starknet V3 account deployment.\n   * @param {V3DeployAccountSignerDetails} deployAccountDetail All the details needed for a V3 deploy account.\n   * @returns an object including the transaction Hash and the signature\n   * @example\n   * ```typescript\n   * const deployData: V3DeployAccountSignerDetails =\n   * {\n   *  tip: 0, paymasterData: [], accountDeploymentData: [],\n   *  nonceDataAvailabilityMode: 'L1', feeDataAvailabilityMode: 'L1',\n   *  resourceBounds: {\n   *    l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n   *    l1_gas: { max_amount: '0x226', max_price_per_unit: '0x22ecb25c00' }\n   *   },\n   *  classHash: '0x540d7f5ec7ecf317e68d48564934cb99259781b1ee3cedbbc37ec5337f8e688',\n   *  constructorCalldata: [\n   *    '3571125127744830445572285574469842579401255431821644822726857471463672199621'\n   *  ],\n   *  contractAddress: '0x4ca062add1cf12a107be1107af17981cf6e544a24d987693230ea481d3d5e34',\n   *  addressSalt: '0x07e52f68e3160e1ef698211cdf6d3792368fe347e7e2d4a8ace14d9b248f39c5',\n   *  chainId: '0x534e5f5345504f4c4941', maxFee: 0,\n   *  version: '0x3', nonce: 0n\n   *}\n   * const res = await myLedgerSigner.signDeployAccountV3(deployData);\n   * // res = {hash:\n   * //   signature:\n   * // }\n   * ```\n   */\n  public async signDeployAccountV3(\n    deployAccountDetail: V3DeployAccountSignerDetails\n  ): Promise<{ hash: bigint; signature: Signature }> {\n    // APDU 0 for path\n    await this._transporter.send(Number('0x5a'), 5, 0, 0, Buffer.from(this.pathBuffer));\n    /* APDU 1 =\n      contract_address (32 bytes) +\n      chain_id (32 bytes) +\n      nonce (32 bytes) +\n      data_availability_mode (32 bytes) +\n      class_hash (32 bytes) +\n      contract_address_salt (32 bytes)\n    */\n    const accountAddressBuf: Uint8Array = this.convertBnToLedger(\n      deployAccountDetail.contractAddress\n    );\n    const chainIdBuf: Uint8Array = this.convertBnToLedger(deployAccountDetail.chainId);\n    const nonceBuf: Uint8Array = this.convertBnToLedger(deployAccountDetail.nonce);\n    const dAModeHashBuf = this.convertBnToLedger(\n      hashDAMode(\n        deployAccountDetail.nonceDataAvailabilityMode === EDataAvailabilityMode.L1\n          ? EDAMode.L1\n          : EDAMode.L2,\n        deployAccountDetail.feeDataAvailabilityMode === EDataAvailabilityMode.L1\n          ? EDAMode.L1\n          : EDAMode.L2\n      )\n    );\n    const classHashBuf: Uint8Array = this.convertBnToLedger(deployAccountDetail.classHash);\n    const saltBuf: Uint8Array = this.convertBnToLedger(deployAccountDetail.addressSalt);\n    const dataBuf: Uint8Array = concatenateArrayBuffer([\n      accountAddressBuf,\n      chainIdBuf,\n      nonceBuf,\n      dAModeHashBuf,\n      classHashBuf,\n      saltBuf,\n    ]);\n    await this._transporter.send(Number('0x5a'), 5, 1, 0, Buffer.from(dataBuf));\n    // APDU 2 = fees\n    const tipBuf = this.convertBnToLedger(deployAccountDetail.tip);\n    const l1_gasBuf = this.convertBnToLedger(\n      encodeResourceBoundsL1(deployAccountDetail.resourceBounds)\n    );\n    const l2_gasBuf = this.convertBnToLedger(\n      encodeResourceBoundsL2(deployAccountDetail.resourceBounds)\n    );\n    const feeBuf: Uint8Array = concatenateArrayBuffer([tipBuf, l1_gasBuf, l2_gasBuf]);\n    await this._transporter.send(Number('0x5a'), 5, 2, 0, Buffer.from(feeBuf));\n    // APDU 3 = paymaster data\n    const paymasterBuf = concatenateArrayBuffer(\n      deployAccountDetail.paymasterData.map((value: BigNumberish): Uint8Array => {\n        const a = this.convertBnToLedger(value);\n        return a;\n      })\n    );\n    await this._transporter.send(Number('0x5a'), 5, 3, 0, Buffer.from(paymasterBuf));\n    // APDU 4 = constructor length\n    const compiledConstructor = CallData.compile(deployAccountDetail.constructorCalldata);\n    const constructorLengthBuf: Uint8Array = this.convertBnToLedger(compiledConstructor.length);\n    await this._transporter.send(Number('0x5a'), 5, 4, 0, Buffer.from(constructorLengthBuf));\n    // APDU 4 = constructor\n    const constructorBuf = concatenateArrayBuffer(\n      compiledConstructor.map((parameter: string): Uint8Array => {\n        const a = this.convertBnToLedger(parameter);\n        return a;\n      })\n    );\n    const constructorChunks: Uint8Array[] = [];\n    const chunkSize = 7 * 32; // 224 bytes\n    for (let i = 0; i < constructorBuf.length; i += chunkSize)\n      constructorChunks.push(constructorBuf.subarray(i, i + chunkSize));\n    let respSign: Uint8Array = new Uint8Array(0);\n    // eslint-disable-next-line no-restricted-syntax\n    for (const chunk of constructorChunks) {\n      respSign = await this._transporter.send(Number('0x5a'), 5, 5, 0, Buffer.from(chunk));\n    }\n    return this.decodeSignatureLedger(respSign);\n  }\n}\n\n/**\n * Format the Ledger wallet path to an Uint8Array.\n * for a Ledger Starknet DAPP v2.2.0\n * EIP2645 path = 2645'/starknet'/application'/0'/accountId'/0\n * @param {number} accountId Id of account. < 2**31.\n * @param {string} [applicationName='LedgerW'] utf8 string of application name.\n * @returns an Uint8array of 24 bytes.\n * @example\n * ```typescript\n * const result = getLedgerPathBuffer211(0);\n * // result = Uint8Array(24) [\n *   128,   0,  10,  85, 199, 65, 233, 201,\n *   171, 206, 231, 219, 128,  0,   0,   0,\n *   128,   0,   0,   0,   0,  0,   0,   0\n * ]\n * ```\n */\nexport function getLedgerPathBuffer221(\n  accountId: number,\n  applicationName: string = 'LedgerW'\n): Uint8Array {\n  const path0buff = new Uint8Array([HARDENING_BYTE, 0, 10, 85]); // \"0x80000A55\" EIP2645;\n  const path1buff = new Uint8Array([71 | HARDENING_BYTE, 65, 233, 201]); // \"starknet'\"\n  const path2Base =\n    applicationName === 'LedgerW'\n      ? new Uint8Array([43, 206, 231, 219])\n      : stringToSha256ToArrayBuff4(applicationName);\n  const path2buff = concatenateArrayBuffer([\n    new Uint8Array([path2Base[0] | HARDENING_BYTE]),\n    path2Base.subarray(1),\n  ]);\n  const path3buff = new Uint8Array([HARDENING_BYTE, 0, 0, 0]);\n  const hex = toHex(BigInt(accountId) | HARDENING_4BYTES);\n  const padded = addHexPrefix(removeHexPrefix(hex).padStart(8, '0'));\n  const path4buff = hexToBytes(padded);\n  const path5buff = new Uint8Array([0, 0, 0, 0]);\n  const pathBuff = concatenateArrayBuffer([\n    path0buff,\n    path1buff,\n    path2buff,\n    path3buff,\n    path4buff,\n    path5buff,\n  ]);\n  return pathBuff;\n}\n","import { UDC } from '../../global/constants';\nimport {\n  Abi,\n  AbiEnums,\n  AbiEvents,\n  AbiStructs,\n  CairoEvent,\n  AbiEvent,\n  LegacyEvent,\n  ParsedEvent,\n  ParsedEvents,\n  RPC,\n  type CairoEventDefinition,\n  type CairoEventVariant,\n  type InvokeTransactionReceiptResponse,\n  type AbiEntry,\n  DeployContractUDCResponse,\n} from '../../types';\nimport assert from '../assert';\nimport { isCairo1Abi } from '../calldata/cairo';\nimport responseParser from '../calldata/responseParser';\nimport { starkCurve } from '../ec';\nimport { addHexPrefix, utf8ToArray } from '../encode';\nimport { cleanHex } from '../num';\nimport { isUndefined, isObject } from '../typed';\n\n/**\n * Check if an ABI entry is related to events.\n * @param {AbiEntry} object an Abi entry\n * @returns {boolean} true if this Abi Entry is related to an event\n * @example\n * ```typescript\n * // use of a transaction receipt\n * ```\n */\nexport function isAbiEvent(object: AbiEntry): boolean {\n  return object.type === 'event';\n}\n\n/**\n * Retrieves the events from the given Cairo 0 ABI.\n * @param {Abi} abi - The Cairo 0 ABI to extract events from.\n * @return {AbiEvents} - An object containing the hashes and the definition of the events.\n * @example\n * ```typescript\n * const result = events.getCairo0AbiEvents(abi0);\n * // result = {\n  '0x35ea10b06d74221d24a134672e9f776a3088ba6b9829e53b9a10abd8817a211': {\n    data: [{ name: 'admin_requester', type: 'felt' }, { name: 'new_requester', type: 'felt' }],\n    keys: [],\n    name: 'AddAdmin',\n    type: 'event'\n  }\n * ```\n */\nfunction getCairo0AbiEvents(abi: Abi): AbiEvents {\n  return abi\n    .filter((abiEntry) => abiEntry.type === 'event')\n    .reduce((acc, abiEntry) => {\n      const entryName = abiEntry.name;\n      const abiEntryMod = { ...abiEntry };\n      abiEntryMod.name = entryName;\n      return {\n        ...acc,\n        [addHexPrefix(starkCurve.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod,\n      };\n    }, {});\n}\n\n/**\n * Retrieves the events from the given Cairo 1 ABI.\n *\n * Is able to handle events nested in Cairo components.\n * @param {Abi} abi - The Cairo 1 ABI to extract events from.\n * @return {AbiEvents} - An object containing the hashes and the definition of the events.\n * @example\n * ```typescript\n * const result = events.getCairo1AbiEvents(abi1);\n * // result = {\n * //   '0x22ea134d4126804c60797e633195f8c9aa5fd6d1567e299f4961d0e96f373ee':\n * //    { '0x34e55c1cd55f1338241b50d352f0e91c7e4ffad0e4271d64eb347589ebdfd16': {\n * //     kind: 'struct', type: 'event',\n * //     name: 'ka::ExComponent::ex_logic_component::Mint',\n * //     members: [{\n * //      name: 'spender',\n * //      type: 'core::starknet::contract_address::ContractAddress',\n * //      kind: 'key'},\n * //      { name: 'value', type: 'core::integer::u256', kind: 'data' }]},\n * // ...\n * ```\n */\nfunction getCairo1AbiEvents(abi: Abi): AbiEvents {\n  const abiEventsStructs = abi.filter((obj) => isAbiEvent(obj) && obj.kind === 'struct');\n  const abiEventsEnums = abi.filter((obj) => isAbiEvent(obj) && obj.kind === 'enum');\n  const abiEventsData: AbiEvents = abiEventsStructs.reduce((acc: CairoEvent, event: CairoEvent) => {\n    let nameList: string[] = [];\n    let { name } = event;\n    let flat: boolean = false;\n    const findName = (variant: CairoEventVariant) => variant.type === name;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const eventEnum = abiEventsEnums.find((eventE) => eventE.variants.some(findName));\n      if (isUndefined(eventEnum)) break;\n      const variant = eventEnum.variants.find(findName);\n      nameList.unshift(variant.name);\n      if (variant.kind === 'flat') flat = true;\n      name = eventEnum.name;\n    }\n\n    if (nameList.length === 0) {\n      throw new Error('inconsistency in ABI events definition.');\n    }\n\n    if (flat) nameList = [nameList[nameList.length - 1]];\n\n    const final = nameList.pop();\n    let result: AbiEvents = {\n      [addHexPrefix(starkCurve.keccak(utf8ToArray(final!)).toString(16))]: event,\n    };\n\n    while (nameList.length > 0) {\n      result = {\n        [addHexPrefix(starkCurve.keccak(utf8ToArray(nameList.pop()!)).toString(16))]: result,\n      };\n    }\n    result = { ...result };\n    return mergeAbiEvents(acc, result);\n  }, {});\n  return abiEventsData;\n}\n\n/**\n * Retrieves the events from the given ABI (from Cairo 0 or Cairo 1 contract).\n *\n * Is able to handle Cairo 1 events nested in Cairo components.\n * @param {Abi} abi - The ABI to extract events from.\n * @return {AbiEvents} - An object containing the hashes and the definition of the events.\n * @example\n * ```typescript\n * const result = events.getAbiEvents(abi);\n * // result = {\n * //   '0x22ea134d4126804c60797e633195f8c9aa5fd6d1567e299f4961d0e96f373ee':\n * //    { '0x34e55c1cd55f1338241b50d352f0e91c7e4ffad0e4271d64eb347589ebdfd16': {\n * //     kind: 'struct', type: 'event',\n * //     name: 'ka::ExComponent::ex_logic_component::Mint',\n * //     members: [{\n * //      name: 'spender',\n * //      type: 'core::starknet::contract_address::ContractAddress',\n * //      kind: 'key'},\n * //      { name: 'value', type: 'core::integer::u256', kind: 'data' }]},\n * // ...\n * ```\n */\nexport function getAbiEvents(abi: Abi): AbiEvents {\n  return isCairo1Abi(abi) ? getCairo1AbiEvents(abi) : getCairo0AbiEvents(abi);\n}\n\n/**\n * internal function to deep merge 2 event description objects\n */\nfunction mergeAbiEvents(target: any, source: any): Object {\n  const output = { ...target };\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach((key) => {\n      if (isObject(source[key])) {\n        if (!(key in target)) Object.assign(output, { [key]: source[key] });\n        else output[key] = mergeAbiEvents(target[key], source[key]);\n      } else {\n        Object.assign(output, { [key]: source[key] });\n      }\n    });\n  }\n  return output;\n}\n\n/**\n * Parse raw events and structure them into response object based on a contract structs and defined events\n * @param {RPC.Event[]} providerReceivedEvents Array of raw events\n * @param {AbiEvents} abiEvents Events defined in the abi\n * @param {AbiStructs} abiStructs Structs defined in the abi\n * @param {AbiEnums} abiEnums Enums defined in the abi\n * @returns {ParsedEvents} parsed events corresponding to the abi\n * @example\n * ```typescript\n * const abiEvents = events.getAbiEvents(sierra.abi);\n * const abiStructs =  CallData.getAbiStruct(sierra.abi);\n * const abiEnums = CallData.getAbiEnum(sierra.abi);\n * const result = events.parseEvents(myEvents, abiEvents, abiStructs, abiEnums);\n * // result = [{test::ExCh::ex_ch::Trade: {\n      maker: 7548613724711489396448209137n,\n      taker: 6435850562375218974960297344n,\n      router_maker: 0n,\n    }}]\n * ```\n */\nexport function parseEvents(\n  providerReceivedEvents: RPC.EmittedEvent[],\n  abiEvents: AbiEvents,\n  abiStructs: AbiStructs,\n  abiEnums: AbiEnums\n): ParsedEvents {\n  const ret = providerReceivedEvents\n    .flat()\n    .reduce((acc, recEvent: RPC.EmittedEvent | RPC.Event) => {\n      let abiEvent: AbiEvent | AbiEvents = abiEvents[recEvent.keys.shift() ?? 0];\n      if (!abiEvent) {\n        return acc;\n      }\n      while (!abiEvent.name) {\n        const hashName = recEvent.keys.shift();\n        assert(!!hashName, 'Not enough data in \"keys\" property of this event.');\n        abiEvent = (abiEvent as AbiEvents)[hashName];\n      }\n      // Create our final event object\n      const parsedEvent: ParsedEvent = {};\n      parsedEvent[abiEvent.name as string] = {};\n      // Remove the event's name hashed from the keys array\n      const keysIter = recEvent.keys[Symbol.iterator]();\n      const dataIter = recEvent.data[Symbol.iterator]();\n\n      const abiEventKeys =\n        (abiEvent as CairoEventDefinition).members?.filter((it) => it.kind === 'key') ||\n        (abiEvent as LegacyEvent).keys;\n      const abiEventData =\n        (abiEvent as CairoEventDefinition).members?.filter((it) => it.kind === 'data') ||\n        (abiEvent as LegacyEvent).data;\n\n      abiEventKeys.forEach((key) => {\n        parsedEvent[abiEvent.name as string][key.name] = responseParser(\n          keysIter,\n          key,\n          abiStructs,\n          abiEnums,\n          parsedEvent[abiEvent.name as string]\n        );\n      });\n\n      abiEventData.forEach((data) => {\n        parsedEvent[abiEvent.name as string][data.name] = responseParser(\n          dataIter,\n          data,\n          abiStructs,\n          abiEnums,\n          parsedEvent[abiEvent.name as string]\n        );\n      });\n      if ('block_hash' in recEvent) parsedEvent.block_hash = recEvent.block_hash;\n      if ('block_number' in recEvent) parsedEvent.block_number = recEvent.block_number;\n      if ('transaction_hash' in recEvent) parsedEvent.transaction_hash = recEvent.transaction_hash;\n      acc.push(parsedEvent);\n      return acc;\n    }, [] as ParsedEvents);\n  return ret;\n}\n\n/**\n * Parse Transaction Receipt Event from UDC invoke transaction and\n * create DeployContractResponse compatible response with addition of the UDC Event data\n * @param {InvokeTransactionReceiptResponse} txReceipt\n *\n * @returns {DeployContractUDCResponse} parsed UDC event data\n */\nexport function parseUDCEvent(\n  txReceipt: InvokeTransactionReceiptResponse\n): DeployContractUDCResponse {\n  if (!txReceipt.events?.length) {\n    throw new Error('UDC emitted event is empty');\n  }\n  const event = txReceipt.events.find(\n    (it: any) => cleanHex(it.from_address) === cleanHex(UDC.ADDRESS)\n  ) || {\n    data: [],\n  };\n  return {\n    transaction_hash: txReceipt.transaction_hash,\n    contract_address: event.data[0],\n    address: event.data[0],\n    deployer: event.data[1],\n    unique: event.data[2],\n    classHash: event.data[3],\n    calldata_len: event.data[4],\n    calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),\n    salt: event.data[event.data.length - 1],\n  };\n}\n","import { CallData } from './calldata';\nimport { Call, type AllowArray, type BigNumberish, type Calldata } from '../types/lib';\nimport {\n  OutsideExecutionTypesV1,\n  OutsideExecutionTypesV2,\n  OutsideExecutionVersion,\n  type OutsideCall,\n  type OutsideExecutionOptions,\n  type OutsideTransaction,\n  type TypedData,\n} from '../types';\nimport { getSelectorFromName } from './hash/selector';\nimport { formatSignature } from './stark';\nimport { toHex } from './num';\n\n/**\n * Converts a Call object to an OutsideCall object that can be used for an Outside Execution.\n * @param {Call} call transaction to proceed.\n * @returns {OutsideCall} transaction formatted in conformity to SNIP-9\n * @example\n * ```typescript\n * const call1: Call = {\n *    contractAddress: '0x0123',\n *    entrypoint: 'transfer',\n *    calldata: { recipient: '0xabcd', amount: cairo.uint256(10) },\n *  };\n *  const result = outsideExecution.getOutsideCall(call1);\n *  // result = {\n *  //  to: '0x0123',\n *  //  selector: getSelectorFromName(call1.entrypoint),\n *  //  calldata: ['43981', '10', '0'],\n *  //}\n * ```\n */\nexport function getOutsideCall(call: Call): OutsideCall {\n  const callData = call.calldata ?? [];\n  const callDataCompiled = Array.isArray(callData) ? callData : CallData.compile(callData);\n  return {\n    to: call.contractAddress,\n    selector: getSelectorFromName(call.entrypoint),\n    calldata: callDataCompiled,\n  };\n}\n\n/**  represents a call object as a typed data, supporting both v1 and v2 versions */\nfunction callToTypedData(call: Call, version: OutsideExecutionVersion) {\n  const outsideCall = getOutsideCall(call);\n  if (version === '1') {\n    return {\n      ...outsideCall,\n      calldata_len: outsideCall.calldata.length,\n      calldata: outsideCall.calldata,\n    };\n  }\n  return {\n    To: outsideCall.to,\n    Selector: outsideCall.selector,\n    Calldata: outsideCall.calldata,\n  };\n}\n\nfunction getDomain(chainId: string, version: OutsideExecutionVersion) {\n  return {\n    name: 'Account.execute_from_outside',\n    version,\n    chainId,\n    ...(version === '2' ? { revision: '1' } : {}),\n  };\n}\n\n/**\n * Build a TypedData message that will be used for an Outside execution.\n * @param {string} chainId  The encoded string of the name of network.\n * @param {OutsideExecutionOptions} options Parameters related to an Outside Execution.\n * @param {BigNumberish} nonce Outside execution nonce (not to confuse with normal transaction nonce).\n * @param {Call[]} myCalls transaction(s) to proceed.\n * @param {OutsideExecutionVersion} version SNIP-9 V1 or V2.\n * @returns {TypedData} SNIP-12 message conform to SNIP-9.\n * @example\n * ```typescript\n * const callOptions: OutsideExecutionOptions = {\n *    caller: '0x1234',\n *    execute_after: 100,\n *    execute_before: 200,\n *  };\n *  const result: TypedData = outsideExecution.getTypedData(\n *    constants.StarknetChainId.SN_SEPOLIA,\n *    callOptions,\n *    21,\n *    [call1],\n *    EOutsideExecutionVersion.V2\n *  );\n *  // result = {\n *  //  domain: {\n *  //    chainId: '0x534e5f5345504f4c4941',\n *  //    name: 'Account.execute_from_outside',\n *  //    revision: '1',\n *  //    version: '2',\n *  //  },\n *  //  message: {\n *  //    Caller: '0x1234',\n *  //  ...\n * ```\n */\nexport function getTypedData(\n  chainId: string,\n  options: OutsideExecutionOptions,\n  nonce: BigNumberish,\n  myCalls: Call[],\n  version: OutsideExecutionVersion\n): TypedData {\n  if (version === '1') {\n    return {\n      types: OutsideExecutionTypesV1,\n      primaryType: 'OutsideExecution',\n      domain: getDomain(chainId, version),\n      message: {\n        ...options,\n        nonce,\n        calls_len: myCalls.length,\n        calls: myCalls.map((call) => callToTypedData(call, version)),\n      },\n    };\n  }\n  return {\n    types: OutsideExecutionTypesV2,\n    primaryType: 'OutsideExecution',\n    domain: getDomain(chainId, version),\n    message: {\n      Caller: options.caller,\n      Nonce: nonce,\n      'Execute After': options.execute_after,\n      'Execute Before': options.execute_before,\n      Calls: myCalls.map((call) => callToTypedData(call, version)),\n    },\n  };\n}\n\n/**\n * Builds a Calldata for the execute_from_outside() entrypoint.\n * @param {OutsideTransaction} outsideTransaction an object that contains all the data for a Outside Execution.\n * @returns {Calldata} The Calldata related to this Outside transaction\n * @example\n * ```typescript\n * const outsideTransaction: OutsideTransaction = {\n *     outsideExecution: {\n *      caller: '0x64b48806902a367c8598f4f95c305e8c1a1acba5f082d294a43793113115691',\n *      nonce: '0x7d0b4b4fce4b236e63d2bb5fc321935d52935cd3b268248cf9cf29c496bd0ae',\n *      execute_after: 500, execute_before: 600,\n *      calls: [{ to: '0x678', selector: '0x890', calldata: [12, 13] }],\n *    },\n *    signature: ['0x123', '0x456'],\n *    signerAddress: '0x3b278ebae434f283f9340587a7f2dd4282658ac8e03cb9b0956db23a0a83657',\n *    version: EOutsideExecutionVersion.V2,\n *  };\n *\n *  const result: Calldata = outsideExecution.buildExecuteFromOutsideCallData(outsideTransaction);\n * // result =      ['2846891009026995430665703316224827616914889274105712248413538305735679628945',\n * //   '3534941323322368687588030484849371698982661160919690922146419787802417549486',\n * //   '500', '600', '1', '1656', '2192', '2', '12', '13', '2', '291', '1110']\n * ```\n */\nexport function buildExecuteFromOutsideCallData(outsideTransaction: OutsideTransaction): Calldata {\n  const execution = outsideTransaction.outsideExecution;\n  const formattedSignature = formatSignature(outsideTransaction.signature);\n  return CallData.compile({\n    outside_execution: execution,\n    signature: formattedSignature,\n  });\n}\n\n/**\n * Builds a Call for execute(), estimateFee() and simulateTransaction() functions.\n * @param {AllowArray<OutsideTransaction>} outsideTransaction an object that contains all the data for an Outside Execution.\n * @returns {Call[]} The Call related to this Outside transaction\n * @example\n * ```typescript\n * const outsideTransaction: OutsideTransaction = {\n *     outsideExecution: {\n *      caller: '0x64b48806902a367c8598f4f95c305e8c1a1acba5f082d294a43793113115691',\n *      nonce: '0x7d0b4b4fce4b236e63d2bb5fc321935d52935cd3b268248cf9cf29c496bd0ae',\n *      execute_after: 500, execute_before: 600,\n *      calls: [{ to: '0x678', selector: '0x890', calldata: [12, 13] }],\n *    },\n *    signature: ['0x123', '0x456'],\n *    signerAddress: '0x3b278ebae434f283f9340587a7f2dd4282658ac8e03cb9b0956db23a0a83657',\n *    version: EOutsideExecutionVersion.V2,\n *  };\n *\n *  const result: Call[] = outsideExecution.buildExecuteFromOutsideCall(outsideTransaction);\n * // result = [{contractAddress: '0x64b48806902a367c8598f4f95c305e8c1a1acba5f082d294a43793113115691',\n * //   entrypoint: 'execute_from_outside_v2',\n * //   calldata: [ ... ],\n * // }]\n * ```\n */\nexport function buildExecuteFromOutsideCall(\n  outsideTransaction: AllowArray<OutsideTransaction>\n): Call[] {\n  const myOutsideTransactions = Array.isArray(outsideTransaction)\n    ? outsideTransaction\n    : [outsideTransaction];\n  const multiCall: Call[] = myOutsideTransactions.map((outsideTx: OutsideTransaction) => {\n    let entrypoint: string;\n    if (outsideTx.version === OutsideExecutionVersion.V1) {\n      entrypoint = 'execute_from_outside';\n    } else if (outsideTx.version === OutsideExecutionVersion.V2) {\n      entrypoint = 'execute_from_outside_v2';\n    } else {\n      throw new Error('Unsupported OutsideExecution version');\n    }\n    return {\n      contractAddress: toHex(outsideTx.signerAddress),\n      entrypoint,\n      calldata: buildExecuteFromOutsideCallData(outsideTx),\n    };\n  });\n  return multiCall;\n}\n","import { RpcProvider } from '../provider';\nimport type { BigNumberish } from '../types';\nimport { toHex } from './num';\n\n/**\n * Implementation of ERC165 introspection.\n * Verify if a contract has implemented some standard functionalities.\n * @param {RpcProvider} provider the provider to access to Starknet.\n * @param {BigNumberish} contractAddress the address of the contract to check.\n * @param {BigNumberish} interfaceId the hash of the functionality to check.\n * @returns {boolean} true if the interfaceId is implemented in this contract.\n * @example\n * ```typescript\n * const snip9InterfaceV2Id = constants.SNIP9_V2_INTERFACE_ID;\n * const result = src5.supportsInterface(myProvider, accountContractAddress, snip9InterfaceV2Id);\n * // result = true\n * ```\n */\nexport async function supportsInterface(\n  provider: RpcProvider,\n  contractAddress: BigNumberish,\n  interfaceId: BigNumberish\n): Promise<boolean> {\n  const call = {\n    contractAddress: toHex(contractAddress),\n    entrypoint: 'supports_interface',\n    calldata: [toHex(interfaceId)],\n  };\n  try {\n    const resp = await provider.callContract(call);\n    return BigInt(resp[0]) !== 0n;\n  } catch {\n    // account not compatible with ERC165 (introspection)\n    return false;\n  }\n}\n","import {\n  OutsideExecutionCallerAny,\n  SNIP9_V1_INTERFACE_ID,\n  SNIP9_V2_INTERFACE_ID,\n  UDC,\n  ZERO,\n} from '../global/constants';\nimport { Provider, ProviderInterface } from '../provider';\nimport { Signer, SignerInterface } from '../signer';\nimport {\n  Abi,\n  AccountInvocations,\n  AccountInvocationsFactoryDetails,\n  AllowArray,\n  BigNumberish,\n  BlockIdentifier,\n  CairoVersion,\n  Call,\n  DeclareAndDeployContractPayload,\n  DeclareContractPayload,\n  DeclareContractResponse,\n  DeclareContractTransaction,\n  DeclareDeployUDCResponse,\n  DeployAccountContractPayload,\n  DeployAccountContractTransaction,\n  DeployContractResponse,\n  DeployContractUDCResponse,\n  DeployTransactionReceiptResponse,\n  EstimateFee,\n  UniversalSuggestedFee,\n  EstimateFeeAction,\n  EstimateFeeBulk,\n  Invocation,\n  Invocations,\n  InvocationsSignerDetails,\n  InvokeFunctionResponse,\n  MultiDeployContractResponse,\n  Nonce,\n  ProviderOptions,\n  Signature,\n  SimulateTransactionDetails,\n  SimulateTransactionResponse,\n  TransactionType,\n  TypedData,\n  UniversalDeployerContractPayload,\n  UniversalDetails,\n} from '../types';\nimport { ETransactionVersion, ETransactionVersion3, type ResourceBounds } from '../types/api';\nimport {\n  OutsideExecutionVersion,\n  type OutsideExecution,\n  type OutsideExecutionOptions,\n  type OutsideTransaction,\n} from '../types/outsideExecution';\nimport { CallData } from '../utils/calldata';\nimport { extractContractHashes, isSierra } from '../utils/contract';\nimport { parseUDCEvent } from '../utils/events';\nimport { calculateContractAddressFromHash } from '../utils/hash';\nimport { isUndefined, isString } from '../utils/typed';\nimport { isHex, toBigInt, toCairoBool, toHex } from '../utils/num';\nimport {\n  buildExecuteFromOutsideCall,\n  getOutsideCall,\n  getTypedData,\n} from '../utils/outsideExecution';\nimport { parseContract } from '../utils/provider';\nimport { supportsInterface } from '../utils/src5';\nimport {\n  estimateFeeToBounds,\n  randomAddress,\n  reduceV2,\n  toFeeVersion,\n  toTransactionVersion,\n  v3Details,\n} from '../utils/stark';\nimport { buildUDCCall, getExecuteCalldata } from '../utils/transaction';\nimport { getMessageHash } from '../utils/typedData';\nimport { AccountInterface } from './interface';\nimport { config } from '../global/config';\n\nexport class Account extends Provider implements AccountInterface {\n  public signer: SignerInterface;\n\n  public address: string;\n\n  public cairoVersion: CairoVersion;\n\n  readonly transactionVersion: typeof ETransactionVersion.V2 | typeof ETransactionVersion.V3;\n\n  constructor(\n    providerOrOptions: ProviderOptions | ProviderInterface,\n    address: string,\n    pkOrSigner: Uint8Array | string | SignerInterface,\n    cairoVersion?: CairoVersion,\n    transactionVersion: typeof ETransactionVersion.V2 | typeof ETransactionVersion.V3 = config.get(\n      'accountTxVersion'\n    )\n  ) {\n    super(providerOrOptions);\n    this.address = address.toLowerCase();\n    this.signer =\n      isString(pkOrSigner) || pkOrSigner instanceof Uint8Array\n        ? new Signer(pkOrSigner)\n        : pkOrSigner;\n\n    if (cairoVersion) {\n      this.cairoVersion = cairoVersion.toString() as CairoVersion;\n    }\n    this.transactionVersion = transactionVersion;\n  }\n\n  // provided version or contract based preferred transactionVersion\n  protected getPreferredVersion(type12: ETransactionVersion, type3: ETransactionVersion) {\n    if (this.transactionVersion === ETransactionVersion.V3) return type3;\n    if (this.transactionVersion === ETransactionVersion.V2) return type12;\n\n    return ETransactionVersion.V3;\n  }\n\n  public async getNonce(blockIdentifier?: BlockIdentifier): Promise<Nonce> {\n    return super.getNonceForAddress(this.address, blockIdentifier);\n  }\n\n  protected async getNonceSafe(nonce?: BigNumberish) {\n    // Patch DEPLOY_ACCOUNT: RPC getNonce for non-existing address will result in error\n    try {\n      return toBigInt(nonce ?? (await this.getNonce()));\n    } catch (error) {\n      return 0n;\n    }\n  }\n\n  /**\n   * Retrieves the Cairo version from the network and sets `cairoVersion` if not already set in the constructor.\n   * @param classHash if provided detects Cairo version from classHash, otherwise from the account address\n   */\n  public async getCairoVersion(classHash?: string) {\n    if (!this.cairoVersion) {\n      const { cairo } = classHash\n        ? await super.getContractVersion(undefined, classHash)\n        : await super.getContractVersion(this.address);\n      this.cairoVersion = cairo;\n    }\n    return this.cairoVersion;\n  }\n\n  public async estimateFee(\n    calls: AllowArray<Call>,\n    estimateFeeDetails: UniversalDetails = {}\n  ): Promise<EstimateFee> {\n    return this.estimateInvokeFee(calls, estimateFeeDetails);\n  }\n\n  public async estimateInvokeFee(\n    calls: AllowArray<Call>,\n    details: UniversalDetails = {}\n  ): Promise<EstimateFee> {\n    const {\n      nonce: providedNonce,\n      blockIdentifier,\n      version: providedVersion,\n      skipValidate = true,\n    } = details;\n\n    const transactions = Array.isArray(calls) ? calls : [calls];\n    const nonce = toBigInt(providedNonce ?? (await this.getNonce()));\n    const version = toTransactionVersion(\n      this.getPreferredVersion(ETransactionVersion.F1, ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    );\n    const chainId = await this.getChainId();\n\n    const signerDetails: InvocationsSignerDetails = {\n      ...v3Details(details),\n      walletAddress: this.address,\n      nonce,\n      maxFee: ZERO,\n      version,\n      chainId,\n      cairoVersion: await this.getCairoVersion(),\n      skipValidate,\n    };\n\n    const invocation = await this.buildInvocation(transactions, signerDetails);\n    return super.getInvokeEstimateFee(\n      { ...invocation },\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n\n  public async estimateDeclareFee(\n    payload: DeclareContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<EstimateFee> {\n    const {\n      blockIdentifier,\n      nonce: providedNonce,\n      version: providedVersion,\n      skipValidate = true,\n    } = details;\n    const nonce = toBigInt(providedNonce ?? (await this.getNonce()));\n    const version = toTransactionVersion(\n      !isSierra(payload.contract)\n        ? ETransactionVersion.F1\n        : this.getPreferredVersion(ETransactionVersion.F2, ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    );\n    const chainId = await this.getChainId();\n\n    const declareContractTransaction = await this.buildDeclarePayload(payload, {\n      ...v3Details(details),\n      nonce,\n      chainId,\n      version,\n      walletAddress: this.address,\n      maxFee: ZERO,\n      cairoVersion: undefined, // unused parameter\n      skipValidate,\n    });\n\n    return super.getDeclareEstimateFee(\n      declareContractTransaction,\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n\n  public async estimateAccountDeployFee(\n    {\n      classHash,\n      addressSalt = 0,\n      constructorCalldata = [],\n      contractAddress,\n    }: DeployAccountContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<EstimateFee> {\n    const { blockIdentifier, version: providedVersion, skipValidate = true } = details;\n    const version = toTransactionVersion(\n      this.getPreferredVersion(ETransactionVersion.F1, ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    ); // TODO: Can Cairo0 be deployed with F3 ?\n    const nonce = ZERO; // DEPLOY_ACCOUNT transaction will have a nonce zero as it is the first transaction in the account\n    const chainId = await this.getChainId();\n\n    const payload = await this.buildAccountDeployPayload(\n      { classHash, addressSalt, constructorCalldata, contractAddress },\n      {\n        ...v3Details(details),\n        nonce,\n        chainId,\n        version,\n        walletAddress: this.address, // unused parameter\n        maxFee: ZERO,\n        cairoVersion: undefined, // unused parameter,\n        skipValidate,\n      }\n    );\n\n    return super.getDeployAccountEstimateFee(\n      { ...payload },\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n\n  public async estimateDeployFee(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details: UniversalDetails = {}\n  ): Promise<EstimateFee> {\n    const calls = this.buildUDCContractPayload(payload);\n    return this.estimateInvokeFee(calls, details);\n  }\n\n  public async estimateFeeBulk(\n    invocations: Invocations,\n    details: UniversalDetails = {}\n  ): Promise<EstimateFeeBulk> {\n    if (!invocations.length) throw TypeError('Invocations should be non-empty array');\n    const { nonce, blockIdentifier, version, skipValidate } = details;\n    const accountInvocations = await this.accountInvocationsFactory(invocations, {\n      ...v3Details(details),\n      versions: [\n        ETransactionVersion.F1, // non-sierra\n        toTransactionVersion(\n          this.getPreferredVersion(ETransactionVersion.F2, ETransactionVersion.F3),\n          version\n        ), // sierra\n      ],\n      nonce,\n      blockIdentifier,\n      skipValidate,\n    });\n\n    return super.getEstimateFeeBulk(accountInvocations, {\n      blockIdentifier,\n      skipValidate,\n    });\n  }\n\n  public async simulateTransaction(\n    invocations: Invocations,\n    details: SimulateTransactionDetails = {}\n  ): Promise<SimulateTransactionResponse> {\n    if (!invocations.length) throw TypeError('Invocations should be non-empty array');\n    const { nonce, blockIdentifier, skipValidate = true, skipExecute, version } = details;\n    const accountInvocations = await this.accountInvocationsFactory(invocations, {\n      ...v3Details(details),\n      versions: [\n        ETransactionVersion.V1, // non-sierra\n        toTransactionVersion(\n          this.getPreferredVersion(ETransactionVersion.V2, ETransactionVersion.V3),\n          version\n        ),\n      ],\n      nonce,\n      blockIdentifier,\n      skipValidate,\n    });\n\n    return super.getSimulateTransaction(accountInvocations, {\n      blockIdentifier,\n      skipValidate,\n      skipExecute,\n    });\n  }\n\n  public async execute(\n    transactions: AllowArray<Call>,\n    transactionsDetail?: UniversalDetails\n  ): Promise<InvokeFunctionResponse>;\n  public async execute(\n    transactions: AllowArray<Call>,\n    abis?: Abi[],\n    transactionsDetail?: UniversalDetails\n  ): Promise<InvokeFunctionResponse>;\n  public async execute(\n    transactions: AllowArray<Call>,\n    arg2?: Abi[] | UniversalDetails,\n    transactionsDetail: UniversalDetails = {}\n  ): Promise<InvokeFunctionResponse> {\n    const details = arg2 === undefined || Array.isArray(arg2) ? transactionsDetail : arg2;\n    const calls = Array.isArray(transactions) ? transactions : [transactions];\n    const nonce = toBigInt(details.nonce ?? (await this.getNonce()));\n    const version = toTransactionVersion(\n      this.getPreferredVersion(ETransactionVersion.V1, ETransactionVersion.V3), // TODO: does this depend on cairo version ?\n      details.version\n    );\n\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      { type: TransactionType.INVOKE, payload: transactions },\n      {\n        ...details,\n        version,\n      }\n    );\n\n    const chainId = await this.getChainId();\n\n    const signerDetails: InvocationsSignerDetails = {\n      ...v3Details(details),\n      resourceBounds: estimate.resourceBounds,\n      walletAddress: this.address,\n      nonce,\n      maxFee: estimate.maxFee,\n      version,\n      chainId,\n      cairoVersion: await this.getCairoVersion(),\n    };\n\n    const signature = await this.signer.signTransaction(calls, signerDetails);\n\n    const calldata = getExecuteCalldata(calls, await this.getCairoVersion());\n\n    return this.invokeFunction(\n      { contractAddress: this.address, calldata, signature },\n      {\n        ...v3Details(details),\n        resourceBounds: estimate.resourceBounds,\n        nonce,\n        maxFee: estimate.maxFee,\n        version,\n      }\n    );\n  }\n\n  /**\n   * First check if contract is already declared, if not declare it\n   * If contract already declared returned transaction_hash is ''.\n   * Method will pass even if contract is already declared\n   * @param transactionsDetail (optional)\n   */\n  public async declareIfNot(\n    payload: DeclareContractPayload,\n    transactionsDetail: UniversalDetails = {}\n  ): Promise<DeclareContractResponse> {\n    const declareContractPayload = extractContractHashes(payload);\n    try {\n      await this.getClassByHash(declareContractPayload.classHash);\n    } catch (error) {\n      return this.declare(payload, transactionsDetail);\n    }\n    return {\n      transaction_hash: '',\n      class_hash: declareContractPayload.classHash,\n    };\n  }\n\n  public async declare(\n    payload: DeclareContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<DeclareContractResponse> {\n    const declareContractPayload = extractContractHashes(payload);\n    const { nonce, version: providedVersion } = details;\n    const version = toTransactionVersion(\n      !isSierra(payload.contract)\n        ? ETransactionVersion.V1\n        : this.getPreferredVersion(ETransactionVersion.V2, ETransactionVersion.V3),\n      providedVersion\n    );\n\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      {\n        type: TransactionType.DECLARE,\n        payload: declareContractPayload,\n      },\n      {\n        ...details,\n        version,\n      }\n    );\n\n    const declareDetails: InvocationsSignerDetails = {\n      ...v3Details(details),\n      resourceBounds: estimate.resourceBounds,\n      maxFee: estimate.maxFee,\n      nonce: toBigInt(nonce ?? (await this.getNonce())),\n      version,\n      chainId: await this.getChainId(),\n      walletAddress: this.address,\n      cairoVersion: undefined,\n    };\n\n    const declareContractTransaction = await this.buildDeclarePayload(\n      declareContractPayload,\n      declareDetails\n    );\n\n    return this.declareContract(declareContractTransaction, declareDetails);\n  }\n\n  public async deploy(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details: UniversalDetails = {}\n  ): Promise<MultiDeployContractResponse> {\n    const { calls, addresses } = buildUDCCall(payload, this.address);\n    const invokeResponse = await this.execute(calls, undefined, details);\n\n    return {\n      ...invokeResponse,\n      contract_address: addresses,\n    };\n  }\n\n  public async deployContract(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details: UniversalDetails = {}\n  ): Promise<DeployContractUDCResponse> {\n    const deployTx = await this.deploy(payload, details);\n    const txReceipt = await this.waitForTransaction(deployTx.transaction_hash);\n    return parseUDCEvent(txReceipt as unknown as DeployTransactionReceiptResponse);\n  }\n\n  public async declareAndDeploy(\n    payload: DeclareAndDeployContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<DeclareDeployUDCResponse> {\n    const { constructorCalldata, salt, unique } = payload;\n    let declare = await this.declareIfNot(payload, details);\n    if (declare.transaction_hash !== '') {\n      const tx = await this.waitForTransaction(declare.transaction_hash);\n      declare = { ...declare, ...tx };\n    }\n    const deploy = await this.deployContract(\n      { classHash: declare.class_hash, salt, unique, constructorCalldata },\n      details\n    );\n    return { declare: { ...declare }, deploy };\n  }\n\n  public deploySelf = this.deployAccount;\n\n  public async deployAccount(\n    {\n      classHash,\n      constructorCalldata = [],\n      addressSalt = 0,\n      contractAddress: providedContractAddress,\n    }: DeployAccountContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<DeployContractResponse> {\n    const version = toTransactionVersion(\n      this.getPreferredVersion(ETransactionVersion.V1, ETransactionVersion.V3),\n      details.version\n    );\n    const nonce = ZERO; // DEPLOY_ACCOUNT transaction will have a nonce zero as it is the first transaction in the account\n    const chainId = await this.getChainId();\n\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const contractAddress =\n      providedContractAddress ??\n      calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      {\n        type: TransactionType.DEPLOY_ACCOUNT,\n        payload: {\n          classHash,\n          constructorCalldata: compiledCalldata,\n          addressSalt,\n          contractAddress,\n        },\n      },\n      details\n    );\n\n    const signature = await this.signer.signDeployAccountTransaction({\n      ...v3Details(details),\n      classHash,\n      constructorCalldata: compiledCalldata,\n      contractAddress,\n      addressSalt,\n      chainId,\n      resourceBounds: estimate.resourceBounds,\n      maxFee: estimate.maxFee,\n      version,\n      nonce,\n    });\n\n    return this.deployAccountContract(\n      { classHash, addressSalt, constructorCalldata, signature },\n      {\n        ...v3Details(details),\n        nonce,\n        resourceBounds: estimate.resourceBounds,\n        maxFee: estimate.maxFee,\n        version,\n      }\n    );\n  }\n\n  public async signMessage(typedData: TypedData): Promise<Signature> {\n    return this.signer.signMessage(typedData, this.address);\n  }\n\n  public async hashMessage(typedData: TypedData): Promise<string> {\n    return getMessageHash(typedData, this.address);\n  }\n\n  /**\n   * @deprecated To replace by `myRpcProvider.verifyMessageInStarknet()`\n   */\n  public async verifyMessageHash(\n    hash: BigNumberish,\n    signature: Signature,\n    signatureVerificationFunctionName?: string,\n    signatureVerificationResponse?: { okResponse: string[]; nokResponse: string[]; error: string[] }\n  ): Promise<boolean> {\n    return this.verifyMessageInStarknet(\n      hash,\n      signature,\n      this.address,\n      signatureVerificationFunctionName,\n      signatureVerificationResponse\n    );\n  }\n\n  /**\n   * @deprecated To replace by `myRpcProvider.verifyMessageInStarknet()`\n   */\n  public async verifyMessage(\n    typedData: TypedData,\n    signature: Signature,\n    signatureVerificationFunctionName?: string,\n    signatureVerificationResponse?: { okResponse: string[]; nokResponse: string[]; error: string[] }\n  ): Promise<boolean> {\n    return this.verifyMessageInStarknet(\n      typedData,\n      signature,\n      this.address,\n      signatureVerificationFunctionName,\n      signatureVerificationResponse\n    );\n  }\n\n  /**\n   * Verify if an account is compatible with SNIP-9 outside execution, and with which version of this standard.\n   * @returns {OutsideExecutionVersion} Not compatible, V1, V2.\n   * @example\n   * ```typescript\n   * const result = myAccount.getSnip9Version();\n   * // result = \"V1\"\n   * ```\n   */\n  public async getSnip9Version(): Promise<OutsideExecutionVersion> {\n    if (await supportsInterface(this, this.address, SNIP9_V2_INTERFACE_ID)) {\n      return OutsideExecutionVersion.V2;\n    }\n    if (await supportsInterface(this, this.address, SNIP9_V1_INTERFACE_ID)) {\n      return OutsideExecutionVersion.V1;\n    }\n    // Account does not support either version 2 or version 1\n    return OutsideExecutionVersion.UNSUPPORTED;\n  }\n\n  /**\n   * Verify if a SNIP-9 nonce has not yet been used by the account.\n   * @param {BigNumberish} nonce SNIP-9 nonce to test.\n   * @returns  {boolean} true if SNIP-9 nonce not yet used.\n   * @example\n   * ```typescript\n   * const result = myAccount.isValidSnip9Nonce(1234);\n   * // result = true\n   * ```\n   */\n  public async isValidSnip9Nonce(nonce: BigNumberish): Promise<boolean> {\n    try {\n      const call: Call = {\n        contractAddress: this.address,\n        entrypoint: 'is_valid_outside_execution_nonce',\n        calldata: [toHex(nonce)],\n      };\n      const resp = await this.callContract(call);\n      return BigInt(resp[0]) !== 0n;\n    } catch (error) {\n      throw new Error(`Failed to check if nonce is valid: ${error}`);\n    }\n  }\n\n  /**\n   * Outside transaction needs a specific SNIP-9 nonce, that we get in this function.\n   * A SNIP-9 nonce can be any number not yet used ; no ordering is needed.\n   * @returns  {string} an Hex string of a SNIP-9 nonce.\n   * @example\n   * ```typescript\n   * const result = myAccount.getSnip9Nonce();\n   * // result = \"0x28a612590dbc36927933c8ee0f357eee639c8b22b3d3aa86949eed3ada4ac55\"\n   * ```\n   */\n  public async getSnip9Nonce(): Promise<string> {\n    const nonce = randomAddress();\n    const isValidNonce = await this.isValidSnip9Nonce(nonce);\n    if (!isValidNonce) {\n      return this.getSnip9Nonce();\n    }\n    return nonce;\n  }\n\n  /**\n   * Creates an object containing transaction(s) that can be executed by an other account with` Account.executeFromOutside()`, called Outside Transaction.\n   * @param {OutsideExecutionOptions} options Parameters of the transaction(s).\n   * @param {AllowArray<Call>} calls Transaction(s) to execute.\n   * @param {OutsideExecutionVersion} [version] SNIP-9 version of the Account that creates the outside transaction.\n   * @param {BigNumberish} [nonce] Outside Nonce.\n   * @returns {OutsideTransaction} and object that can be used in `Account.executeFromOutside()`\n   * @example\n   * ```typescript\n   * const now_seconds = Math.floor(Date.now() / 1000);\n   * const callOptions: OutsideExecutionOptions = {\n      caller: executorAccount.address, execute_after: now_seconds - 3600, execute_before: now_seconds + 3600 };\n   * const call1: Call = { contractAddress: ethAddress, entrypoint: 'transfer', calldata: {\n   *     recipient: recipientAccount.address, amount: cairo.uint256(100) } };\n   * const outsideTransaction1: OutsideTransaction = await signerAccount.getOutsideTransaction(callOptions, call3);\n   * // result = {\n   * // outsideExecution: {\n   * // caller: '0x64b48806902a367c8598f4f95c305e8c1a1acba5f082d294a43793113115691',\n   * // nonce: '0x28a612590dbc36927933c8ee0f357eee639c8b22b3d3aa86949eed3ada4ac55',\n   * // execute_after: 1723650229, execute_before: 1723704229, calls: [[Object]] },\n   * // signature: Signature {\n   * // r: 67518627037915514985321278857825384106482999609634873287406612756843916814n,\n   * // s: 737198738569840639192844101690009498983611654458636624293579534560862067709n, recovery: 0 },\n   * // signerAddress: '0x655f8fd7c4013c07cf12a92184aa6c314d181443913e21f7e209a18f0c78492',\n   * // version: '2'\n   * // }\n   * ```\n   */\n  public async getOutsideTransaction(\n    options: OutsideExecutionOptions,\n    calls: AllowArray<Call>,\n    version?: OutsideExecutionVersion,\n    nonce?: BigNumberish\n  ): Promise<OutsideTransaction> {\n    if (!isHex(options.caller) && options.caller !== 'ANY_CALLER') {\n      throw new Error(`The caller ${options.caller} is not valid.`);\n    }\n    const codedCaller: string = isHex(options.caller) ? options.caller : OutsideExecutionCallerAny;\n    const myCalls: Call[] = Array.isArray(calls) ? calls : [calls];\n    const supportedVersion = version ?? (await this.getSnip9Version());\n    if (!supportedVersion) {\n      throw new Error('This account is not handling outside transactions.');\n    }\n    const myNonce = nonce ? toHex(nonce) : await this.getSnip9Nonce();\n    const message = getTypedData(\n      await this.getChainId(),\n      {\n        caller: codedCaller,\n        execute_after: options.execute_after,\n        execute_before: options.execute_before,\n      },\n      myNonce,\n      myCalls,\n      supportedVersion\n    );\n    const sign: Signature = await this.signMessage(message);\n    const toExecute: OutsideExecution = {\n      caller: codedCaller,\n      nonce: myNonce,\n      execute_after: options.execute_after,\n      execute_before: options.execute_before,\n      calls: myCalls.map(getOutsideCall),\n    };\n    return {\n      outsideExecution: toExecute,\n      signature: sign,\n      signerAddress: this.address,\n      version: supportedVersion,\n    };\n  }\n\n  /**\n   * An account B executes a transaction that has been signed by an account A.\n   * Fees are paid by B.\n   * @param {AllowArray<OutsideTransaction>} outsideTransaction the signed transaction generated by `Account.getOutsideTransaction()`.\n   * @param {UniversalDetails} [opts] same options than `Account.execute()`.\n   * @returns {InvokeFunctionResponse} same response than `Account.execute()`.\n   * @example\n   * ```typescript\n   * const outsideTransaction1: OutsideTransaction = await signerAccount.getOutsideTransaction(callOptions, call1);\n   * const outsideTransaction2: OutsideTransaction = await signerAccount.getOutsideTransaction(callOptions4, call4);\n   * const result = await myAccount.executeFromOutside([\n      outsideTransaction1,\n      outsideTransaction2,\n    ]);\n   * // result = { transaction_hash: '0x11233...`}\n   * ```\n   */\n  public async executeFromOutside(\n    outsideTransaction: AllowArray<OutsideTransaction>,\n    opts?: UniversalDetails\n  ): Promise<InvokeFunctionResponse> {\n    const multiCall = buildExecuteFromOutsideCall(outsideTransaction);\n    return this.execute(multiCall, opts);\n  }\n\n  /*\n   * Support methods\n   */\n\n  protected async getUniversalSuggestedFee(\n    version: ETransactionVersion,\n    { type, payload }: EstimateFeeAction,\n    details: UniversalDetails\n  ): Promise<UniversalSuggestedFee> {\n    let maxFee: BigNumberish = 0;\n    let resourceBounds: ResourceBounds = estimateFeeToBounds(ZERO);\n\n    if (version === ETransactionVersion.V3) {\n      resourceBounds =\n        details.resourceBounds ??\n        (await this.getSuggestedFee({ type, payload } as any, details)).resourceBounds;\n    } else {\n      maxFee =\n        details.maxFee ??\n        (await this.getSuggestedFee({ type, payload } as any, details)).suggestedMaxFee;\n    }\n\n    return {\n      maxFee,\n      resourceBounds,\n    };\n  }\n\n  public async getSuggestedFee(\n    { type, payload }: EstimateFeeAction,\n    details: UniversalDetails\n  ): Promise<EstimateFee> {\n    switch (type) {\n      case TransactionType.INVOKE:\n        return this.estimateInvokeFee(payload, details);\n\n      case TransactionType.DECLARE:\n        return this.estimateDeclareFee(payload, details);\n\n      case TransactionType.DEPLOY_ACCOUNT:\n        return this.estimateAccountDeployFee(payload, details);\n\n      case TransactionType.DEPLOY:\n        return this.estimateDeployFee(payload, details);\n\n      default:\n        return {\n          gas_consumed: 0n,\n          gas_price: 0n,\n          overall_fee: ZERO,\n          unit: 'FRI',\n          suggestedMaxFee: ZERO,\n          resourceBounds: estimateFeeToBounds(ZERO),\n          data_gas_consumed: 0n,\n          data_gas_price: 0n,\n        };\n    }\n  }\n\n  public async buildInvocation(\n    call: Array<Call>,\n    details: InvocationsSignerDetails\n  ): Promise<Invocation> {\n    const calldata = getExecuteCalldata(call, await this.getCairoVersion());\n    const signature = !details.skipValidate ? await this.signer.signTransaction(call, details) : [];\n\n    return {\n      ...v3Details(details),\n      contractAddress: this.address,\n      calldata,\n      signature,\n    };\n  }\n\n  public async buildDeclarePayload(\n    payload: DeclareContractPayload,\n    details: InvocationsSignerDetails\n  ): Promise<DeclareContractTransaction> {\n    const { classHash, contract, compiledClassHash } = extractContractHashes(payload);\n    const compressedCompiledContract = parseContract(contract);\n\n    if (\n      isUndefined(compiledClassHash) &&\n      (details.version === ETransactionVersion3.F3 || details.version === ETransactionVersion3.V3)\n    ) {\n      throw Error('V3 Transaction work with Cairo1 Contracts and require compiledClassHash');\n    }\n\n    const signature = !details.skipValidate\n      ? await this.signer.signDeclareTransaction({\n          ...details,\n          ...v3Details(details),\n          classHash,\n          compiledClassHash: compiledClassHash as string, // TODO: TS, cast because optional for v2 and required for v3, thrown if not present\n          senderAddress: details.walletAddress,\n        })\n      : [];\n\n    return {\n      senderAddress: details.walletAddress,\n      signature,\n      contract: compressedCompiledContract,\n      compiledClassHash,\n    };\n  }\n\n  public async buildAccountDeployPayload(\n    {\n      classHash,\n      addressSalt = 0,\n      constructorCalldata = [],\n      contractAddress: providedContractAddress,\n    }: DeployAccountContractPayload,\n    details: InvocationsSignerDetails\n  ): Promise<DeployAccountContractTransaction> {\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const contractAddress =\n      providedContractAddress ??\n      calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n\n    const signature = !details.skipValidate\n      ? await this.signer.signDeployAccountTransaction({\n          ...details,\n          ...v3Details(details),\n          classHash,\n          contractAddress,\n          addressSalt,\n          constructorCalldata: compiledCalldata,\n        })\n      : [];\n\n    return {\n      ...v3Details(details),\n      classHash,\n      addressSalt,\n      constructorCalldata: compiledCalldata,\n      signature,\n    };\n  }\n\n  public buildUDCContractPayload(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[]\n  ): Call[] {\n    const calls = [].concat(payload as []).map((it) => {\n      const {\n        classHash,\n        salt = '0',\n        unique = true,\n        constructorCalldata = [],\n      } = it as UniversalDeployerContractPayload;\n      const compiledConstructorCallData = CallData.compile(constructorCalldata);\n\n      return {\n        contractAddress: UDC.ADDRESS,\n        entrypoint: UDC.ENTRYPOINT,\n        calldata: [\n          classHash,\n          salt,\n          toCairoBool(unique),\n          compiledConstructorCallData.length,\n          ...compiledConstructorCallData,\n        ],\n      };\n    });\n    return calls;\n  }\n\n  public async accountInvocationsFactory(\n    invocations: Invocations,\n    details: AccountInvocationsFactoryDetails\n  ) {\n    const { nonce, blockIdentifier, skipValidate = true } = details;\n    const safeNonce = await this.getNonceSafe(nonce);\n    const chainId = await this.getChainId();\n    const versions = details.versions.map((it) => toTransactionVersion(it));\n\n    // BULK ACTION FROM NEW ACCOUNT START WITH DEPLOY_ACCOUNT\n    const tx0Payload: any = 'payload' in invocations[0] ? invocations[0].payload : invocations[0];\n    const cairoVersion =\n      invocations[0].type === TransactionType.DEPLOY_ACCOUNT\n        ? await this.getCairoVersion(tx0Payload.classHash)\n        : await this.getCairoVersion();\n\n    return Promise.all(\n      ([] as Invocations).concat(invocations).map(async (transaction, index: number) => {\n        const txPayload: any = 'payload' in transaction ? transaction.payload : transaction;\n        const signerDetails = {\n          ...v3Details(details),\n          walletAddress: this.address,\n          nonce: toBigInt(Number(safeNonce) + index),\n          maxFee: ZERO,\n          chainId,\n          cairoVersion,\n          version: '' as ETransactionVersion,\n          skipValidate,\n        };\n        const common = {\n          type: transaction.type,\n          nonce: toBigInt(Number(safeNonce) + index),\n          blockIdentifier,\n          version: '' as ETransactionVersion,\n        };\n\n        if (transaction.type === TransactionType.INVOKE) {\n          // 1 or 3\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n\n          const payload = await this.buildInvocation(\n            ([] as Call[]).concat(txPayload),\n            signerDetails\n          );\n          return {\n            ...common,\n            ...payload,\n            ...signerDetails,\n          };\n        }\n        if (transaction.type === TransactionType.DEPLOY) {\n          // 1 or 3\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n\n          const calls = this.buildUDCContractPayload(txPayload);\n          const payload = await this.buildInvocation(calls, signerDetails);\n          return {\n            ...common,\n            ...payload,\n            ...signerDetails,\n            type: TransactionType.INVOKE,\n          };\n        }\n        if (transaction.type === TransactionType.DECLARE) {\n          // 1 (Cairo0) or 2 or 3\n          const versionX = !isSierra(txPayload.contract) ? versions[0] : versions[1];\n          signerDetails.version = versionX;\n          common.version = versionX;\n\n          const payload = await this.buildDeclarePayload(txPayload, signerDetails);\n          return {\n            ...common,\n            ...payload,\n            ...signerDetails,\n          };\n        }\n        if (transaction.type === TransactionType.DEPLOY_ACCOUNT) {\n          // 1 or 3\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n\n          const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);\n          return {\n            ...common,\n            ...payload,\n            ...signerDetails,\n          };\n        }\n        throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction}`);\n      })\n    ) as Promise<AccountInvocations>;\n  }\n\n  public async getStarkName(\n    address: BigNumberish = this.address, // default to the wallet address\n    StarknetIdContract?: string\n  ): Promise<string> {\n    return super.getStarkName(address, StarknetIdContract);\n  }\n}\n","import { ProviderInterface } from '../provider';\nimport { SignerInterface } from '../signer';\nimport {\n  Abi,\n  AllowArray,\n  BlockIdentifier,\n  CairoVersion,\n  Call,\n  DeclareAndDeployContractPayload,\n  DeclareContractPayload,\n  DeclareContractResponse,\n  DeclareDeployUDCResponse,\n  DeployAccountContractPayload,\n  DeployContractResponse,\n  DeployContractUDCResponse,\n  EstimateFee,\n  EstimateFeeAction,\n  EstimateFeeDetails,\n  EstimateFeeResponse,\n  EstimateFeeResponseBulk,\n  Invocations,\n  InvocationsDetails,\n  InvokeFunctionResponse,\n  MultiDeployContractResponse,\n  Nonce,\n  Signature,\n  SimulateTransactionDetails,\n  SimulateTransactionResponse,\n  TypedData,\n  UniversalDeployerContractPayload,\n} from '../types';\n\nexport abstract class AccountInterface extends ProviderInterface {\n  public abstract address: string;\n\n  public abstract signer: SignerInterface;\n\n  public abstract cairoVersion: CairoVersion;\n\n  /**\n   * Estimate Fee for executing an INVOKE transaction on starknet\n   *\n   * @param calls the invocation object containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata? - (defaults to []) the calldata\n   *\n   * @param estimateFeeDetails -\n   * - blockIdentifier?\n   * - nonce? = 0\n   * - skipValidate? - default true\n   * - tip? - prioritize order of transactions in the mempool.\n   * - accountDeploymentData? - deploy an account contract (substitution for deploy account transaction)\n   * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)\n   * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei\n   *\n   * @returns response from estimate_fee\n   */\n  public abstract estimateInvokeFee(\n    calls: AllowArray<Call>,\n    estimateFeeDetails?: EstimateFeeDetails\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimate Fee for executing a DECLARE transaction on starknet\n   *\n   * @param contractPayload the payload object containing:\n   * - contract - the compiled contract to be declared\n   * - casm? - compiled cairo assembly. Cairo1(casm or compiledClassHash are required)\n   * - classHash? - the class hash of the compiled contract. Precalculate for faster execution.\n   * - compiledClassHash?: class hash of the cairo assembly. Cairo1(casm or compiledClassHash are required)\n   *\n   * @param estimateFeeDetails -\n   * - blockIdentifier?\n   * - nonce? = 0\n   * - skipValidate? - default true\n   * - tip? - prioritize order of transactions in the mempool.\n   * - accountDeploymentData? - deploy an account contract (substitution for deploy account transaction)\n   * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)\n   * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei\n   *\n   * @returns response from estimate_fee\n   */\n  public abstract estimateDeclareFee(\n    contractPayload: DeclareContractPayload,\n    estimateFeeDetails?: EstimateFeeDetails\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimate Fee for executing a DEPLOY_ACCOUNT transaction on starknet\n   *\n   * @param contractPayload -\n   * - classHash - the class hash of the compiled contract.\n   * - constructorCalldata? - constructor data;\n   * - contractAddress? - future account contract address. Precalculate for faster execution.\n   * - addressSalt? - salt used for calculation of the contractAddress. Required if contractAddress is provided.\n   *\n   * @param estimateFeeDetails -\n   * - blockIdentifier?\n   * - nonce? = 0\n   * - skipValidate? - default true\n   * - tip? - prioritize order of transactions in the mempool.\n   * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)\n   * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei\n   *\n   * @returns response from estimate_fee\n   */\n  public abstract estimateAccountDeployFee(\n    contractPayload: DeployAccountContractPayload,\n    estimateFeeDetails?: EstimateFeeDetails\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimate Fee for executing a UDC DEPLOY transaction on starknet\n   * This is different from the normal DEPLOY transaction as it goes through the Universal Deployer Contract (UDC)\n\n  * @param deployContractPayload array or singular\n   * - classHash: computed class hash of compiled contract\n   * - salt: address salt\n   * - unique: bool if true ensure unique salt\n   * - constructorCalldata: constructor calldata\n   *\n   * @param estimateFeeDetails -\n   * - blockIdentifier?\n   * - nonce?\n   * - skipValidate? - default true\n   * - tip? - prioritize order of transactions in the mempool.\n   * - accountDeploymentData? - deploy an account contract (substitution for deploy account transaction)\n   * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)\n   * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei\n   */\n  public abstract estimateDeployFee(\n    deployContractPayload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    estimateFeeDetails?: EstimateFeeDetails\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimate Fee for executing a list of transactions on starknet\n   * Contract must be deployed for fee estimation to be possible\n   *\n   * @param invocations array of transaction object containing :\n   * - type - the type of transaction : 'DECLARE' | (multi)'DEPLOY' | (multi)'INVOKE_FUNCTION' | 'DEPLOY_ACCOUNT'\n   * - payload - the payload of the transaction\n   *\n   *  @param details -\n   * - blockIdentifier?\n   * - nonce?\n   * - skipValidate? - default true\n   * - tip? - prioritize order of transactions in the mempool.\n   * - accountDeploymentData? - deploy an account contract (substitution for deploy account transaction)\n   * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)\n   * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei\n   *\n   * @returns response from estimate_fee\n   */\n  public abstract estimateFeeBulk(\n    invocations: Invocations,\n    details?: EstimateFeeDetails\n  ): Promise<EstimateFeeResponseBulk>;\n\n  /**\n   * Gets Suggested Max Fee based on the transaction type\n   *\n   * @param  {EstimateFeeAction} estimateFeeAction\n   * @param  {EstimateFeeDetails} details\n   * @returns EstimateFee (...response, resourceBounds, suggestedMaxFee)\n   */\n  public abstract getSuggestedFee(\n    estimateFeeAction: EstimateFeeAction,\n    details: EstimateFeeDetails\n  ): Promise<EstimateFee>;\n\n  /**\n   * Simulates an array of transaction and returns an array of transaction trace and estimated fee.\n   *\n   * @param invocations Invocations containing:\n   * - type - transaction type: DECLARE, (multi)DEPLOY, DEPLOY_ACCOUNT, (multi)INVOKE_FUNCTION\n   * @param details SimulateTransactionDetails\n   *\n   * @returns response from simulate_transaction\n   */\n  public abstract simulateTransaction(\n    invocations: Invocations,\n    details?: SimulateTransactionDetails\n  ): Promise<SimulateTransactionResponse>;\n\n  /**\n   * Invoke execute function in account contract\n   *\n   * @param transactions the invocation object or an array of them, containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata - (defaults to []) the calldata\n   * - signature - (defaults to []) the signature\n   * @param {InvocationsDetails} transactionsDetail Additional optional parameters for the transaction\n   *\n   * @returns response from addTransaction\n   */\n  public abstract execute(\n    transactions: AllowArray<Call>,\n    transactionsDetail?: InvocationsDetails\n  ): Promise<InvokeFunctionResponse>;\n  /**\n   * @deprecated\n   * @param transactions the invocation object or an array of them, containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata - (defaults to []) the calldata\n   * - signature - (defaults to []) the signature\n   * @param abis (optional) the abi of the contract for better displaying\n   * @param {InvocationsDetails} transactionsDetail Additional optional parameters for the transaction\n   * * @returns response from addTransaction\n   */\n  public abstract execute(\n    transactions: AllowArray<Call>,\n    abis?: Abi[],\n    transactionsDetail?: InvocationsDetails\n  ): Promise<InvokeFunctionResponse>;\n\n  /**\n   * Declares a given compiled contract (json) to starknet\n   *\n   * @param contractPayload transaction payload to be deployed containing:\n   * - contract: compiled contract code\n   * - (optional) classHash: computed class hash of compiled contract. Pre-compute it for faster execution.\n   * - (required for Cairo1 without compiledClassHash) casm: CompiledContract | string;\n   * - (optional for Cairo1 with casm) compiledClassHash: compiled class hash from casm. Pre-compute it for faster execution.\n   * @param transactionsDetail - InvocationsDetails\n   *\n   * @returns a confirmation of sending a transaction on the starknet contract\n   */\n  public abstract declare(\n    contractPayload: DeclareContractPayload,\n    transactionsDetail?: InvocationsDetails\n  ): Promise<DeclareContractResponse>;\n\n  /**\n   * Deploys a declared contract to starknet - using Universal Deployer Contract (UDC)\n   * support multicall\n   *\n   * @param payload -\n   * - classHash: computed class hash of compiled contract\n   * - [constructorCalldata] contract constructor calldata\n   * - [salt=pseudorandom] deploy address salt\n   * - [unique=true] ensure unique salt\n   * @param details - InvocationsDetails\n   *\n   * @returns\n   * - contract_address[]\n   * - transaction_hash\n   */\n  public abstract deploy(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details?: InvocationsDetails\n  ): Promise<MultiDeployContractResponse>;\n\n  /**\n   * Simplify deploy simulating old DeployContract with same response + UDC specific response\n   * Internal wait for L2 transaction, support multicall\n   *\n   * @param payload -\n   * - classHash: computed class hash of compiled contract\n   * - [constructorCalldata] contract constructor calldata\n   * - [salt=pseudorandom] deploy address salt\n   * - [unique=true] ensure unique salt\n   * @param details - InvocationsDetails\n   *\n   * @returns\n   *  - contract_address\n   *  - transaction_hash\n   *  - address\n   *  - deployer\n   *  - unique\n   *  - classHash\n   *  - calldata_len\n   *  - calldata\n   *  - salt\n   */\n  public abstract deployContract(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details?: InvocationsDetails\n  ): Promise<DeployContractUDCResponse>;\n\n  /**\n   * Declares and Deploy a given compiled contract (json) to starknet using UDC\n   * Internal wait for L2 transaction, do not support multicall\n   * Method will pass even if contract is already declared (internal using DeclareIfNot)\n   *\n   * @param payload\n   * - contract: compiled contract code\n   * - [casm=cairo1]: CairoAssembly | undefined;\n   * - [compiledClassHash]: string | undefined;\n   * - [classHash]: computed class hash of compiled contract\n   * - [constructorCalldata] contract constructor calldata\n   * - [salt=pseudorandom] deploy address salt\n   * - [unique=true] ensure unique salt\n   * @param details - InvocationsDetails\n   *\n   * @returns\n   * - declare\n   *    - transaction_hash\n   * - deploy\n   *    - contract_address\n   *    - transaction_hash\n   *    - address\n   *    - deployer\n   *    - unique\n   *    - classHash\n   *    - calldata_len\n   *    - calldata\n   *    - salt\n   */\n  public abstract declareAndDeploy(\n    payload: DeclareAndDeployContractPayload,\n    details?: InvocationsDetails\n  ): Promise<DeclareDeployUDCResponse>;\n\n  /**\n   * Deploy the account on Starknet\n   *\n   * @param contractPayload transaction payload to be deployed containing:\n   * - classHash: computed class hash of compiled contract\n   * - optional constructor calldata\n   * - optional address salt\n   * - optional contractAddress\n   * @param transactionsDetail - InvocationsDetails\n   *\n   * @returns a confirmation of sending a transaction on the starknet contract\n   */\n  public abstract deployAccount(\n    contractPayload: DeployAccountContractPayload,\n    transactionsDetail?: InvocationsDetails\n  ): Promise<DeployContractResponse>;\n\n  /**\n   * Signs a TypedData object for off-chain usage with the Starknet private key and returns the signature\n   * This adds a message prefix so it can't be interchanged with transactions\n   *\n   * @param typedData - TypedData object to be signed\n   * @returns the signature of the TypedData object\n   * @throws {Error} if typedData is not a valid TypedData\n   */\n  public abstract signMessage(typedData: TypedData): Promise<Signature>;\n\n  /**\n   * Hash a TypedData object with Pedersen hash and return the hash\n   * This adds a message prefix so it can't be interchanged with transactions\n   *\n   * @param typedData - TypedData object to be hashed\n   * @returns the hash of the TypedData object\n   * @throws {Error} if typedData is not a valid TypedData\n   */\n  public abstract hashMessage(typedData: TypedData): Promise<string>;\n\n  /**\n   * Gets the nonce of the account with respect to a specific block\n   *\n   * @param  {BlockIdentifier} blockIdentifier - optional blockIdentifier. Defaults to 'pending'\n   * @returns nonce of the account\n   */\n  public abstract getNonce(blockIdentifier?: BlockIdentifier): Promise<Nonce>;\n}\n","import {\n  type WatchAssetParameters,\n  type AccountChangeEventHandler,\n  type AddDeclareTransactionParameters,\n  type AddInvokeTransactionParameters,\n  type AddStarknetChainParameters,\n  type NetworkChangeEventHandler,\n  type ChainId,\n  type StarknetWindowObject,\n  type TypedData,\n  type Permission,\n  type Address,\n  AddInvokeTransactionResult,\n  AddDeclareTransactionResult,\n  AccountDeploymentData,\n  Signature,\n  SpecVersion,\n} from 'starknet-types-07';\n\n/**\n * Request Permission for wallet account, return addresses that are allowed by user\n * @param {boolean} [silent_mode=false] false: request user interaction allowance. true: return only pre-allowed\n * @returns allowed accounts addresses\n */\nexport function requestAccounts(\n  swo: StarknetWindowObject,\n  silent_mode: boolean = false\n): Promise<Address[]> {\n  return swo.request({\n    type: 'wallet_requestAccounts',\n    params: { silent_mode },\n  });\n}\n\n/**\n * Request Permission for wallet account\n * @returns allowed accounts addresses\n */\nexport function getPermissions(swo: StarknetWindowObject): Promise<Permission[]> {\n  return swo.request({ type: 'wallet_getPermissions' });\n}\n\n/**\n * Request adding ERC20 Token to Wallet List\n * @param asset WatchAssetParameters\n * @returns boolean\n */\nexport function watchAsset(\n  swo: StarknetWindowObject,\n  asset: WatchAssetParameters\n): Promise<boolean> {\n  return swo.request({ type: 'wallet_watchAsset', params: asset });\n}\n\n/**\n * Request adding custom Starknet chain\n * @param chain AddStarknetChainParameters\n * @returns boolean\n */\nexport function addStarknetChain(\n  swo: StarknetWindowObject,\n  chain: AddStarknetChainParameters\n): Promise<boolean> {\n  // TODO: This should set custom RPC endpoint ?\n  return swo.request({ type: 'wallet_addStarknetChain', params: chain });\n}\n\n/**\n * Request Wallet Network change\n * @param chainId StarknetChainId\n * @returns boolean\n */\nexport function switchStarknetChain(swo: StarknetWindowObject, chainId: ChainId): Promise<boolean> {\n  return swo.request({\n    type: 'wallet_switchStarknetChain',\n    params: { chainId },\n  });\n}\n\n/**\n * Request the current chain ID from the wallet.\n * @returns The current Starknet chain ID.\n */\nexport function requestChainId(swo: StarknetWindowObject): Promise<ChainId> {\n  return swo.request({ type: 'wallet_requestChainId' });\n}\n\n/**\n * Get deployment data for a contract.\n * @returns The deployment data result.\n */\nexport function deploymentData(swo: StarknetWindowObject): Promise<AccountDeploymentData> {\n  return swo.request({ type: 'wallet_deploymentData' }); // TODO: test\n}\n\n/**\n * Add an invoke transaction to the wallet.\n * @param params The parameters required for the invoke transaction.\n * @returns The result of adding the invoke transaction.\n */\nexport function addInvokeTransaction(\n  swo: StarknetWindowObject,\n  params: AddInvokeTransactionParameters\n): Promise<AddInvokeTransactionResult> {\n  return swo.request({ type: 'wallet_addInvokeTransaction', params });\n}\n\n/**\n * Add a declare transaction to the wallet.\n * @param params The parameters required for the declare transaction.\n * @returns The result of adding the declare transaction.\n */\nexport function addDeclareTransaction(\n  swo: StarknetWindowObject,\n  params: AddDeclareTransactionParameters\n): Promise<AddDeclareTransactionResult> {\n  return swo.request({ type: 'wallet_addDeclareTransaction', params });\n}\n\n/**\n * Sign typed data using the wallet.\n * @param swo the starknet (wallet) window object to request the signature.\n * @param typedData The typed data to sign.\n * @returns An array of signatures as strings.\n */\nexport function signMessage(swo: StarknetWindowObject, typedData: TypedData): Promise<Signature> {\n  return swo.request({ type: 'wallet_signTypedData', params: typedData });\n}\n\n/**\n * Get the list of supported specifications.\n * @returns An array of supported specification strings.\n */\nexport function supportedSpecs(swo: StarknetWindowObject): Promise<SpecVersion[]> {\n  return swo.request({ type: 'wallet_supportedSpecs' });\n}\n\n/**\n * Attaches an event handler function to the \"accountsChanged\" event of a StarknetWindowObject.\n * When the accounts are changed, the specified callback function will be called.\n *\n * @param {StarknetWindowObject} swo - The StarknetWindowObject to attach the event handler to.\n * @param {AccountChangeEventHandler} callback - The function to be called when the accounts are changed.\n *                                              It will receive the changed accounts as a parameter.\n * @returns {void}\n */\nexport function onAccountChange(\n  swo: StarknetWindowObject,\n  callback: AccountChangeEventHandler\n): void {\n  swo.on('accountsChanged', callback);\n}\n\n/**\n * Register a callback function to be called when the network is changed.\n *\n * @param {StarknetWindowObject} swo - The StarknetWindowObject instance.\n * @param {NetworkChangeEventHandler} callback - The callback function to be called when the network is changed.\n * @return {void}\n */\nexport function onNetworkChanged(\n  swo: StarknetWindowObject,\n  callback: NetworkChangeEventHandler\n): void {\n  swo.on('networkChanged', callback);\n}\n","import type {\n  AccountChangeEventHandler,\n  AddStarknetChainParameters,\n  NetworkChangeEventHandler,\n  Signature,\n  WatchAssetParameters,\n} from 'starknet-types-07';\n\nimport { Account, AccountInterface } from '../account';\nimport { StarknetChainId } from '../global/constants';\nimport { ProviderInterface } from '../provider';\nimport {\n  AllowArray,\n  CairoVersion,\n  Call,\n  CompiledSierra,\n  DeclareContractPayload,\n  MultiDeployContractResponse,\n  ProviderOptions,\n  TypedData,\n  UniversalDeployerContractPayload,\n} from '../types';\nimport { extractContractHashes } from '../utils/contract';\nimport { stringify } from '../utils/json';\nimport { buildUDCCall } from '../utils/transaction';\nimport {\n  addDeclareTransaction,\n  addInvokeTransaction,\n  addStarknetChain,\n  getPermissions,\n  onAccountChange,\n  onNetworkChanged,\n  requestAccounts,\n  signMessage,\n  switchStarknetChain,\n  watchAsset,\n} from './connect';\nimport { StarknetWalletProvider } from './types';\nimport { logger } from '../global/logger';\n\n// TODO: Remove non address constructor in next major version\n// Represent 'Selected Active' Account inside Connected Wallet\nexport class WalletAccount extends Account implements AccountInterface {\n  public walletProvider: StarknetWalletProvider;\n\n  /**\n   * @deprecated Use static method WalletAccount.connect or WalletAccount.connectSilent instead. Constructor {@link WalletAccount.(format:2)}.\n   */\n  constructor(\n    providerOrOptions: ProviderOptions | ProviderInterface,\n    walletProvider: StarknetWalletProvider,\n    cairoVersion?: CairoVersion\n  );\n  constructor(\n    providerOrOptions: ProviderOptions | ProviderInterface,\n    walletProvider: StarknetWalletProvider,\n    cairoVersion?: CairoVersion,\n    address?: string\n  );\n  constructor(\n    providerOrOptions: ProviderOptions | ProviderInterface,\n    walletProvider: StarknetWalletProvider,\n    cairoVersion?: CairoVersion,\n    address: string = ''\n  ) {\n    super(providerOrOptions, address, '', cairoVersion); // At this point unknown address\n    this.walletProvider = walletProvider;\n\n    // Update Address on change\n    this.walletProvider.on('accountsChanged', (res) => {\n      if (!res) return;\n      this.address = res[0].toLowerCase();\n    });\n\n    // Update Channel chainId on Network change\n    this.walletProvider.on('networkChanged', (res) => {\n      if (!res) return;\n      // Determine is it better to set chainId or replace channel with new one\n      // At the moment channel is stateless but it could change\n      this.channel.setChainId(res as StarknetChainId);\n    });\n\n    if (!address.length) {\n      logger.warn(\n        '@deprecated Use static method WalletAccount.connect or WalletAccount.connectSilent instead. Constructor {@link WalletAccount.(format:2)}.'\n      );\n      requestAccounts(this.walletProvider).then(([accountAddress]) => {\n        this.address = accountAddress.toLowerCase();\n      });\n    }\n  }\n\n  /**\n   * WALLET EVENTS\n   */\n  public onAccountChange(callback: AccountChangeEventHandler): void {\n    onAccountChange(this.walletProvider, callback);\n  }\n\n  public onNetworkChanged(callback: NetworkChangeEventHandler): void {\n    onNetworkChanged(this.walletProvider, callback);\n  }\n\n  /**\n   * WALLET SPECIFIC METHODS\n   */\n  public requestAccounts(silentMode = false) {\n    return requestAccounts(this.walletProvider, silentMode);\n  }\n\n  public getPermissions() {\n    return getPermissions(this.walletProvider);\n  }\n\n  public switchStarknetChain(chainId: StarknetChainId) {\n    return switchStarknetChain(this.walletProvider, chainId);\n  }\n\n  public watchAsset(asset: WatchAssetParameters) {\n    return watchAsset(this.walletProvider, asset);\n  }\n\n  public addStarknetChain(chain: AddStarknetChainParameters) {\n    return addStarknetChain(this.walletProvider, chain);\n  }\n\n  /**\n   * ACCOUNT METHODS\n   */\n  override execute(calls: AllowArray<Call>) {\n    const txCalls = [].concat(calls as any).map((it) => {\n      const { contractAddress, entrypoint, calldata } = it;\n      return {\n        contract_address: contractAddress,\n        entry_point: entrypoint,\n        calldata,\n      };\n    });\n\n    const params = {\n      calls: txCalls,\n    };\n\n    return addInvokeTransaction(this.walletProvider, params);\n  }\n\n  override declare(payload: DeclareContractPayload) {\n    const declareContractPayload = extractContractHashes(payload);\n\n    // DISCUSS: HOTFIX: Adapt Abi format\n    const pContract = payload.contract as CompiledSierra;\n    const cairo1Contract = {\n      ...pContract,\n      abi: stringify(pContract.abi),\n    };\n\n    // Check FIx\n    if (!declareContractPayload.compiledClassHash) {\n      throw Error('compiledClassHash is required');\n    }\n\n    const params = {\n      compiled_class_hash: declareContractPayload.compiledClassHash,\n      contract_class: cairo1Contract,\n    };\n\n    return addDeclareTransaction(this.walletProvider, params);\n  }\n\n  override async deploy(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[]\n  ): Promise<MultiDeployContractResponse> {\n    const { calls, addresses } = buildUDCCall(payload, this.address);\n    const invokeResponse = await this.execute(calls);\n\n    return {\n      ...invokeResponse,\n      contract_address: addresses,\n    };\n  }\n\n  override signMessage(typedData: TypedData): Promise<Signature> {\n    return signMessage(this.walletProvider, typedData);\n  }\n\n  static async connect(\n    provider: ProviderInterface,\n    walletProvider: StarknetWalletProvider,\n    cairoVersion?: CairoVersion,\n    silentMode: boolean = false\n  ) {\n    const [accountAddress] = await requestAccounts(walletProvider, silentMode);\n    return new WalletAccount(provider, walletProvider, cairoVersion, accountAddress);\n  }\n\n  static async connectSilent(\n    provider: ProviderInterface,\n    walletProvider: StarknetWalletProvider,\n    cairoVersion?: CairoVersion\n  ) {\n    return WalletAccount.connect(provider, walletProvider, cairoVersion, true);\n  }\n\n  // TODO: MISSING ESTIMATES\n}\n","import type { Abi as AbiKanabi, TypedContract as AbiWanTypedContract } from 'abi-wan-kanabi';\n\nimport { AccountInterface } from '../account';\nimport { ProviderInterface, defaultProvider } from '../provider';\nimport {\n  Abi,\n  AbiEvents,\n  ArgsOrCalldata,\n  ArgsOrCalldataWithOptions,\n  AsyncContractFunction,\n  Call,\n  CallOptions,\n  Calldata,\n  ContractFunction,\n  ContractOptions,\n  EstimateFeeResponse,\n  FunctionAbi,\n  InvokeFunctionResponse,\n  InvokeOptions,\n  InvokeTransactionReceiptResponse,\n  ParsedEvents,\n  RawArgs,\n  Result,\n  AbiStruct,\n  ValidateType,\n  type SuccessfulTransactionReceiptResponse,\n} from '../types';\nimport assert from '../utils/assert';\nimport { cairo, CallData } from '../utils/calldata';\nimport { createAbiParser } from '../utils/calldata/parser';\nimport { getAbiEvents, parseEvents as parseRawEvents } from '../utils/events/index';\nimport { cleanHex } from '../utils/num';\nimport { ContractInterface } from './interface';\nimport type { GetTransactionReceiptResponse } from '../utils/transactionReceipt';\nimport type { INVOKE_TXN_RECEIPT } from '../types/provider/spec';\nimport { logger } from '../global/logger';\n\nexport type TypedContractV2<TAbi extends AbiKanabi> = AbiWanTypedContract<TAbi> & Contract;\n\nexport const splitArgsAndOptions = (args: ArgsOrCalldataWithOptions) => {\n  const options = [\n    'blockIdentifier',\n    'parseRequest',\n    'parseResponse',\n    'formatResponse',\n    'maxFee',\n    'nonce',\n    'signature',\n    'addressSalt',\n  ];\n  const lastArg = args[args.length - 1];\n  if (typeof lastArg === 'object' && options.some((x) => x in lastArg)) {\n    return { args: args as ArgsOrCalldata, options: args.pop() as ContractOptions };\n  }\n  return { args: args as ArgsOrCalldata };\n};\n\n/**\n * Adds call methods to the contract\n */\nfunction buildCall(contract: Contract, functionAbi: FunctionAbi): AsyncContractFunction {\n  return async function (...args: ArgsOrCalldataWithOptions): Promise<any> {\n    const params = splitArgsAndOptions(args);\n    return contract.call(functionAbi.name, params.args, {\n      parseRequest: true,\n      parseResponse: true,\n      ...params.options,\n    });\n  };\n}\n\n/**\n * Adds invoke methods to the contract\n */\nfunction buildInvoke(contract: Contract, functionAbi: FunctionAbi): AsyncContractFunction {\n  return async function (...args: Array<any>): Promise<any> {\n    const params = splitArgsAndOptions(args);\n    return contract.invoke(functionAbi.name, params.args, {\n      parseRequest: true,\n      ...params.options,\n    });\n  };\n}\n\n/**\n * Adds call/invoke methods to the contract\n */\nfunction buildDefault(contract: Contract, functionAbi: FunctionAbi): AsyncContractFunction {\n  if (functionAbi.stateMutability === 'view' || functionAbi.state_mutability === 'view') {\n    return buildCall(contract, functionAbi);\n  }\n  return buildInvoke(contract, functionAbi);\n}\n\n/**\n * Adds populate for methods to the contract\n */\nfunction buildPopulate(contract: Contract, functionAbi: FunctionAbi): ContractFunction {\n  return function (...args: Array<any>): any {\n    return contract.populate(functionAbi.name, args);\n  };\n}\n\n/**\n * Adds estimateFee for methods to the contract\n */\nfunction buildEstimate(contract: Contract, functionAbi: FunctionAbi): ContractFunction {\n  return function (...args: Array<any>): any {\n    return contract.estimate(functionAbi.name, args);\n  };\n}\n\nexport function getCalldata(args: RawArgs, callback: Function): Calldata {\n  // Check if Calldata in args or args[0] else compile\n  if (Array.isArray(args) && '__compiled__' in args) return args as Calldata;\n  if (Array.isArray(args) && Array.isArray(args[0]) && '__compiled__' in args[0])\n    return args[0] as Calldata;\n  return callback();\n}\n\nexport class Contract implements ContractInterface {\n  abi: Abi;\n\n  address: string;\n\n  providerOrAccount: ProviderInterface | AccountInterface;\n\n  deployTransactionHash?: string;\n\n  protected readonly structs: { [name: string]: AbiStruct };\n\n  protected readonly events: AbiEvents;\n\n  readonly functions!: { [name: string]: AsyncContractFunction };\n\n  readonly callStatic!: { [name: string]: AsyncContractFunction };\n\n  readonly populateTransaction!: { [name: string]: ContractFunction };\n\n  readonly estimateFee!: { [name: string]: ContractFunction };\n\n  readonly [key: string]: AsyncContractFunction | any;\n\n  private callData: CallData;\n\n  /**\n   * Contract class to handle contract methods\n   *\n   * @param abi - Abi of the contract object\n   * @param address (optional) - address to connect to\n   * @param providerOrAccount (optional) - Provider or Account to attach to\n   */\n  constructor(\n    abi: Abi,\n    address: string,\n    providerOrAccount: ProviderInterface | AccountInterface = defaultProvider\n  ) {\n    this.address = address && address.toLowerCase();\n    this.providerOrAccount = providerOrAccount;\n    this.callData = new CallData(abi);\n    this.structs = CallData.getAbiStruct(abi);\n    this.events = getAbiEvents(abi);\n    const parser = createAbiParser(abi);\n    this.abi = parser.getLegacyFormat();\n\n    const options = { enumerable: true, value: {}, writable: false };\n    Object.defineProperties(this, {\n      functions: { enumerable: true, value: {}, writable: false },\n      callStatic: { enumerable: true, value: {}, writable: false },\n      populateTransaction: { enumerable: true, value: {}, writable: false },\n      estimateFee: { enumerable: true, value: {}, writable: false },\n    });\n    this.abi.forEach((abiElement) => {\n      if (abiElement.type !== 'function') return;\n      const signature = abiElement.name;\n      if (!this[signature]) {\n        Object.defineProperty(this, signature, {\n          ...options,\n          value: buildDefault(this, abiElement),\n        });\n      }\n      if (!this.functions[signature]) {\n        Object.defineProperty(this.functions, signature, {\n          ...options,\n          value: buildDefault(this, abiElement),\n        });\n      }\n      if (!this.callStatic[signature]) {\n        Object.defineProperty(this.callStatic, signature, {\n          ...options,\n          value: buildCall(this, abiElement),\n        });\n      }\n      if (!this.populateTransaction[signature]) {\n        Object.defineProperty(this.populateTransaction, signature, {\n          ...options,\n          value: buildPopulate(this, abiElement),\n        });\n      }\n      if (!this.estimateFee[signature]) {\n        Object.defineProperty(this.estimateFee, signature, {\n          ...options,\n          value: buildEstimate(this, abiElement),\n        });\n      }\n    });\n  }\n\n  public attach(address: string): void {\n    this.address = address;\n  }\n\n  public connect(providerOrAccount: ProviderInterface | AccountInterface) {\n    this.providerOrAccount = providerOrAccount;\n  }\n\n  public async deployed(): Promise<Contract> {\n    if (this.deployTransactionHash) {\n      await this.providerOrAccount.waitForTransaction(this.deployTransactionHash);\n      this.deployTransactionHash = undefined;\n    }\n    return this;\n  }\n\n  public async call(\n    method: string,\n    args: ArgsOrCalldata = [],\n    {\n      parseRequest = true,\n      parseResponse = true,\n      formatResponse = undefined,\n      blockIdentifier = undefined,\n    }: CallOptions = {}\n  ): Promise<Result> {\n    assert(this.address !== null, 'contract is not connected to an address');\n\n    const calldata = getCalldata(args, () => {\n      if (parseRequest) {\n        this.callData.validate(ValidateType.CALL, method, args);\n        return this.callData.compile(method, args);\n      }\n      logger.warn('Call skipped parsing but provided rawArgs, possible malfunction request');\n      return args;\n    });\n\n    return this.providerOrAccount\n      .callContract(\n        {\n          contractAddress: this.address,\n          calldata,\n          entrypoint: method,\n        },\n        blockIdentifier\n      )\n      .then((it) => {\n        if (!parseResponse) {\n          return it;\n        }\n        if (formatResponse) {\n          return this.callData.format(method, it, formatResponse);\n        }\n        return this.callData.parse(method, it);\n      });\n  }\n\n  public invoke(\n    method: string,\n    args: ArgsOrCalldata = [],\n    { parseRequest = true, maxFee, nonce, signature }: InvokeOptions = {}\n  ): Promise<InvokeFunctionResponse> {\n    assert(this.address !== null, 'contract is not connected to an address');\n\n    const calldata = getCalldata(args, () => {\n      if (parseRequest) {\n        this.callData.validate(ValidateType.INVOKE, method, args);\n        return this.callData.compile(method, args);\n      }\n      logger.warn('Invoke skipped parsing but provided rawArgs, possible malfunction request');\n      return args;\n    });\n\n    const invocation = {\n      contractAddress: this.address,\n      calldata,\n      entrypoint: method,\n    };\n    if ('execute' in this.providerOrAccount) {\n      return this.providerOrAccount.execute(invocation, undefined, {\n        maxFee,\n        nonce,\n      });\n    }\n\n    if (!nonce) throw new Error(`Nonce is required when invoking a function without an account`);\n    logger.warn(`Invoking ${method} without an account. This will not work on a public node.`);\n\n    return this.providerOrAccount.invokeFunction(\n      {\n        ...invocation,\n        signature,\n      },\n      {\n        nonce,\n      }\n    );\n  }\n\n  public async estimate(method: string, args: ArgsOrCalldata = []): Promise<EstimateFeeResponse> {\n    assert(this.address !== null, 'contract is not connected to an address');\n\n    if (!getCalldata(args, () => false)) {\n      this.callData.validate(ValidateType.INVOKE, method, args);\n    }\n\n    const invocation = this.populate(method, args);\n    if ('estimateInvokeFee' in this.providerOrAccount) {\n      return this.providerOrAccount.estimateInvokeFee(invocation);\n    }\n    throw Error('Contract must be connected to the account contract to estimate');\n  }\n\n  public populate(method: string, args: RawArgs = []): Call {\n    const calldata: Calldata = getCalldata(args, () => this.callData.compile(method, args));\n    return {\n      contractAddress: this.address,\n      entrypoint: method,\n      calldata,\n    };\n  }\n\n  public parseEvents(receipt: GetTransactionReceiptResponse): ParsedEvents {\n    let parsed: ParsedEvents;\n    receipt.match({\n      success: (txR: SuccessfulTransactionReceiptResponse) => {\n        const emittedEvents =\n          (txR as InvokeTransactionReceiptResponse).events\n            ?.map((event) => {\n              return {\n                block_hash: (txR as INVOKE_TXN_RECEIPT).block_hash,\n                block_number: (txR as INVOKE_TXN_RECEIPT).block_number,\n                transaction_hash: (txR as INVOKE_TXN_RECEIPT).transaction_hash,\n                ...event,\n              };\n            })\n            .filter((event) => cleanHex(event.from_address) === cleanHex(this.address), []) || [];\n        parsed = parseRawEvents(\n          emittedEvents,\n          this.events,\n          this.structs,\n          CallData.getAbiEnum(this.abi)\n        );\n      },\n      _: () => {\n        throw Error('This transaction was not successful.');\n      },\n    });\n    return parsed!;\n  }\n\n  public isCairo1(): boolean {\n    return cairo.isCairo1Abi(this.abi);\n  }\n\n  public async getVersion() {\n    return this.providerOrAccount.getContractVersion(this.address);\n  }\n\n  public typedv2<TAbi extends AbiKanabi>(tAbi: TAbi): TypedContractV2<TAbi> {\n    return this as unknown as TypedContractV2<typeof tAbi>;\n  }\n}\n","import type { Abi as AbiKanabi, TypedContract as AbiWanTypedContract } from 'abi-wan-kanabi';\n\nimport { AccountInterface } from '../account';\nimport { ProviderInterface } from '../provider';\nimport {\n  Abi,\n  ArgsOrCalldata,\n  AsyncContractFunction,\n  BigNumberish,\n  BlockIdentifier,\n  CallOptions,\n  Calldata,\n  ContractFunction,\n  ContractVersion,\n  EstimateFeeResponse,\n  Invocation,\n  InvokeFunctionResponse,\n  InvokeOptions,\n  ParsedEvents,\n  RawArgs,\n  Result,\n  Uint256,\n} from '../types';\nimport { CairoCustomEnum } from '../utils/calldata/enum/CairoCustomEnum';\nimport { CairoOption } from '../utils/calldata/enum/CairoOption';\nimport { CairoResult } from '../utils/calldata/enum/CairoResult';\nimport type { GetTransactionReceiptResponse } from '../utils/transactionReceipt';\n\ndeclare module 'abi-wan-kanabi' {\n  export interface Config<OptionT = any, ResultT = any, ErrorT = any> {\n    FeltType: BigNumberish;\n    U256Type: number | bigint | Uint256;\n    U512Type: BigNumberish;\n    Secp256k1PointType: BigNumberish;\n    Option: CairoOption<OptionT>;\n    Tuple: Record<number, BigNumberish | object | boolean>;\n    Result: CairoResult<ResultT, ErrorT>;\n    Enum: CairoCustomEnum;\n    Calldata: RawArgs | Calldata;\n    CallOptions: CallOptions;\n    InvokeOptions: InvokeOptions;\n    InvokeFunctionResponse: InvokeFunctionResponse;\n  }\n}\n\ntype TypedContractV2<TAbi extends AbiKanabi> = AbiWanTypedContract<TAbi> & ContractInterface;\n\nexport abstract class ContractInterface {\n  public abstract abi: Abi;\n\n  public abstract address: string;\n\n  public abstract providerOrAccount: ProviderInterface | AccountInterface;\n\n  public abstract deployTransactionHash?: string;\n\n  readonly functions!: { [name: string]: AsyncContractFunction };\n\n  readonly callStatic!: { [name: string]: AsyncContractFunction };\n\n  readonly populateTransaction!: { [name: string]: ContractFunction };\n\n  readonly estimateFee!: { [name: string]: ContractFunction };\n\n  readonly [key: string]: AsyncContractFunction | any;\n\n  /**\n   * Saves the address of the contract deployed on network that will be used for interaction\n   *\n   * @param address - address of the contract\n   */\n  public abstract attach(address: string): void;\n\n  /**\n   * Attaches to new Provider or Account\n   *\n   * @param providerOrAccount - new Provider or Account to attach to\n   */\n  public abstract connect(providerOrAccount: ProviderInterface | AccountInterface): void;\n\n  /**\n   * Resolves when contract is deployed on the network or when no deployment transaction is found\n   *\n   * @returns Promise that resolves when contract is deployed on the network or when no deployment transaction is found\n   * @throws When deployment fails\n   */\n  public abstract deployed(): Promise<ContractInterface>;\n\n  /**\n   * Calls a method on a contract\n   *\n   * @param method name of the method\n   * @param args Array of the arguments for the call\n   * @param options optional blockIdentifier\n   * @returns Result of the call as an array with key value pars\n   */\n  public abstract call(\n    method: string,\n    args?: ArgsOrCalldata,\n    options?: CallOptions\n  ): Promise<Result>;\n\n  /**\n   * Invokes a method on a contract\n   *\n   * @param method name of the method\n   * @param args Array of the arguments for the invoke or Calldata\n   * @param options\n   * @returns Add Transaction Response\n   */\n  public abstract invoke(\n    method: string,\n    args?: ArgsOrCalldata,\n    options?: InvokeOptions\n  ): Promise<InvokeFunctionResponse>;\n\n  /**\n   * Estimates a method on a contract\n   *\n   * @param method name of the method\n   * @param args Array of the arguments for the call or Calldata\n   * @param options optional blockIdentifier\n   */\n  public abstract estimate(\n    method: string,\n    args?: ArgsOrCalldata,\n    options?: {\n      blockIdentifier?: BlockIdentifier;\n    }\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Calls a method on a contract\n   *\n   * @param method name of the method\n   * @param args Array of the arguments for the call or Calldata\n   * @returns Invocation object\n   */\n  public abstract populate(method: string, args?: ArgsOrCalldata): Invocation;\n\n  /**\n   * Parse contract events of a GetTransactionReceiptResponse received from waitForTransaction. Based on contract's abi\n   *\n   * @param receipt transaction receipt\n   * @returns Events parsed\n   */\n  public abstract parseEvents(receipt: GetTransactionReceiptResponse): ParsedEvents;\n\n  /**\n   * tells if the contract comes from a Cairo 1 contract\n   *\n   * @returns TRUE if the contract comes from a Cairo1 contract\n   * @example\n   * ```typescript\n   * const isCairo1: boolean = myContract.isCairo1();\n   * ```\n   */\n  public abstract isCairo1(): boolean;\n\n  /**\n   * Retrieves the version of the contract (cairo version & compiler version)\n   */\n  public abstract getVersion(): Promise<ContractVersion>;\n\n  /**\n   * Returns a typed instance of ContractV2 based on the supplied ABI.\n   *\n   * @param {TAbi} tAbi - The ABI (Abstract Binary Interface) of the ContractV2.\n   * @return {TypedContractV2<TAbi>} - A typed instance of ContractV2.\n   */\n  public abstract typedv2<TAbi extends AbiKanabi>(tAbi: TAbi): TypedContractV2<TAbi>;\n}\n","import { AccountInterface } from '../account';\nimport { logger } from '../global/logger';\nimport {\n  Abi,\n  ArgsOrCalldataWithOptions,\n  CairoAssembly,\n  CompiledContract,\n  ValidateType,\n} from '../types';\nimport assert from '../utils/assert';\nimport { CallData } from '../utils/calldata';\nimport { Contract, getCalldata, splitArgsAndOptions } from './default';\n\nexport type ContractFactoryParams = {\n  compiledContract: CompiledContract;\n  account: any;\n  casm?: CairoAssembly;\n  classHash?: string;\n  compiledClassHash?: string;\n  abi?: Abi;\n};\n\nexport class ContractFactory {\n  compiledContract: CompiledContract;\n\n  account: AccountInterface;\n\n  abi: Abi;\n\n  classHash?: string;\n\n  casm?: CairoAssembly;\n\n  compiledClassHash?: string;\n\n  private CallData: CallData;\n\n  /**\n   * @param params CFParams\n   *  - compiledContract: CompiledContract;\n   *  - account: AccountInterface;\n   *  - casm?: CairoAssembly;\n   *  - classHash?: string;\n   *  - compiledClassHash?: string;\n   *  - abi?: Abi;\n   */\n  constructor(params: ContractFactoryParams) {\n    this.compiledContract = params.compiledContract;\n    this.account = params.account;\n    this.casm = params.casm;\n    this.abi = params.abi ?? params.compiledContract.abi;\n    this.classHash = params.classHash;\n    this.compiledClassHash = params.compiledClassHash;\n    this.CallData = new CallData(this.abi);\n  }\n\n  /**\n   * Deploys contract and returns new instance of the Contract\n   *\n   * If contract is not declared it will first declare it, and then deploy\n   */\n  public async deploy(...args: ArgsOrCalldataWithOptions): Promise<Contract> {\n    const { args: param, options = { parseRequest: true } } = splitArgsAndOptions(args);\n\n    const constructorCalldata = getCalldata(param, () => {\n      if (options.parseRequest) {\n        this.CallData.validate(ValidateType.DEPLOY, 'constructor', param);\n        return this.CallData.compile('constructor', param);\n      }\n      logger.warn('Call skipped parsing but provided rawArgs, possible malfunction request');\n      return param;\n    });\n\n    const {\n      deploy: { contract_address, transaction_hash },\n    } = await this.account.declareAndDeploy({\n      contract: this.compiledContract,\n      casm: this.casm,\n      classHash: this.classHash,\n      compiledClassHash: this.compiledClassHash,\n      constructorCalldata,\n      salt: options.addressSalt,\n    });\n    assert(Boolean(contract_address), 'Deployment of the contract failed');\n\n    const contractInstance = new Contract(\n      this.compiledContract.abi,\n      contract_address!,\n      this.account\n    );\n    contractInstance.deployTransactionHash = transaction_hash;\n\n    return contractInstance;\n  }\n\n  /**\n   * Attaches to new Account\n   *\n   * @param account - new Account to attach to\n   */\n  connect(account: AccountInterface): ContractFactory {\n    this.account = account;\n    return this;\n  }\n\n  /**\n   * Attaches current abi and account to the new address\n   */\n  attach(address: string): Contract {\n    return new Contract(this.abi, address, this.account);\n  }\n\n  // ethers.js' getDeployTransaction can't be supported as it requires the account or signer to return a signed transaction which is not possible with the current implementation\n}\n","import {\n  BlockWithTxHashes,\n  FeeEstimate,\n  CallContractResponse,\n  DeclareContractResponse,\n  DeployContractResponse,\n  EstimateFeeResponse,\n  GetBlockResponse,\n  GetTransactionResponse,\n  InvokeFunctionResponse,\n  SimulateTransactionResponse,\n} from '../../types';\nimport type { GetTransactionReceiptResponse } from '../transactionReceipt';\n\nexport abstract class ResponseParser {\n  abstract parseGetBlockResponse(res: BlockWithTxHashes): GetBlockResponse;\n\n  abstract parseGetTransactionResponse(res: any): GetTransactionResponse;\n\n  abstract parseGetTransactionReceiptResponse(res: any): GetTransactionReceiptResponse;\n\n  abstract parseFeeEstimateResponse(res: FeeEstimate[]): EstimateFeeResponse;\n\n  abstract parseCallContractResponse(res: any): CallContractResponse;\n\n  abstract parseInvokeFunctionResponse(res: any): InvokeFunctionResponse;\n\n  abstract parseDeployContractResponse(res: any): DeployContractResponse;\n\n  abstract parseDeclareContractResponse(res: any): DeclareContractResponse;\n\n  abstract parseSimulateTransactionResponse(res: any): SimulateTransactionResponse;\n}\n","import { isHex } from './num';\n\n/**\n * Convert strk to fri or fri to strk\n * @example\n * ```typescript\n * units(1000n, 'fri') // '0.000000000000001' strk\n * units('1', 'strk') // '1000000000000000000' fri\n * ```\n */\nexport function units(amount: string | bigint, simbol: 'fri' | 'strk' = 'fri') {\n  if (simbol === 'strk') {\n    let numStr = '';\n    if (typeof amount === 'bigint') numStr = amount.toString();\n    else if (typeof amount === 'string') {\n      if (isHex(amount)) {\n        numStr = BigInt(amount).toString();\n      } else {\n        numStr = amount;\n      }\n    }\n\n    const [integer, decimal = '0'] = numStr.split('.');\n    const pdec = decimal.padEnd(18, '0');\n    return `${integer}${pdec}`.replace(/\\b0+/g, '');\n  }\n\n  const bis = BigInt(amount).toString();\n  let strk;\n  if (bis.length <= 18) {\n    strk = `0.${bis.padStart(18, '0')}`;\n  } else {\n    strk = `${bis.slice(0, bis.length - 18)}.${bis.slice(bis.length - 18)}`;\n  }\n\n  return strk.replace(/(\\.[0-9]*[1-9])0+$|\\.0*$/, '$1');\n}\n"],"mappings":"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","names":["RpcProvider","RpcChannel","BaseUrl","NetworkName","StarknetChainId","TransactionHashPrefix","FeeMarginPercentage","parse","stringify","stringify","OutsideExecutionVersion","stringify","number","hexToBytesNoble","import_utils","listTypeVariant","parsedParameter","parseBaseTypes","calculateDeclareTransactionHash","calculateDeployAccountTransactionHash","calculateInvokeTransactionHash","computeHashOnElements","calculateDeclareTransactionHash","calculateDeployAccountTransactionHash","calculateTransactionHashCommon","import_starknet","calculateTransactionHashCommon","calculateDeployAccountTransactionHash","calculateDeclareTransactionHash","calculateInvokeTransactionHash","calculateDeclareTransactionHash","calculateDeployAccountTransactionHash","import_starknet","computeHashOnElements","json","stringify","parse","import_starknet","stringify","base64","parse","parse","makeFetchCookie","isomorphicFetch","stringify","parse","stringify","error","result","RpcChannel","defaultOptions","RpcChannel","stringify","error","result","RpcChannel","StarknetIdContract","StarknetIdIdentityContract","StarknetIdVerifierContract","StarknetIdPfpContract","StarknetIdPopContract","StarknetIdMulticallContract","RpcProvider","calculateInvokeTransactionHash","calculateDeployAccountTransactionHash","calculateDeclareTransactionHash","import_secp256k1","uint256","calculateInvokeTransactionHash","calculateDeployAccountTransactionHash","calculateDeclareTransactionHash","calculateInvokeTransactionHash","calculateDeployAccountTransactionHash","calculateDeclareTransactionHash","import_utils","calculateInvokeTransactionHash","calculateDeployAccountTransactionHash","execution","RpcProvider","StarknetIdContract","stringify"]}